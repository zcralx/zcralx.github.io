<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zcralx.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"show_result":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="[TOC] 前言：了解一下JVM(java虚拟机)当前市面上使用范围最广的，是Sun&#x2F;OracleJDK或者OpenJDK中默认的 HotSpot 虚拟机。 市面上还存在很多非常优秀的Java虚拟机，它们都遵循Java虚拟机规范，但具体的实现上各有特点，在某一个领域拥有突出的性能优势是它们最重要的卖点。例如IBM的J9，Azul Systems 的 Azul VM 等等。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="https://zcralx.github.io/posts/66c016fb/index.html">
<meta property="og:site_name" content="zcralx&#39;s blog">
<meta property="og:description" content="[TOC] 前言：了解一下JVM(java虚拟机)当前市面上使用范围最广的，是Sun&#x2F;OracleJDK或者OpenJDK中默认的 HotSpot 虚拟机。 市面上还存在很多非常优秀的Java虚拟机，它们都遵循Java虚拟机规范，但具体的实现上各有特点，在某一个领域拥有突出的性能优势是它们最重要的卖点。例如IBM的J9，Azul Systems 的 Azul VM 等等。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zcralx.github.io/assets/img/02.png">
<meta property="og:image" content="https://zcralx.github.io/assets/img/bytecode.png">
<meta property="og:image" content="https://zcralx.github.io/assets/img/09.png">
<meta property="article:published_time" content="2024-04-03T12:39:40.000Z">
<meta property="article:modified_time" content="2024-04-10T12:40:31.393Z">
<meta property="article:author" content="魚">
<meta property="article:tag" content="GC">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="字节码">
<meta property="article:tag" content="类的加载">
<meta property="article:tag" content="常量池">
<meta property="article:tag" content="对象的生命周期">
<meta property="article:tag" content="反编译">
<meta property="article:tag" content="面试题">
<meta property="article:tag" content="引用">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zcralx.github.io/assets/img/02.png">


<link rel="canonical" href="https://zcralx.github.io/posts/66c016fb/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zcralx.github.io/posts/66c016fb/","path":"posts/66c016fb/","title":"JVM"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM | zcralx's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">zcralx's blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">多喜乐，长安宁，愿你一切都好</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">29</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">12</span></a></li><li class="menu-item menu-item-象棋"><a href="/xiangqi/" rel="section"><i class="fa fa-chess-rook fa-fw"></i>象棋</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">
  
    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BJVM-java%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">1.</span> <span class="nav-text">前言：了解一下JVM(java虚拟机)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.1.</span> <span class="nav-text">JVM的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E5%BC%80%E5%A7%8B%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">何时开始？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E7%BB%93%E6%9D%9F%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">何时结束？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-number">1.2.</span> <span class="nav-text">JVM执行引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javap%E5%8F%8D%E7%BC%96%E8%AF%91"><span class="nav-number">1.3.</span> <span class="nav-text">javap反编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.4.</span> <span class="nav-text">常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%88Literal%EF%BC%89-%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%EF%BC%88Symbolic-References%EF%BC%89"><span class="nav-number">1.4.1.</span> <span class="nav-text">字面量（Literal） &amp; 符号引用（Symbolic References）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88Runtime-Constant-Pool%EF%BC%89"><span class="nav-number">1.4.2.</span> <span class="nav-text">运行时常量池（Runtime Constant Pool）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88String-Constant-Pool%EF%BC%89-%E5%85%B6%E4%BB%96%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E9%87%8C%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.4.3.</span> <span class="nav-text">字符串常量池（String Constant Pool） &amp; 其他包装类型里实现的常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String-intern-%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">String.intern()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%91%A2%EF%BC%9F"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">以下创建了多少个对象呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">基本类型的包装类和常量池</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E4%B9%8B%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.</span> <span class="nav-text">JVM之字节码与类的加载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Class%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">Class文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8BClass%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.1.</span> <span class="nav-text">查看Class文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class%E6%96%87%E4%BB%B6%E7%BB%84%E6%88%90"><span class="nav-number">2.1.2.</span> <span class="nav-text">Class文件组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AD%94%E6%95%B0%EF%BC%88cafebabe%EF%BC%89"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">魔数（cafebabe）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">版本号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0-1"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">常量池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%A0%87%E8%AE%B0-Access-flags"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">访问标记(Access flags)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.2.5.</span> <span class="nav-text">类索引、父类索引和接口索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E5%80%BC%E5%AE%9A%E4%BD%8D%E5%88%B0%E5%9C%A8Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="nav-number">2.1.2.5.1.</span> <span class="nav-text">如何通过索引值定位到在Class文件中的位置？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E8%A1%A8"><span class="nav-number">2.1.2.6.</span> <span class="nav-text">字段表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="nav-number">2.1.2.7.</span> <span class="nav-text">方法表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8"><span class="nav-number">2.1.2.8.</span> <span class="nav-text">属性表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">2.2.</span> <span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">了解类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%B1%BB"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">命名空间：存储加载的类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.2.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.3.</span> <span class="nav-text">类的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%BF%98%E6%9C%AA%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">2.2.3.4.1.</span> <span class="nav-text">引用的类型，还未加载初始化怎么办？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">2.2.3.4.2.</span> <span class="nav-text">解析的时机</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.2.3.5.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.2.3.5.1.</span> <span class="nav-text">&lt;clinit&gt;() 方法的作用是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA"><span class="nav-number">2.2.3.5.2.</span> <span class="nav-text">初始化时机</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.3.6.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD"><span class="nav-number">2.2.3.7.</span> <span class="nav-text">卸载</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E4%B9%8B%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">3.</span> <span class="nav-text">JVM之内存与垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">JVM内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%88java-heap"><span class="nav-number">3.1.1.</span> <span class="nav-text">堆内存（java heap)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E5%8C%BA"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">堆内存的分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">堆内存的基本知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLAB%EF%BC%88Thread-Local-Allocation-Buffer%EF%BC%89"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">TLAB（Thread Local Allocation Buffer）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">3.1.2.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">方法区内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">3.1.2.1.1.</span> <span class="nav-text">类型信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0-2"><span class="nav-number">3.1.2.1.2.</span> <span class="nav-text">常量池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%9F%E4%BF%A1%E6%81%AF"><span class="nav-number">3.1.2.1.3.</span> <span class="nav-text">域信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF"><span class="nav-number">3.1.2.1.4.</span> <span class="nav-text">方法信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">3.1.2.1.5.</span> <span class="nav-text">静态变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-number">3.1.2.1.6.</span> <span class="nav-text">类加载器引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Class%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="nav-number">3.1.2.1.7.</span> <span class="nav-text">Class对象引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8-1"><span class="nav-number">3.1.2.1.8.</span> <span class="nav-text">方法表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B%E6%A0%88%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%8E%E5%A0%86%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">简单认识一下栈、方法区与堆之间的联系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC-Register%EF%BC%89"><span class="nav-number">3.1.3.</span> <span class="nav-text">程序计数器（PC Register）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">3.1.4.</span> <span class="nav-text">虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">基本特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89"><span class="nav-number">3.1.4.1.1.</span> <span class="nav-text">线程私有</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7%EF%BC%88Stack-Frame%EF%BC%89"><span class="nav-number">3.1.4.1.2.</span> <span class="nav-text">栈帧（Stack Frame）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E6%A0%88%E5%B8%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.1.4.1.3.</span> <span class="nav-text">方法调用与栈帧生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%9B%9E%E6%BA%AF"><span class="nav-number">3.1.4.1.4.</span> <span class="nav-text">异常处理与回溯</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%99%90%E5%88%B6%E4%B8%8E%E8%B0%83%E6%95%B4"><span class="nav-number">3.1.4.1.5.</span> <span class="nav-text">栈大小的限制与调整</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stack%EF%BC%89"><span class="nav-number">3.1.5.</span> <span class="nav-text">本地方法栈（Native Method Stack）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">启用时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3-JNI"><span class="nav-number">3.1.5.2.</span> <span class="nav-text">本地方法接口(JNI)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.5.2.1.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="nav-number">3.1.5.2.2.</span> <span class="nav-text">副作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.1.5.2.3.</span> <span class="nav-text">操作步骤</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6-Copying-%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">3.2.1.</span> <span class="nav-text">复制(Copying)算法（标记-复制算法）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E6%9C%BA%E5%88%B6"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">分配担保机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95-Mark-Sweep"><span class="nav-number">3.2.2.</span> <span class="nav-text">标记-清除算法(Mark-Sweep)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%EF%BC%89-Mark-Compact"><span class="nav-number">3.2.3.</span> <span class="nav-text">标记-压缩算法（标记-整理）(Mark-Compact)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">3.3.</span> <span class="nav-text">垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Minor-GC"><span class="nav-number">3.3.1.</span> <span class="nav-text">Minor GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Major-GC"><span class="nav-number">3.3.2.</span> <span class="nav-text">Major GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Full-GC"><span class="nav-number">3.3.3.</span> <span class="nav-text">Full GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mixed-GC"><span class="nav-number">3.3.4.</span> <span class="nav-text">Mixed GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stop-The-World-STW"><span class="nav-number">3.3.5.</span> <span class="nav-text">Stop The World(STW)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="nav-number">3.3.6.</span> <span class="nav-text">判断对象是否可以回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E6%A0%B9%E8%8A%82%E7%82%B9-GC-Roots-%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.3.6.1.</span> <span class="nav-text">可以作为根节点(GC Roots)的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0GC-Roots"><span class="nav-number">3.3.6.2.</span> <span class="nav-text">如何找到GC Roots?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.4.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-XX-UseSerialGC-SerialOld"><span class="nav-number">3.4.1.</span> <span class="nav-text">Serial(-XX:+UseSerialGC) &amp; SerialOld</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew-XX-UseParNewGC-CMS-XX-UseConcMarkSweepGC"><span class="nav-number">3.4.2.</span> <span class="nav-text">ParNew(-XX:+UseParNewGC) &amp; CMS(-XX:+UseConcMarkSweepGC)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ParNew"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">ParNew</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">CMS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">3.4.2.2.1.</span> <span class="nav-text">CMS运行过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">3.4.2.2.2.</span> <span class="nav-text">CMS的缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Scavenge-XX-UseParallelGC-Parallel-Old-XX-UseParallelOldGC"><span class="nav-number">3.4.3.</span> <span class="nav-text">Parallel Scavenge(-XX:+UseParallelGC) &amp; Parallel Old(-XX:+UseParallelOldGC)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Scavenge"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">Parallel Scavenge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Old"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">Parallel Old</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Garbage-First%EF%BC%88G1%EF%BC%89"><span class="nav-number">3.4.4.</span> <span class="nav-text">Garbage First（G1）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">运行过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8DGC-%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.4.4.2.</span> <span class="nav-text">三种GC 模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E5%8F%AF%E6%8E%A7%E7%9A%84%EF%BC%9F"><span class="nav-number">3.4.4.3.</span> <span class="nav-text">G1是如何保证停顿时间可控的？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZGC"><span class="nav-number">3.4.5.</span> <span class="nav-text">ZGC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#G1%E7%9A%84%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88ZGC%E8%83%BD%E5%81%9A%E5%88%B0%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E5%A6%82%E6%AD%A4%E7%9F%AD%E6%9A%82%EF%BC%9F"><span class="nav-number">3.4.5.1.</span> <span class="nav-text">G1的性能瓶颈（为什么ZGC能做到停顿时间如此短暂？)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZGC-%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84%EF%BC%9A%E6%8C%87%E9%92%88%E6%9F%93%E8%89%B2-%E8%AF%BB%E5%B1%8F%E9%9A%9C"><span class="nav-number">3.4.5.2.</span> <span class="nav-text">ZGC 是怎么做到的：指针染色 &amp; 读屏障</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%88%91%E7%9A%84GC%E5%99%A8"><span class="nav-number">3.4.6.</span> <span class="nav-text">查看我的GC器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">3.5.</span> <span class="nav-text">分代垃圾回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3"><span class="nav-number">3.5.1.</span> <span class="nav-text">年轻代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%A4%E5%9D%97Survivor%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">为什么要两块Survivor空间？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B4%E8%80%81%E4%BB%A3"><span class="nav-number">3.5.2.</span> <span class="nav-text">年老代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.5.3.</span> <span class="nav-text">跨代引用的问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">4.</span> <span class="nav-text">JVM之对象的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%98%B6%E6%AE%B5"><span class="nav-number">4.1.</span> <span class="nav-text">创建阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E9%98%B6%E6%AE%B5"><span class="nav-number">4.2.</span> <span class="nav-text">应用阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8-StrongReference"><span class="nav-number">4.2.1.</span> <span class="nav-text">强引用(StrongReference)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8-SoftReference"><span class="nav-number">4.2.2.</span> <span class="nav-text">软引用(SoftReference)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8-WeakReference"><span class="nav-number">4.2.3.</span> <span class="nav-text">弱引用(WeakReference)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8-PhantomReference"><span class="nav-number">4.2.4.</span> <span class="nav-text">虚引用(PhantomReference)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E8%A7%86%E9%98%B6%E6%AE%B5"><span class="nav-number">4.3.</span> <span class="nav-text">不可视阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%88%B0%E8%BE%BE%E9%98%B6%E6%AE%B5"><span class="nav-number">4.4.</span> <span class="nav-text">不可到达阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E6%94%B6%E9%9B%86%E9%98%B6%E6%AE%B5%E3%80%81%E7%BB%88%E7%BB%93%E9%98%B6%E6%AE%B5%E4%B8%8E%E9%87%8A%E6%94%BE%E9%98%B6%E6%AE%B5"><span class="nav-number">4.5.</span> <span class="nav-text">可收集阶段、终结阶段与释放阶段</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Q-A"><span class="nav-number">5.</span> <span class="nav-text">Q &amp; A</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%80%81%E5%B9%B4%E4%BB%A3%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%92%8C%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%80%E6%A0%B7%E7%9A%84%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">为什么老年代不使用和新生代一样的标记-复制算法呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%EF%BC%88%E5%8E%8B%E7%BC%A9%EF%BC%89%E7%AE%97%E6%B3%95%EF%BC%8C%E6%AF%8F%E6%AC%A1%E6%95%B4%E7%90%86%E9%83%BD%E6%B6%88%E8%80%97%E5%A4%A7%E9%87%8F%E6%97%B6%E9%97%B4%EF%BC%8C%E8%83%BD%E4%B8%8D%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">标记-整理（压缩）算法，每次整理都消耗大量时间，能不能优化一下？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%EF%BC%9F%E5%AE%83%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">什么是内存碎片？它会带来什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E9%A3%99%E9%AB%98%E6%8E%92%E6%9F%A5%E6%96%B9%E6%A1%88%E4%B8%8E%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="nav-number">5.4.</span> <span class="nav-text">CPU飙高排查方案与思路？</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="魚"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">魚</p>
  <div class="site-description" itemprop="description">yuyu6661@foxmail.com</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zcralx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zcralx" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/zzzzzzzzzzz-90-37" title="zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;zzzzzzzzzzz-90-37" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>zhihu</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zcralx.github.io/posts/66c016fb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="魚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zcralx's blog">
      <meta itemprop="description" content="yuyu6661@foxmail.com">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JVM | zcralx's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-03 20:39:40" itemprop="dateCreated datePublished" datetime="2024-04-03T20:39:40+08:00">2024-04-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-10 20:40:31" itemprop="dateModified" datetime="2024-04-10T20:40:31+08:00">2024-04-10</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>47 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%81%AB%E7%81%B5%E5%84%BF/16416703"><img src="/assets/img/02.png" alt="桌面图片" title="火灵儿"></a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2141280035&auto=1&height=66"></iframe>

<p>[TOC]</p>
<h1 id="前言：了解一下JVM-java虚拟机"><a href="#前言：了解一下JVM-java虚拟机" class="headerlink" title="前言：了解一下JVM(java虚拟机)"></a>前言：了解一下JVM(java虚拟机)</h1><p>当前市面上使用范围最广的，是Sun&#x2F;OracleJDK或者OpenJDK中默认的 HotSpot 虚拟机。</p>
<p>市面上还存在很多非常优秀的Java虚拟机，它们都遵循Java虚拟机规范，但具体的实现上各有特点，在某一个领域拥有突出的性能优势是它们最重要的卖点。例如IBM的J9，Azul Systems 的 Azul VM 等等。</p>
<span id="more"></span>



<h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><h3 id="何时开始？"><a href="#何时开始？" class="headerlink" title="何时开始？"></a>何时开始？</h3><p>JVM在Java程序开始运行的时候，它才运行，程序结束的时它就停止。一个Java程序会开启一个JVM进程，如果一台机器上运行3个Java程序，那么就会有3个运行中的JVM进程。</p>
<p>JVM中的线程分为两种：守护线程和普通线程<br><strong>守护线程</strong>是JVM自己使用的线程，比如垃圾回收（GC）就是一个守护线程。<br><strong>普通线程</strong>一般是Java程序的线程，只要JVM中有普通线程在执行，那么JVM就不会停止。</p>
<h3 id="何时结束？"><a href="#何时结束？" class="headerlink" title="何时结束？"></a>何时结束？</h3><p>在如下几种情况下，Java虚拟机将结束生命周期：</p>
<ol>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而终止进程</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ol>
<h2 id="JVM执行引擎"><a href="#JVM执行引擎" class="headerlink" title="JVM执行引擎"></a>JVM执行引擎</h2><p>Java虚拟机相当于一台虚拟的物理机，这两种机器都有代码执行能力，区别主要是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而JVM的执行引擎是自己实现的，因此程序员可以自行制定指令集和执行引擎的结构体系。</p>
<p>执行引擎的主要职责，就是把这些自行制定的指令集翻译成硬件所支持的指令集格式，然后执行。</p>
<p>在JVM规范中制定了虚拟机字节码执行引擎的概念模型，这个模型称之为JVM执行引擎的统一外观，各个Java 虚拟机的发行厂商都需要按照这个规范来实现。</p>
<p>在不同的虚拟机实现中，可能会有两种的执行方式：解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码）。虚拟机可以按自身的需求，采用一种或同时采用多种组合的方式来实现执行引擎。但无论内部怎么实现，都要遵循<strong>输入的是字节码文件、处理过程是等效字节码解析过程、输出的是执行结果</strong>这个JVM规范要求。</p>
<h2 id="javap反编译"><a href="#javap反编译" class="headerlink" title="javap反编译"></a>javap反编译</h2><p>javap是java内置的反编译命令。</p>
<p><code>javap -v -p Main.class</code>：-v 显示附加信息，如局部变量表、操作码等；-p 显示所有类和成员，包括私有的。</p>
<p><code>javap -help</code>：查看javap的基本用法。</p>
<p><code>Classfile .....</code>第一行表示字节码文件的位置。</p>
<p><code>Last modified....</code>这一行表示字节码文件的修改信息。</p>
<p><code>SHA-256 checksum.....</code>字节码文件的 SHA-256 值，用于校验文件的完整性。</p>
<p><code>Compiled from.....</code>说明该字节码文件编译自xxxx.java 源文件。</p>
<p><code>public class.....</code>类访问修饰符和类型，表明这是一个公开的类，名为 xxxx。</p>
<p><code>minor version</code>次版本号， <code>major version</code>主版本号。</p>
<p><code> flags:....</code>类访问标记，一共有 8 种：</p>
<p><img src="/assets/img/bytecode.png" title="类访问标记"></p>
<p><code>this_class: #3</code>当前类的索引，指向常量池中下标为 3 的常量，类似的，<code>super_class: #4</code>父类的索引。</p>
<p><code>interfaces: 0, fields: 1, methods: 2, attributes: 1</code>当前类有 0 个接口，1 个字段（age），2 个方法（write方法和缺省的默认构造方法）。</p>
<p>后面还有一大堆，不想看了，原文在<a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/bytecode.html">https://javabetter.cn/jvm/bytecode.html</a></p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>常量池就是Class文件里的一大段内容（通常是最大的一段内容），它主要存放着 字面量、符号引用 等信息，在JVM把Class文件加载完成后，Class 常量池里的数据会存放到<strong>运行时常量池</strong>中。</p>
<h3 id="字面量（Literal）-符号引用（Symbolic-References）"><a href="#字面量（Literal）-符号引用（Symbolic-References）" class="headerlink" title="字面量（Literal） &amp; 符号引用（Symbolic References）"></a>字面量（Literal） &amp; 符号引用（Symbolic References）</h3><p>字面量：类似 Java 中的常量概念，比如文本字符串，final 常量等。</p>
<p>符号引用，包括以下三种：</p>
<ul>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
</ul>
<p>jvm先从常量池获取对应的符号引用，然后在类创建或者运行时解析并翻译到具体的内存地址上。</p>
<h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>运行时常量池是方法区（Method Area）的一部分，运行时常量池中存储的，是基本类型的数据和对象的引用。</p>
<p>Java虚拟机在加载Class文件时，Class文件内容里常量池的数据会放入运行时常量池。每一个加载好的Class对象里都会有一个运行时常量池。</p>
<h3 id="字符串常量池（String-Constant-Pool）-其他包装类型里实现的常量池"><a href="#字符串常量池（String-Constant-Pool）-其他包装类型里实现的常量池" class="headerlink" title="字符串常量池（String Constant Pool） &amp; 其他包装类型里实现的常量池"></a>字符串常量池（String Constant Pool） &amp; 其他包装类型里实现的常量池</h3><p>字符串由一个char[]构成，当我们的Java程序里频繁出现相同字面量的代码时，重复的创建和销毁对象是一件很浪费资源的事情，所以Java实现了一个字符串常量池。</p>
<p>JDK7之后，字符串常量池从方法区迁移到了堆区，它的底层实现可以理解为是一个<strong>HashTable</strong>。Jvm中只会存在一份字符串常量池。字符串常量池里，存放的数据可以是引用也可以是对象实例本身。</p>
<p>字符串常量池也具备运行时常量池动态性的特征，它支持运行期间将新的常量放入池中，这种特性被开发人员利用比较多的就是 String.intern() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>当以上代码运行时，JVM会到字符串常量池查找 “aaa” 这个字面量对象是否存在：</p>
<p><strong>存在</strong>：则返回该对象的引用给变量 <strong>str1</strong> 。</p>
<p><strong>不存在</strong>：则创建一个对象，同时将引用返回给变量 <strong>str1 。</strong>（JDK8之后，对象实例直接存储在字符串常量池里）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//返回TRUE</span></span><br></pre></td></tr></table></figure>

<p>因为变量<strong>str1</strong> 和<strong>str2</strong> 都指向同一个对象，所以返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//返回FALSE</span></span><br></pre></td></tr></table></figure>

<p>当我们使用了<strong>new</strong>来构造字符串对象的时候，不管字符串常量池中是否有相同内容的对象的引用，新的字符串对象都会创建。因为两个指向的是不同的对象，所以返回FALSE 。</p>
<h4 id="String-intern-方法"><a href="#String-intern-方法" class="headerlink" title="String.intern()方法"></a>String.intern()方法</h4><p>对于使用了new 创建的字符串对象，如果想要将这个对象添加到字符串常量池，可以使用intern() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">interns</span> <span class="operator">=</span> str3.intern();</span><br><span class="line">System.out.println(interns == str1);<span class="comment">//返回TRUE</span></span><br></pre></td></tr></table></figure>

<p>intern() 方法会检查字符串常量池中是否有与之匹配的对象，并做如下操作：</p>
<p>存在：直接返回对象引用给interns变量。</p>
<p>不存在：将这个对象引用加入到常量池，再返回对象引用给interns变量。</p>
<h4 id="以下创建了多少个对象呢？"><a href="#以下创建了多少个对象呢？" class="headerlink" title="以下创建了多少个对象呢？"></a>以下创建了多少个对象呢？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>+<span class="string">&quot;efg&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;abcefg&quot;</span>;</span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//返回TRUE</span></span><br></pre></td></tr></table></figure>

<p>答案是三个。第一个：”abc” ，第一个：”efg”，第三个：”abc”+”efg”（”abcefg”）</p>
<p>String str5 &#x3D; “abcefg”; 这句代码并没有创建对象，它从常量池中找到了”abcefg” 的引用，所以str4 &#x3D;&#x3D; str5 返回TRUE，因为它们都指向一个相同的对象。</p>
<h4 id="基本类型的包装类和常量池"><a href="#基本类型的包装类和常量池" class="headerlink" title="基本类型的包装类和常量池"></a>基本类型的包装类和常量池</h4><p>Byte、Short、Integer、Long、Character、Boolean、String 这 7 种包装类都各自实现了自己的常量池。</p>
<p>Float 和Double 这两个浮点类型没有实现常量池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出TRUE</span></span><br></pre></td></tr></table></figure>

<p>Byte、Short、Integer、Long、Character这5种包装类都默认创建了数值[-128 , 127]的缓存数据。<strong>当这5个类型的数据不在这个区间内的时候，将会去创建新的对象，并且不会将这些新的对象放入常量池中。</strong></p>
<h1 id="JVM之字节码与类的加载"><a href="#JVM之字节码与类的加载" class="headerlink" title="JVM之字节码与类的加载"></a>JVM之字节码与类的加载</h1><h2 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h2><p>Class文件由Java编译器生成，我们创建的.Java文件在经过编译器后，会变成.Class的文件，这样才能被JVM所识别并运行。</p>
<p>Class文件的核心设计思想是<strong>平台无关性</strong>，它存储的不是操作系统可以直接识别的二进制本地机器码，而是根据Java虚拟机规范所自定义的指令集、符号表和一些其他信息，所以只要任何一个操作系统下开发有对应的Java虚拟机，开发者的Java程序就能跑起来。</p>
<h3 id="查看Class文件"><a href="#查看Class文件" class="headerlink" title="查看Class文件"></a>查看Class文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd Hello.class</span><br></pre></td></tr></table></figure>
<h3 id="Class文件组成"><a href="#Class文件组成" class="headerlink" title="Class文件组成"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/class-file-jiegou.html">Class文件组成</a></h3><h4 id="魔数（cafebabe）"><a href="#魔数（cafebabe）" class="headerlink" title="魔数（cafebabe）"></a>魔数（cafebabe）</h4><p>第一行中有一串特殊的字符 <code>cafebabe</code>，它就是一个魔数，是 JVM 识别 class 文件的标志，JVM 会在验证阶段检查 class 文件是否以该魔数开头，如果不是则会抛出 <code>ClassFormatError</code>。</p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>紧跟着魔数后面的四个字节 <code>0000 0037</code> 分别表示副版本号和主版本号。也就是说，主版本号为 55（0x37 的十进制），也就是 Java 11 对应的版本号，副版本号为 0。</p>
<h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p>紧跟在版本号之后的是常量池，它包含了类、接口、字段和方法的符号引用，以及字符串字面量和数值常量。这些信息在编译时被创建，并在运行时被JVM使用。</p>
<h4 id="访问标记-Access-flags"><a href="#访问标记-Access-flags" class="headerlink" title="访问标记(Access flags)"></a>访问标记(Access flags)</h4><p>紧跟着常量池之后的区域就是访问标记，这个标记用于识别类或接口的访问信息。</p>
<h4 id="类索引、父类索引和接口索引"><a href="#类索引、父类索引和接口索引" class="headerlink" title="类索引、父类索引和接口索引"></a>类索引、父类索引和接口索引</h4><p>这三部分用来确定类的继承关系，this_class 为当前类的索引，super_class 为父类的索引，interfaces 为接口。</p>
<h5 id="如何通过索引值定位到在Class文件中的位置？"><a href="#如何通过索引值定位到在Class文件中的位置？" class="headerlink" title="如何通过索引值定位到在Class文件中的位置？"></a>如何通过索引值定位到在Class文件中的位置？</h5><blockquote>
<p>在Java类文件中，常量池是一个索引表，它从索引值1开始计数，每个条目都有一个唯一的索引。</p>
<ul>
<li>常量池计数器：在常量池之前，类文件有一个16位的常量池计数器，表示常量池中有多少项。它的值比实际常量数大1（因为索引从1开始）。</li>
<li>常量池条目：每个常量池条目的开始是一个标签（1个字节），表明了常量的类型（如Class、Fieldref、Methodref等）。根据这个类型，后面跟着的数据结构也不同。</li>
</ul>
<p>定位过程大致如下：</p>
<ul>
<li><strong>读取常量池计数器</strong>：首先，从类文件的开头读取常量池计数器的值，确定常量池中有多少条目。</li>
<li><strong>遍历常量池</strong>：从常量池的第一项开始遍历。由于不同类型的常量长度不同，需要根据每个常量的类型来确定它的长度。</li>
<li><strong>根据索引定位</strong>：继续遍历，直到到达所需的索引值。每次遍历时，根据条目类型读取相应长度的数据，直到达到目标索引。</li>
</ul>
</blockquote>
<h4 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h4><p>一个类中定义的字段会被存储在字段表（fields）中，包括静态的和非静态的。</p>
<h4 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h4><p>方法表和字段表类似，区别是用来存储方法的信息，包括方法名，方法的参数，方法的签名。</p>
<h4 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h4><p>属性表是 class 文件中的最后一部分，通常出现在字段和方法中。</p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>也可以称之为类加载器，JVM默认提供三个类加载器</p>
<h3 id="了解类加载器"><a href="#了解类加载器" class="headerlink" title="了解类加载器"></a>了解类加载器</h3><p>1、<strong>Bootstrap ClassLoader：</strong>称之为启动类加载器，是最顶层的类加载器，负责加载JDK中的核心类库，如 rt.jar、resources.jar、charsets.jar等。<br>2、<strong>Extension ClassLoader：</strong>称之为扩展类加载器，负责加载Java的扩展类库，默认加载$JAVA_HOME中jre&#x2F;lib&#x2F;*.jar 或 -Djava.ext.dirs指定目录下的jar包。<br>3、<strong>Application ClassLoader：</strong>称之为系统类加载器，负责加载应用程序classpath目录下所有jar和class文件。</p>
<p>除了Java默认提供的三个加载器之外，我们还可以根据自身需求自定义ClassLoader，自定义的类加载器必须继承自 java.lang.ClassLoader 类。</p>
<p>除了 BootStrap ClassLoader 之外的两个默认加载器都是继承自 java.lang.ClassLoader ，BootStrap ClassLoader 不是一个普通的Java类，它底层由C++编写，已嵌入到了JVM的内核当中。</p>
<p>当JVM启动后，BootStrap ClassLoader 也随之启动，负责加载完核心类库，并构造Extension ClassLoader 和App ClassLoader 类加载器。</p>
<h4 id="命名空间：存储加载的类"><a href="#命名空间：存储加载的类" class="headerlink" title="命名空间：存储加载的类"></a>命名空间：存储加载的类</h4><p>每个类加载器都拥有一个自己的命名空间，用于<strong>存储被自身加载过的所有类的全限定名</strong>。子类加载器可以检查父类加载器中加载的类，通过拿类的全限定名在父类的命名空间内搜索匹配。<strong>但父类不可以看子类加载了哪些类</strong>。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><strong>任何一个类加载器在接到一个类的加载请求时，都会先让其父类进行加载，只有父类无法加载（或者没有父类）的情况下，才尝试自己加载。</strong><br>父子关系：Boot &gt; Extension &gt; App &gt; 用户自定义</p>
<p><strong>好处：</strong><br>先了解一个知识点：不同的类加载器，加载同一个类，结果是虚拟机里会存在两份这个类的信息，所以当判断这两个类是否“相等”时，必定是不相等的。</p>
<p>使用双亲委派模型可以保证每一个类只会有一个类加载器。例如Java最基础的Object类，它存放在 rt.jar 之中，这是 Bootstrap 的职责范围，当向上委派到 Bootstrap 时就会被加载。</p>
<p>但如果没有使用双亲委派模式，可以任由自定义加载器进行加载的话，Java这些核心类的API就会被随意篡改。</p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>类加载机制指的是将.class文件中的二进制数据读入到内存中，并对数据进行校验，解析和初始化。最终，每一个类都会在方法区保存一份它的元数据，在堆中创建一个与之对应的Class对象。</p>
<p>类的生命周期，经历7个阶段，分别是加载、验证、准备、解析、初始化、使用、卸载。<br>除了<strong>使用</strong>和<strong>卸载</strong>两个过程，前面的5个阶段 <strong>加载、验证、准备、解析、初始化</strong> 的执行过程，就是类的加载过程。5个阶段并不是严格意义上的按顺序完成，在类加载的过程中，这些阶段会互相混合，交叉运行，最终完成类的加载和初始化。</p>
<p>对于什么时候加载，Java虚拟机规范中并没有约束，各个虚拟机都可以按自身需要来自由实现。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段，虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名去找到其对应的.class文件（类加载器执行）</li>
<li>将这个.class文件内的二进制数据读取出来，转化成方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范。例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型 …… 等等</p>
<p><strong>元数据验证</strong>：对字节码描述的元数据信息进行语义分析，要符合Java语言规范。例如：是否继承了不允许被继承的类（例如final修饰过的）、类中的字段、方法是否和父类产生矛盾 …… 等等</p>
<p><strong>字节码验证</strong>：对类的方法体进行校验分析，确保这些方法在运行时是合法的、符合逻辑的。</p>
<p><strong>符号引用验证</strong>：发生在<strong>解析</strong>阶段，符号引用转为直接引用的时候，例如：确保符号引用的全限定名能找到对应的类、符号引用中的类、字段、方法允许被当前类所访问 …… 等等</p>
<p>验证阶段不是必须的，虽然这个阶段非常重要。Java虚拟机允许程序员主动取消这个阶段，用来缩短类加载的时间，可以根据自身需求，使用 -Xverify:none参数来关闭大部分的类验证措施。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>这个阶段，类的静态字段信息会得到内存分配，并且设置为初始值。初始值指的是变量数据类型的默认值，而不是被在Java代码中被显式地赋予的值。但是，当字段信息被 final 修饰成常量（ConstantValue）时，这个初始值就是Java代码中显式地赋予的值。</p>
<p>在JDK8取消永久代后，方法区变成了一个逻辑上的区域，这些类变量的内存实际上是分配在Java堆中的。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>这个阶段，虚拟机会把Class文件中，<strong>常量池内的符号引用转换为直接引用</strong>。可以理解为当前加载的这个类，和它所引用的类，正式进行连接的过程。</p>
<blockquote>
<p>符号引用：代码在编译期间，是不知道最终引用的类型具体指向内存中哪个位置的，这时候会用一个符号引用，来表示具体引用的目标。</p>
<p>直接引用：直接引用就是可以直接或间接指向目标内存位置的指针或句柄。</p>
</blockquote>
<h5 id="引用的类型，还未加载初始化怎么办？"><a href="#引用的类型，还未加载初始化怎么办？" class="headerlink" title="引用的类型，还未加载初始化怎么办？"></a>引用的类型，还未加载初始化怎么办？</h5><p>当出现这种情况，会触发这个引用对应类型的加载和初始化。</p>
<h5 id="解析的时机"><a href="#解析的时机" class="headerlink" title="解析的时机"></a>解析的时机</h5><p>解析并不只出现在类加载过程，有些方法可能是真正被调用时才做解析操作。通常类加载时的解析包括了描述唯一版本的方法的符号引用，比如：final修饰的方法，版本唯一确定，就更适合在类加载阶段直接替换为直接引用。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化的过程，就是执行类构造器 &lt;clinit&gt;()方法的过程。&lt;clinit&gt;() 方法 和 &lt;init&gt; 方法不同，它们一个是“类构造器”，一个是实例构造器。</p>
<p>Java虚拟机会保证在子类&lt;clinit&gt;() 方法在执行前，父类的 &lt;clinit&gt;() 已经执行完毕。而 &lt;init&gt; 方法则需要显性的调用父类的构造器。&lt;clinit&gt;() 方法<strong>由编译器自动生成</strong>，但不是必须生成的，只有这个类存在static修饰的变量，或者类中存在静态代码块但时候，才会自动生成&lt;clinit&gt;()方法。</p>
<h5 id="方法的作用是什么？"><a href="#方法的作用是什么？" class="headerlink" title="&lt;clinit&gt;() 方法的作用是什么？"></a>&lt;clinit&gt;() 方法的作用是什么？</h5><p>上面提到在准备阶段，已经对类中static修饰的变量赋予了初始值。&lt;clinit&gt;() 方法的作用，就是给这些变量赋予程序员实际定义的值。同时类中如果存在static代码块，也会执行这个静态代码块里面的代码。</p>
<h5 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a>初始化时机</h5><p>Java虚拟机规范有明确规定，当符合以下条件时（包括但不限于），虚拟机内存中没有找到对应类型信息，则必须对类进行<strong>初始化</strong>操作：</p>
<blockquote>
<p>使用new实例化对象时；</p>
<p>读取或者设置一个类的静态字段或方法时；</p>
<p>反射调用时，例如 Class.forName(“com.xxx.MyTest”)；</p>
<p>初始化一个类的子类，会首先初始化子类的父类；</p>
<p>Java虚拟机启动时标明的启动类；</p>
<p>JDK8 之后，接口中存在default方法，这个接口的实现类初始化时，接口会其之前进行初始化；</p>
</blockquote>
<p>初始化阶段开始之前，自然还是要先经历 加载、验证、准备 、解析的。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>有了class对象，就可以在堆上为这个类分配实例对象，或者调用它的静态方法了。</p>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>卸载类即该类的 Class 对象被 GC。</p>
<p>卸载类需要满足 3 个要求:</p>
<blockquote>
<ol>
<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器的实例已被 GC</li>
</ol>
</blockquote>
<p>没有实例对象，没有被引用，且类加载器还要被GC，因此类的class对象被GC是一件不太容易发生的事件。</p>
<p><strong>只有自定义类加载器加载的类才有可能被卸载，JVM三个自带的类加载器加载的Class永远不会被卸载</strong>。</p>
<h1 id="JVM之内存与垃圾回收"><a href="#JVM之内存与垃圾回收" class="headerlink" title="JVM之内存与垃圾回收"></a>JVM之内存与垃圾回收</h1><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><h3 id="堆内存（java-heap"><a href="#堆内存（java-heap" class="headerlink" title="堆内存（java heap)"></a>堆内存（java heap)</h3><h4 id="堆内存的分区"><a href="#堆内存的分区" class="headerlink" title="堆内存的分区"></a>堆内存的分区</h4><p>堆内存通常被划分为不同的子区域，以更好地适应对象生命周期的不同阶段以及提高内存管理效率。</p>
<p>常见的一种分区方式是将堆分为年轻代、老年代和「永久代（PermGen）与元空间（Metaspace）」。</p>
<p>在早期的JVM版本中，永久代用于存储类的元数据信息，如类名、方法名、字段名等符号引用以及静态变量、常量池等。然而，永久代在JDK 8及以后的版本中已被元空间（Metaspace）所取代。</p>
<p>元空间不在堆内存中，而是使用本地内存（Native Memory），用于存储类的元数据和方法区数据。</p>
<h4 id="堆内存的基本知识"><a href="#堆内存的基本知识" class="headerlink" title="堆内存的基本知识"></a>堆内存的基本知识</h4><p>堆区负责存放对象实例，当Java创建一个类的实例对象或者数组时，都会在堆中为新的对象分配内存。</p>
<p>虚拟机中只有一个堆，程序中所有的线程都共享它。堆的存取方式为管道类型，先进先出。</p>
<p>在程序运行中，可以动态的分配堆的内存大小：</p>
<blockquote>
<ul>
<li><code>-Xms</code>：设定JVM初始堆内存大小。设置此值可以避免程序在运行初期因频繁的堆内存扩容而导致性能下降。</li>
<li><code>-Xmx</code>：设定JVM最大堆内存大小。超出此值，若无法进一步分配内存，则会导致<code>OutOfMemoryError</code>异常。</li>
<li>理想情况下，<code>-Xms</code>和<code>-Xmx</code>应设为相同的值，以减少堆内存动态扩展带来的额外开销。</li>
</ul>
</blockquote>
<p>堆的内存资源回收是交给GC进行管理的。</p>
<h4 id="TLAB（Thread-Local-Allocation-Buffer）"><a href="#TLAB（Thread-Local-Allocation-Buffer）" class="headerlink" title="TLAB（Thread Local Allocation Buffer）"></a>TLAB（Thread Local Allocation Buffer）</h4><p>为了提高对象分配的并发性和减少多线程竞争，JVM允许为每个线程分配一个私有的小块内存区域，称为TLAB。</p>
<p>线程在分配新对象时，优先在自己的TLAB中寻找空闲空间，只有当TLAB空间不足时，才会尝试锁定全局堆内存进行分配。</p>
<p>这种方式可以降低锁的竞争，提升分配效率。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区用于存储JVM加载完成的类型信息、常量、静态变量、即时编译器编译后的代码缓存，方法区和 Java 堆区一样，都是线程共享的内存区域。</p>
<p>在JDK8以前，使用永久代的方式来实现方法区，可以像java堆一样去管理方法区的内存，而它会更容易导致内存溢出的问题（永久代有上限，参数：-XX:MaxPermSize，即使不设置也会有默认大小）；到了JDK7，尝试将字符串常量池、静态变量移出来；JDK8以后，永久代的概念被废弃了，方法区改用和 JRockit、J9一样的<strong>在本地内存中实现的元空间（Meta Space）</strong>来代替，好处是元空间会在运行时根据需要动态调整，只要没有超过当前进程可用的内存上限，就不会出现溢出的问题。</p>
<p>当需要扩展时空间不足，会抛出OutOfMemoryError 异常。</p>
<h4 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h4><h5 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h5><p>类或接口的全限定名（包名+类名），如 <code>java.lang.String</code>；类的直接父类的全限定名（对于接口则是其直接父接口列表）；修饰符和类型标志：如 public、final、abstract 等修饰符，以及是否为接口、枚举、注解等类型标志；类或接口直接实现或继承的接口列表。</p>
<h5 id="常量池-2"><a href="#常量池-2" class="headerlink" title="常量池"></a>常量池</h5><p>字符串、整型、浮点数等基本类型的常量值；符号引用</p>
<h5 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h5><p>类或接口中声明的所有字段（成员变量）的相关数据；类型（完全限定名）；初始值或默认值（对于非final的静态变量，初始值在准备阶段设定；对于实例变量，其默认值在对象初始化时设定）；<br>字段的声明顺序。</p>
<h5 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h5><p>方法的名称、返回类型、参数列表及其类型、修饰符（如 public、private、synchronized、abstract、native 等）；方法的字节码：描述方法执行的具体指令序列；方法的附加信息；局部变量表：描述各局部变量的名称、类型和作用域；操作数栈和帧数据区大小：与方法执行时的栈帧结构相关；异常表：记录方法内特定指令可能抛出的异常处理信息（如catch块的位置）。</p>
<h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>非final的静态变量：类或接口中声明的静态变量，它们不属于常量池的一部分，而是存储在方法区中供所有实例共享。<br>全局常量(final static) ：虽然也在方法区中，但通常会被编译器优化并直接嵌入到使用它们的类文件中。</p>
<h5 id="类加载器引用"><a href="#类加载器引用" class="headerlink" title="类加载器引用"></a>类加载器引用</h5><p>指向加载该类或接口的类加载器的引用，用于确定类的加载来源和进行类加载器相关的沙箱隔离。</p>
<h5 id="Class对象引用"><a href="#Class对象引用" class="headerlink" title="Class对象引用"></a>Class对象引用</h5><p>每个被加载的类或接口都会在堆中生成一个对应的<code>java.lang.Class</code>对象，方法区中存储的是指向该对象的引用。</p>
<h5 id="方法表-1"><a href="#方法表-1" class="headerlink" title="方法表"></a>方法表</h5><p>有时也称为方法描述符表，它是一个列表，包含了类或接口中所有方法的描述符，用于快速查找和访问方法。</p>
<h4 id="简单认识一下栈、方法区与堆之间的联系"><a href="#简单认识一下栈、方法区与堆之间的联系" class="headerlink" title="简单认识一下栈、方法区与堆之间的联系"></a>简单认识一下栈、方法区与堆之间的联系</h4><p><img src="/assets/img/09.png" alt="认识联系" title="区分"></p>
<p>等号左边的A为类型信息，存储于方法区中；a为变量，存放于局部变量表中，也就是存于栈中；等号右边的new A()，也就是对象的创建，就是创建在堆中。</p>
<h3 id="程序计数器（PC-Register）"><a href="#程序计数器（PC-Register）" class="headerlink" title="程序计数器（PC Register）"></a>程序计数器（PC Register）</h3><p>在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>JVM的多线程是<strong>通过线程轮流切换并分配处理器执行时间</strong>的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以<strong>每条线程都会有一个独立的程序计数器</strong>，就是一个指针，指向方法区中的方法字节码，由执行引擎读取下一条指令。</p>
<p>程序计数器仅占很小的一块内存空间。</p>
<p>当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址。如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>JVM在运行Java应用程序时为每个线程创建的一个线程私有的内存区域，虚拟机栈主要用于存储和管理Java方法的调用过程中的各种数据和指令。</p>
<h4 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h4><h5 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h5><p>每个线程都有独立的虚拟机栈，不同线程之间的栈数据相互隔离，因此保证了线程间的独立性和安全性。</p>
<h5 id="栈帧（Stack-Frame）"><a href="#栈帧（Stack-Frame）" class="headerlink" title="栈帧（Stack Frame）"></a>栈帧（Stack Frame）</h5><p>每当一个方法被调用时，虚拟机栈上会创建一个新的栈帧来存储该方法的局部变量表、操作数栈、动态链接和方法出口信息。</p>
<p>栈帧的入栈和出栈顺序与方法的调用和返回顺序一致，遵循后进先出原则。</p>
<blockquote>
<ul>
<li><strong>局部变量表</strong>：存储方法内的基本类型变量、对象引用和其他引用类型的数据。</li>
<li><strong>操作数栈</strong>：作为计算单元，用于存放方法执行过程中的临时数据，支持算术运算、类型转换等操作。</li>
<li><strong>动态链接</strong>：指向方法调用的实际代码实现，因为Java支持方法的重载和动态绑定。</li>
<li><strong>方法出口</strong>：记录方法结束的位置，无论是正常返回还是异常返回，都需要通过它来恢复调用者的执行状态。</li>
</ul>
</blockquote>
<h5 id="方法调用与栈帧生命周期"><a href="#方法调用与栈帧生命周期" class="headerlink" title="方法调用与栈帧生命周期"></a>方法调用与栈帧生命周期</h5><p>方法的调用过程就是相应的栈帧压入虚拟机栈的过程；方法的执行完毕则是栈帧弹出的过程。</p>
<p>如果线程请求的栈深度大于虚拟机允许的最大深度，将会抛出 <code>StackOverflowError</code> 异常；如果虚拟机栈容量无法动态扩展，并且栈内存不足时，会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h5 id="异常处理与回溯"><a href="#异常处理与回溯" class="headerlink" title="异常处理与回溯"></a>异常处理与回溯</h5><p>当方法执行过程中发生异常时，虚拟机会通过异常处理表找到合适的异常处理器，并通过栈帧的连接关系找到异常抛出前的位置，从而继续执行异常处理逻辑。</p>
<h5 id="栈大小的限制与调整"><a href="#栈大小的限制与调整" class="headerlink" title="栈大小的限制与调整"></a>栈大小的限制与调整</h5><p>在启动Java虚拟机时，可以指定虚拟机栈的大小。</p>
<h3 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h3><p>本地方法栈的功能和JVM栈非常类似，区别在于虚拟机栈执行的是Java方法，本地方法栈执行的是本地（Native）方法服务，存储的也是本地方法的局部变量表，本地方法的操作数栈等信息。</p>
<p>栈内的数据在超出其作用域后，会被自动释放掉，它不由GC管理。</p>
<h4 id="启用时机"><a href="#启用时机" class="headerlink" title="启用时机"></a>启用时机</h4><p>本地方法栈是在 程序调用 或 JVM调用 <strong>本地方法接口（Native）</strong>时候启用。</p>
<p>本地方法都不是使用Java语言编写的，它们可能由C或其他语言编写，本地方法也不由JVM去运行，所以本地方法的运行不受JVM管理。</p>
<p>HotSpot VM将本地方法栈和JVM栈合并了。</p>
<h4 id="本地方法接口-JNI"><a href="#本地方法接口-JNI" class="headerlink" title="本地方法接口(JNI)"></a>本地方法接口(JNI)</h4><p>JNI是Java Native interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C和C++）。</p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>当我们有一些旧的库，已经使用C语言编写好了，如果要移植到Java上来，非常浪费时间，而JNI可以支持Java程序与C语言编写的库进行交互，这样就不必要进行移植了。或者是与硬件、操作系统进行交互、提高程序的性能等，都可以使用JNI。</p>
<h5 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h5><p>一旦使用JNI，Java程序将丢失了Java平台的两个优点：</p>
<ol>
<li>程序不再跨平台，要想跨平台，必须在不同的系统环境下程序编译配置本地语言部分。</li>
<li>程序不再是绝对安全的，本地代码的使用不当可能会导致整个程序崩溃。一个通用规则是，调用本地方法应该集中在少数的几个类当中，这样就降低了Java和其他语言之间的耦合。</li>
</ol>
<h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><ol>
<li>将需要用C&#x2F;C++实现的方法用native关键字声明</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用静态代码块进行动态链接库加载jnidemo.dll&#x2F;jnidemo.so</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">       System.loadLibrary(<span class="string">&quot;jnidemo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>用javac -h .  JNIDemo.java生成头文件（旧版本为javah)，执行完后生成一个的.h头文件和class文件。</li>
<li>实现对应的函数：创建.cpp文件，写代码，将.h头文件里函数的声明复制过来,加上需要用的参数名。</li>
<li>将C&#x2F;C++编译成动态链接库,mac用jnilib文件，win用dll文件<br><strong>查找jdk安装位置：&#x2F;usr&#x2F;libexec&#x2F;java_home</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o javafirst.jnilib -fPIC -shared -I/Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home/include/darwin java_first.cpp</span><br></pre></td></tr></table></figure>
<p>两个路径一个是jni.h的，一个是jni_md.h的</p>
<ul>
<li>shared: 表示创建一个共享目标文件，即动态链接库</li>
<li>fPIC: 生成位置无关代码（Position Independent Code），这是在创建共享库时必须的选项。</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="复制-Copying-算法（标记-复制算法）"><a href="#复制-Copying-算法（标记-复制算法）" class="headerlink" title="复制(Copying)算法（标记-复制算法）"></a>复制(<code>Copying</code>)算法（标记-复制算法）</h3><p>将可用内存分为两块，每次只用其中一块，当一块内存用完了，就将还存活的对象复制到另外一块上，然后再把已经使用过的内存空间一次性清理掉，循环下去。这样每次只需对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。</p>
<p>优点：实现简单；不产生内存碎片</p>
<p>缺点：内存缩小为原来的一半，代价太高</p>
<blockquote>
<p>现在商用虚拟机都采用复制算法来回收新生代，不过<code>1:1</code>的比例非常不科学，因此新生代的内存被划分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间，每次使用<code>Eden</code>和其中一块<code>Survivor</code>。</p>
<p>每次回收时，将<code>Eden</code>和<code>Survivor</code>中还存活着的对象一次性复制到另外一块<code>Survivor</code>空间上，最后清理掉<code>Eden</code>和刚才用过的<code>Survivor</code>空间。</p>
<p><code>HotSpot</code>虚拟机默认<code>Eden</code>区和<code>Survivor</code>区的比例为<code>8:1</code>，意思是每次新生代中可用内存空间为整个新生代容量的<code>90%</code>。当然，我们无法保证每次回收都少于<code>10%</code>的对象存活，当<code>Survivor</code>空间不够用时，需要依赖老年代进行分配担保(<code>Handle Promotion</code>)。</p>
</blockquote>
<h4 id="分配担保机制"><a href="#分配担保机制" class="headerlink" title="分配担保机制"></a>分配担保机制</h4><p>虽然根据IBM的研究，每次GC新生代里98%的对象都会被回收，但这不是百分之百的几率，极端情况下可能会出现超过10%的对象存活。分配担保机制就是为了保证当出现这种情况时，有其他内存空间来进行兜底。</p>
<p>通常这个“担保人”是老年代，当存活的对象超过Survivor空间大小时，这些存活的对象会忽略年龄，直接进入老年代里。</p>
<h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(<code>Mark-Sweep</code>)</h3><p>首先标记出所有需要回收的对象，标记完成后回收所有被标记的对象。</p>
<p>从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象，如果活着，就标记。只有全部标记完毕的时候，清理动作才开始。在清理的时候，没有标记的对象将会被释放，不会发生任何动作。但是剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就得重新整理剩下的对象。</p>
<p>优点：标记—清除算法中每个活着的对象的引用只需要找到一个即可，找到一个就可以判断它为活的。此外，更重要的是，这个算法并不移动对象的位置。</p>
<p>缺点：不足主要体现在效率和空间，从效率的角度讲，标记和清除效率都不高（递归与全堆对象遍历），每个活着的对象都要在标记阶段遍历一遍，所有对象都要在清除阶段扫描一遍，因此算法复杂度较高；从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致需要分配较大对象时，无法找到足够的连续内存而提前触发一次垃圾收集动作。</p>
<h3 id="标记-压缩算法（标记-整理）-Mark-Compact"><a href="#标记-压缩算法（标记-整理）-Mark-Compact" class="headerlink" title="标记-压缩算法（标记-整理）(Mark-Compact)"></a>标记-压缩算法（标记-整理）(<code>Mark-Compact</code>)</h3><p>过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。</p>
<p>优点：该算法不会像标记-清除算法那样产生大量的碎片空间。</p>
<p>缺点：如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>当程序创建一个新的对象或者基本类型的数据，内存空间不足时，会触发GC的执行。</p>
<p>GC只回收<strong>堆区和方法区</strong>内的基本类型数据和对象。</p>
<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>只回收新生代区域，通常频率较高但耗时较短。</p>
<h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>只回收老年代区域。只有CMS实现了Major GC，所以在老年代里，触发GC，除了CMS和G1之外的其他收集器，大多数触发的其实是 Full GC。</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>回收整个堆区和方法区，开销较大，尽量避免过于频繁的发生。</p>
<h3 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h3><p>回收整个新生代和部分老年代。G1收集器实现了这个类型。</p>
<h3 id="Stop-The-World-STW"><a href="#Stop-The-World-STW" class="headerlink" title="Stop The World(STW)"></a>Stop The World(STW)</h3><p><strong>Stop The World</strong> 会在任何一种GC算法中发生，其实可以把它理解为GC在清理内存时需要暂停所有用户线程。当 STW发生时，除GC所需的线程外，所有的线程都进入等待状态，直到 GC 任务完成。每一代的Java垃圾回收器，都把缩减 <strong>Stop The World</strong> 停顿时间作为很重要的目标。</p>
<h3 id="判断对象是否可以回收"><a href="#判断对象是否可以回收" class="headerlink" title="判断对象是否可以回收"></a>判断对象是否可以回收</h3><p>需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>（主要）。</p>
<ul>
<li><p>引用计数算法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，但是无法解决对象相互循环引用的问题，就是互相引用的对象。</p>
</li>
<li><p>可达性分析算法（Reachability Analysis）（根搜索算法）：通过一系列可被作为 <strong>GC Roots</strong> 的根对象来作为起始节点，从这些节点开始，根据引用关系向下搜索，搜索过程的就是一条<strong>引用链（Reference Chain）</strong>，没有在这个链条上面的对象，也就是根节点通过引用链不可达到这个对象时，就认为这个对象是可以被回收的。当一个对象到<code>GC Roots</code>不可达时，在下一个垃圾回收周期中尝试回收该对象，如果对象重写了<code>finalize()</code>，并在这个方法中成功自救(将自身赋予某个引用)，那么这个对象不会被回收。但如果这个对象没有重写<code>finalize()</code>方法或已执行过这个方法，该对象将会被回收。</p>
</li>
</ul>
<h4 id="可以作为根节点-GC-Roots-的对象"><a href="#可以作为根节点-GC-Roots-的对象" class="headerlink" title="可以作为根节点(GC Roots)的对象"></a>可以作为根节点(<code>GC Roots</code>)的对象</h4><blockquote>
<ul>
<li><p>虚拟机栈中引用的对象，例如线程调用方法时，使用或产生的参数、局部变量、临时变量等；</p>
</li>
<li><p>方法区中类的引用类型静态变量或常量；</p>
</li>
<li><p>本地方法栈中<code>JNI</code>引用的对象。</p>
</li>
<li><p>在JVM内部的对象，例如基本数据类型的Class对象，一些常驻的异常对象（NullPointExcepiton），系统类加载器等。</p>
</li>
<li><p>所有synchronized同步锁的持有对象。</p>
</li>
<li><p>反映JVM内部情况的JMXBean、JVMTI注册的回调、本地代码缓存等。</p>
</li>
</ul>
</blockquote>
<h4 id="如何找到GC-Roots"><a href="#如何找到GC-Roots" class="headerlink" title="如何找到GC Roots?"></a>如何找到GC Roots?</h4><p>虽然我们明确知道哪些对象可以作为 GC Roots ，但是遍历整个方法区，栈，常量池等，显然效率太低。</p>
<p>HotSpot使用OopMap来实现，他将所有可能的GC Roots记录下来，这样直接从OopMap里就可以拿到GC Roots。</p>
<p>但是，会导致OopMap变化的操作太多了，因此，只会在安全点记录OopMap。</p>
<p>在找到GC Roots的这个过程，是一定会导致STW的。暂停所有线程是需要一个合适的时机的，执行代码不是说停就能停的。</p>
<p>所以专门有<strong>安全点和安全区域</strong>两个概念作为线程由于某种原因需要暂停的暂停点。当用户线程执行到安全点或安全区域的代码处才可以被暂停。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>垃圾回收器并不是特指一种，Java官方本身就提供了很多个GC回收器供用户选择，还有各个Java虚拟机厂商（例如 Azul 的PCG、C4）也自己设计开发了很多优秀的垃圾回收器。</p>
<p>就目前来说，JVM 的垃圾收集器主要分为两大类：<strong>分代收集器</strong>和<strong>分区收集器</strong>，分代收集器的代表是 CMS，分区收集器的代表是 G1 和 ZGC。</p>
<h3 id="Serial-XX-UseSerialGC-SerialOld"><a href="#Serial-XX-UseSerialGC-SerialOld" class="headerlink" title="Serial(-XX:+UseSerialGC) &amp; SerialOld"></a>Serial(-XX:+UseSerialGC) &amp; SerialOld</h3><p>Serial 是Java虚拟机初代收集器，在JDK1.3之前是Jvm<strong>新生代收集器</strong>的唯一选择，这是一个<strong>单线程</strong>工作的收集器。在进行垃圾回收的时候，需要STW，直到回收结束。</p>
<p>虽然历史久远，但它依然是HotSpot虚拟机运行在客户端模式下，或者4核4GB以下服务端的默认新生代收集器，这种核心数和内存空间较小的场景下，它单线程的优势就体现出来了，没有线程交互的开销，加上内存空间不大，单次回收耗时几十毫秒，这点停顿时间，完全是可以接受的。</p>
<p>Serial 负责收集新生代区域，它采用<strong>标记-复制</strong>算法。</p>
<p>SerialOld 负责收集老年代区域，它采用<strong>标记-整理</strong>算法。</p>
<h3 id="ParNew-XX-UseParNewGC-CMS-XX-UseConcMarkSweepGC"><a href="#ParNew-XX-UseParNewGC-CMS-XX-UseConcMarkSweepGC" class="headerlink" title="ParNew(-XX:+UseParNewGC) &amp; CMS(-XX:+UseConcMarkSweepGC)"></a>ParNew(-XX:+UseParNewGC) &amp; CMS(-XX:+UseConcMarkSweepGC)</h3><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>ParNew 就是 在Serial 收集器的基础之上，实现了它的多线程版本。它可以多条线程同时进行垃圾收集，这也是它和 Serial 收集器的最大的区别，其他的功能性、配置、策略等等的和 Serial 基本一致。</p>
<p>在JDK9之后，Java官方取消了ParNew和除了CMS收集器之外的所有老年代收集器的搭配，而且还取消了 - XX:+UseParNewGC 这个参数，只能和CMS搭配使用。</p>
<p>ParNew 负责收集新生代区域，它采用<strong>标记-复制</strong>算法。</p>
<p>ParNew 是JDK7之前 Server VM 模式下的首选的新生代收集器。但是在单CPU的情况下，它的效率不会比 Serial收集器高的。</p>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>CMS (Concurrent Mark Sweep) 是JDK1.4后期推出的GC收集器，它是一款并发低停顿的收集器，<strong>对于响应速度有较高要求，对停顿时间忍受度低的应用，非常适合使用CMS作为垃圾收集器</strong>。</p>
<p><strong>第一个关注 GC 停顿时间（STW 的时间）的垃圾收集器</strong>。</p>
<p>CMS 负责收集老年代区域，它采用<strong>标记-清除</strong>算法。</p>
<h5 id="CMS运行过程"><a href="#CMS运行过程" class="headerlink" title="CMS运行过程"></a>CMS运行过程</h5><p>可以分为四个步骤：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
</ol>
<p>这个阶段<strong>需要</strong> Stop The World（暂停暂停所有用户线程），但这个阶段的速度很快，因为只标记和根节点（GC Roots）直接关联的对象。</p>
<ol start="2">
<li>并发标记（CMS Concurrent mark）</li>
</ol>
<p>这个阶段<strong>不需要</strong> Stop The World，在初始标记完成后，并发标记从GC Roots直接关联的对象开始，遍历整个引用链，这个阶段耗时较长，但<strong>用户线程可以和GC线程一起并发执行</strong>。</p>
<ol start="3">
<li>重新标记（CMS remark）</li>
</ol>
<p>这个阶段<strong>需要</strong> Stop The World，因为并发标记阶段，用户线程和标间线程同时在运行，相当于一边扫地一边丢垃圾，重新标记就是修正用户线程继续运行，导致的变动的那一部分对象。这一阶段的耗时比初始标记长一些，但远没有达到并发标记阶段那么长的时间。这个阶段可以多线程并行标记。</p>
<ol start="4">
<li>并发清理（Concurrent sweep）</li>
</ol>
<p>这个阶段<strong>不需要</strong> Stop The World，执行到这里，说明标记阶段已经完成，此时遍历整个老年代的内存空间，清理掉可回收的对象，由于不需要移动整理存活的对象，这个阶段可以允许用户线程和回收线程并发执行。在清理完成后，会重置CMS收集器的数据结构，等待下一次垃圾回收。</p>
<p>以上4个步骤可以看出，CMS之所以能实现低延迟，是因为它把垃圾搜集分成了几个明确的步骤，在一些耗时较长的阶段实现了用户线程和GC线程并发执行的能力。<strong>用两次短暂的 Stop Tow World 来代替了其他收集器一整段长时间的 Stop Tow World</strong>。</p>
<h5 id="CMS的缺点"><a href="#CMS的缺点" class="headerlink" title="CMS的缺点"></a>CMS的缺点</h5><ol>
<li><p>由于使用了标记-清理算法，回收结束后会产生大量不连续的内存空间，也就是内存碎片。</p>
</li>
<li><p>由于使用了并发处理，很多情况下都是GC线程和应用线程并发执行的，GC线程肯定会占用一部分计算资源。默认情况下，CMS 启用的垃圾回收线程数是<strong>（CPU数量 + 3)&#x2F;4</strong>，当 CPU 数量很大时，启用的垃圾回收线程数占比就越小。但如果 CPU 数量很小，例如只有 2 个 CPU，垃圾回收线程占用就达到了 50%，这极大地降低系统的吞吐量，无法接受。</p>
</li>
<li><p>CMS有两个阶段是可以用户线程和GC线程并发执行的，用户线程的继续执行自然会伴随垃圾的不断产生，这些就是浮动垃圾。这些垃圾只能等下次触发GC的时候才能清除了，也因为这些浮动垃圾的存在，CMS收集器需要留一手，JDK5的时候，在老年代内存空间使用了68%的时候就会触发一次GC，到了JDK6，觉得JDK5的这个设置太保守了，所以调整到了92%。(可以通过-XX:CMSInitiatingOccupancyFraction 调整这个阈值)</p>
</li>
</ol>
<h3 id="Parallel-Scavenge-XX-UseParallelGC-Parallel-Old-XX-UseParallelOldGC"><a href="#Parallel-Scavenge-XX-UseParallelGC-Parallel-Old-XX-UseParallelOldGC" class="headerlink" title="Parallel Scavenge(-XX:+UseParallelGC) &amp; Parallel Old(-XX:+UseParallelOldGC)"></a>Parallel Scavenge(-XX:+UseParallelGC) &amp; Parallel Old(-XX:+UseParallelOldGC)</h3><h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>和 ParNew 很相似，都是新生代的收集器，支持多线程并行回收，也同样是使用<strong>标记-复制</strong>来作为回收算法。</p>
<p>但 Parallel Scavenge 的关注点不一样，它的目标是实现一个可控制吞吐量的垃圾收集器。</p>
<blockquote>
<p>吞吐量的计算公式：运行用户代码时间 &#x2F; (运行用户代码时间 + 运行垃圾收集时间)</p>
</blockquote>
<h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>就像 Serial Old 是 Serial 的老年代版本一样，Parallel Old 是 Parallel Scavenge 的老年代版本。</p>
<p>Parallel Old 也支持多线程并行回收的能力，使用<strong>标记-整理</strong>来作为回收算法。这个收集器是JDK6的时候推出的，和 Parallel Scavenge 搭配，在多CPU核心和大内存的场景下，吞吐性能优秀。</p>
<p>在注重吞吐量和多CPU核心的情况下，都可以优先考虑 Parallel Scavenge + Parallelo Old 收集器，这也是JDK8的默认收集器组合。</p>
<h3 id="Garbage-First（G1）"><a href="#Garbage-First（G1）" class="headerlink" title="Garbage First（G1）"></a>Garbage First（G1）</h3><p>在JDK9 的时候成为了服务端模式下的默认垃圾收集器。</p>
<p>G1 收集器的设计理念是：实现一个<strong>停顿时间可控的低延迟垃圾收集器</strong></p>
<p>G1 基于分代的思想进行设计，对堆内存进行了重新布局，把堆区划分成很多个大小相同的区域（Region），新、老年代也不再固定在某个区域了，每一个Region都可以根据运行情况的需要，扮演Eden、Survivor、老年代区域、或者Humongous区域。</p>
<p>可以通过 <code>-XX:G1HeapRegionSize=n</code> 来设置 Region 的大小，可以设定为 1M、2M、4M、8M、16M、32M（不能超过）。</p>
<p>大对象（超过了一个 Region 大小的 50%）会被存储到Humongous区域，G1大多数情况下会把这个区域当作老年代来看待。如果对象占用空间超过Region的容量，就会存放到N个连续的 Humongous Region 中。</p>
<p>G1 可以以增量方式执行垃圾回收，这意味着它不需要一次性回收整个堆空间，而是可以逐步、增量地清理。有助于控制停顿时间，尤其是在处理大型堆时。</p>
<p>G1 垃圾回收器可以并行回收垃圾，这意味着它可以利用多个 CPU 来加速垃圾回收的速度，这一特性在年轻代的垃圾回收（Minor GC）中特别明显，因为年轻代的回收通常涉及较多的对象和较高的回收速率。</p>
<p>在进行老年代的垃圾回收时，G1 使用标记-整理算法。</p>
<h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><p>大致分成四个步骤：</p>
<blockquote>
<p><strong>初始标记（Initial Marking）- Stop The World</strong></p>
<p>只标记 GC Roots 能直接关联的对象，还有一些额外的细节操作例如修改TAMS指针的值，保证后续阶段用户程序并发运行的时候，新对象分配在正确的位置。这个阶段需要暂停用户线程，但耗时很短。</p>
<p><strong>并发标记（Concurrent Marking）- No Stop The World</strong></p>
<p>从根节点（GC Root）开始，顺着引用链遍历整个堆，找出存活的对象。这个步骤耗时较长，但用户线程可以和GC线程并发执行。</p>
<p><strong>最终标记（Final Marking）- Stop The World</strong></p>
<p>处理并发标记阶段，用户线程继续运行产生的引用变动，这个阶段需要暂停用户线程，支持并行处理。</p>
<p><strong>筛选回收（Live Data Counting and Evacuation）- Stop The World</strong></p>
<p>根据以上三个阶段标记完成的数据，计算出各个Region的回收价值和成本，再根据用户期望的停顿时间来决定要回收多少个Region。回收使用的是复制算法，把需要回收的这些Region里存活的对象，复制到空闲的Region中，然后清理掉旧Region全部空间。因为需要移动存活的对象，所以不可避免的要暂停用户线程，这个步骤支持多条线程并行回收。</p>
</blockquote>
<h4 id="三种GC-模式"><a href="#三种GC-模式" class="headerlink" title="三种GC 模式"></a>三种GC 模式</h4><p>G1 中存在三种 GC 模式，分别是 Young GC、Mixed GC 和 Full GC。</p>
<p>当 Eden 区的内存空间无法支持新对象的内存分配时，G1 会触发 Young GC。</p>
<p>当需要分配对象到 Humongous 区域或者堆内存的空间占比超过 <code>-XX:G1HeapWastePercent</code> 设置的 InitiatingHeapOccupancyPercent 值时，G1 会触发一次 concurrent marking，它的作用就是计算老年代中有多少空间需要被回收，当发现垃圾的占比达到 <code>-XX:G1HeapWastePercent</code> 中所设置的 G1HeapWastePercent 比例时，在下次 Young GC 后会触发一次 Mixed GC。</p>
<p>Mixed GC 是指回收年轻代的 Region 以及一部分老年代中的 Region。Mixed GC 和 Young GC 一样，采用的也是复制算法。</p>
<p>在 Mixed GC 过程中，如果发现老年代空间还是不足，此时如果 G1HeapWastePercent 设定过低，可能引发 Full GC。<code>-XX:G1HeapWastePercent</code> 默认是 5，意味着只有 5% 的堆是“浪费”的。如果浪费的堆的百分比大于 G1HeapWastePercent，则运行 Full GC。</p>
<p>在以 Region 为最小管理单元以及所采用的 GC 模式的基础上，G1 建立了停顿预测模型，即 Pause Prediction Model 。这也是 G1 非常被人所称道的特性。</p>
<p>我们可以借助 <code>-XX:MaxGCPauseMillis</code> 来设置期望的停顿时间（默认 200ms），G1 会根据这个值来计算出一个合理的 Young GC 的回收时间，然后根据这个时间来制定 Young GC 的回收计划。</p>
<h4 id="G1是如何保证停顿时间可控的？"><a href="#G1是如何保证停顿时间可控的？" class="headerlink" title="G1是如何保证停顿时间可控的？"></a>G1是如何保证停顿时间可控的？</h4><p>首先G1把内存区域分成了若干个相同大小的 Region 区，在执行回收的时候，根据标记阶段统计到的数据，计算出各个 Region 区的回收价值和成本，有了这些数据之后，就可以计算出回收哪几个Region价值最高，且符合用户预期的停顿时间。</p>
<h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/gc-collector.html">ZGC</a></h3><p>JDK11 推出的一款低延迟垃圾收集器，适用于大内存低延迟服务的内存管理和回收，SPEC jbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。</p>
<p>ZGC 很强大，它的目标是：</p>
<blockquote>
<ul>
<li>停顿时间不超过 10ms；</li>
<li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li>
<li>支持 8MB~4TB 级别的堆，未来支持 16TB。</li>
</ul>
</blockquote>
<h4 id="G1的性能瓶颈（为什么ZGC能做到停顿时间如此短暂？"><a href="#G1的性能瓶颈（为什么ZGC能做到停顿时间如此短暂？" class="headerlink" title="G1的性能瓶颈（为什么ZGC能做到停顿时间如此短暂？)"></a>G1的性能瓶颈（为什么ZGC能做到停顿时间如此短暂？)</h4><p>前面讲 G1 垃圾收集器的时候提到过，Young GC 和 Mixed GC 均采用的是复制算法，复制算法主要包括以下 3 个阶段：</p>
<p>①、标记阶段，从 GC Roots 开始，分析对象可达性，标记出活跃对象。</p>
<p>②、对象转移阶段，把活跃对象复制到新的内存地址上。</p>
<p>③、重定位阶段，因为转移导致对象地址发生了变化，在重定位阶段，所有指向对象旧地址的引用都要调整到对象新的地址上。</p>
<p>标记阶段因为只标记 GC Roots，耗时较短。但转移阶段和重定位阶段需要处理所有存活的对象，耗时较长，并且转移阶段是 STW 的，因此，<strong>G1 的性能瓶颈就主要卡在转移阶段</strong>。</p>
<p>与 G1 和 CMS 类似，<strong>ZGC 也采用了复制算法，只不过做了重大优化，ZGC 在标记、转移和重定位阶段几乎都是并发的，这是 ZGC 实现停顿时间小于 10ms 的关键所在。</strong></p>
<h4 id="ZGC-是怎么做到的：指针染色-读屏障"><a href="#ZGC-是怎么做到的：指针染色-读屏障" class="headerlink" title="ZGC 是怎么做到的：指针染色 &amp; 读屏障"></a>ZGC 是怎么做到的：指针染色 &amp; 读屏障</h4><ul>
<li>指针染色（Colored Pointer）：一种用于标记对象状态的技术。</li>
<li>读屏障（Load Barrier）：一种在程序运行时插入到对象访问操作中的特殊检查，用于确保对象访问的正确性。</li>
</ul>
<p>这两种技术可以让所有线程在并发的条件下就指针的颜色 (状态) 达成一致，而不是对象地址。因此，ZGC 可以并发的复制对象，这大大的降低了 GC 的停顿时间。</p>
<blockquote>
<p><strong>指针染色（空间换时间）</strong></p>
<p>在一个指针中，除了存储对象的实际地址外，还有额外的位被用来存储关于该对象的元数据信息。这些信息可能包括：</p>
<ul>
<li>对象是否被移动了（即它是否在回收过程中被移动到了新的位置）。</li>
<li>对象的存活状态。</li>
<li>对象是否被锁定或有其他特殊状态。</li>
</ul>
<p>通过在指针中嵌入这些信息，ZGC 在标记和转移阶段会更快，因为通过指针上的颜色就能区分出对象状态，不用额外做内存访问。</p>
<p>ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间。</p>
<p><strong>读屏障</strong></p>
<p>当程序尝试读取一个对象时，读屏障会触发以下操作：</p>
<ul>
<li>检查指针染色：读屏障首先检查指向对象的指针的颜色信息。</li>
<li>处理移动的对象：如果指针表示对象已经被移动（例如，在垃圾回收过程中），读屏障将确保返回对象的新位置。</li>
<li>确保一致性：通过这种方式，ZGC 能够在并发移动对象时保持内存访问的一致性，从而减少对应用程序停顿的需要。</li>
</ul>
<p>读屏障可能被GC线程和业务线程触发，并且只会在访问堆内对象时触发，访问的对象位于GC Roots时不会触发，这也是扫描GC Roots时需要STW的原因。</p>
</blockquote>
<p>简化的示例代码，展示了读屏障的触发时机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> obj.FieldA   <span class="comment">// 从堆中读取引用，需要加入屏障</span></span><br><span class="line">&lt;Load barrier&gt;</span><br><span class="line"><span class="type">Object</span> <span class="variable">p</span> <span class="operator">=</span> o  <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line">o.dosomething() <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  obj.FieldB  <span class="comment">//无需加入屏障，因为不是对象引用</span></span><br></pre></td></tr></table></figure>

<h3 id="查看我的GC器"><a href="#查看我的GC器" class="headerlink" title="查看我的GC器"></a>查看我的GC器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GarbageCollectorMXBean&gt; beans = ManagementFactory.getGarbageCollectorMXBeans();</span><br><span class="line"><span class="keyword">for</span> (GarbageCollectorMXBean bean : beans) &#123;System.out.println(bean.getName());&#125;</span><br></pre></td></tr></table></figure>

<p>我的结果：</p>
<blockquote>
<p>G1 Young Generation<br>G1 Concurrent GC<br>G1 Old Generation</p>
</blockquote>
<h2 id="分代垃圾回收策略"><a href="#分代垃圾回收策略" class="headerlink" title="分代垃圾回收策略"></a>分代垃圾回收策略</h2><p>JVM分代垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p>试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。</p>
<p>因此，分代垃圾回收<strong>采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上</strong>，不同代上采用最适合它的垃圾回收方式进行回收。</p>
<p>虚拟机中堆的共划分为三个代：年轻代(YoungGeneration)、年老代(OldGeneration)和<del>持久代(PermanentGeneration)</del>。年轻代和年老代对垃圾收集影响较大。</p>
<h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p>所有新生成的对象首先都是放在年轻代的。年轻代分三个区。一个Eden区(Eden Space伊甸园区)，两个Survivor区(Survivor Space 0 幸存者区0和 Survivor Space 1幸存者区1，也称为from区和to区)（默认8:1:1）。</p>
<p>大部分对象在Eden区中生成。当Eden空间不足时，触发Minor GC，存活下来的对象会被复制到From区，这时Eden区就干净了，Eden区可以继续创建新对象，再次满时，触发GC，将Eden区与From区还在被使用的对象复制到To区，再下一次GC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。经过若干次GC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是还没有被回收，就会被复制到老年代。「对于一些大的对象（指需要占用大量连续内存空间的对象）则直接进入到老年代。」</p>
<p><strong>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</strong></p>
<p>Survivor的两个区是对称的，没先后关系。Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的(多于两个)，这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p>
<p>由于新生代中的对象大多都是临时对象，死亡率较高，因此采用复制算法。在进行Minor GC时，会先标记出伊甸园区和其中一个幸存者区中的存活对象，并将它们复制到另一个幸存者区中，最后清空原来的两个区域。这样既能高效地回收大量死亡对象，又保持了内存的连续性。</p>
<h4 id="为什么要两块Survivor空间？"><a href="#为什么要两块Survivor空间？" class="headerlink" title="为什么要两块Survivor空间？"></a>为什么要两块Survivor空间？</h4><p>因为复制算法必须要有一块空间是空闲的。想象一下，如果只有一块Eden空间 + 一块Survivor空间。当GC回收完成后，Eden中存活的对象会移动到Survivor空间。程序继续运行，新的对象又会进入Eden空间，此时就会出现 Eden 和 Survivor 空间里都有对象，复制算法也就进行不下去了。</p>
<h3 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a>年老代</h3><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
<p>老年代中的对象生命周期更长，存活率高，不适合频繁地进行复制操作。因此，在老年代上一般采用标记-清除或者标记-压缩算法。</p>
<h3 id="跨代引用的问题"><a href="#跨代引用的问题" class="headerlink" title="跨代引用的问题"></a>跨代引用的问题</h3><p>举个例子，新生代中的对象很有可能会被老年代里的对象所引用，当新生代触发GC的时候，只搜索新生代的区域明显是不够的，还得搜索老年代的对象是否引用了新生代中非 GC Roots 引用链上的对象，来确保正确性。但这样做会带来很大的性能开销。为了解决这个问题，Java定义了一种名为记忆集的抽象的数据结构，用于记录存在跨区域引用的对象指针集合。</p>
<p>大多数的虚拟机，都采用一种名为<strong>卡表（Card Table）</strong>的方式去实现记忆集，卡表由一个数组构成，每一个元素都对应着一块特定大小的内存区域，这块内存区域被称之为卡页（Card Page），每一个卡页，可能会包含N个存在跨区域引用的对象，只要存在跨区域引用的对象，这个卡页就会被标识为1。当GC发生的时候，就不需要扫描整个区域了，只需要把这些被标识为1的卡页加入对应区域的 GC Roots 里一起扫描即可。</p>
<h1 id="JVM之对象的生命周期"><a href="#JVM之对象的生命周期" class="headerlink" title="JVM之对象的生命周期"></a>JVM之对象的生命周期</h1><p>在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段：创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）。</p>
<h2 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h2><p>在对象创建阶段，系统要通过下面的步骤，完成对象的创建过程：</p>
<blockquote>
<ol>
<li><p>为对象分配存储空间。</p>
</li>
<li><p>开始构造对象。</p>
</li>
<li><p>递归调用其超类的构造方法。</p>
</li>
<li><p>进行对象实例初始化与变量初始化。</p>
</li>
<li><p>执行构造方法体。</p>
</li>
</ol>
</blockquote>
<p>在创建对象时，我们应该遵循一些基本的规则，以提高应用的性能：</p>
<blockquote>
<ol>
<li><p>避免在循环体中创建对象，即使该对象占用内存空间不大。</p>
</li>
<li><p>尽量及时使对象符合垃圾回收标准。</p>
</li>
<li><p>不要采用过深的继承层次。</p>
</li>
<li><p>访问本地变量优于访问类中的变量。</p>
</li>
</ol>
</blockquote>
<h2 id="应用阶段"><a href="#应用阶段" class="headerlink" title="应用阶段"></a>应用阶段</h2><p>在这个阶段，对象具备下列特征：</p>
<ul>
<li>系统至少维护着对象的一个强引用（StrongReference）</li>
<li>所有对该对象的引用全部是强引用（除非我们显式地使用了：软引用（SoftReference）、弱引用（WeakReference）或虚引用（PhantomReference））</li>
</ul>
<h3 id="强引用-StrongReference"><a href="#强引用-StrongReference" class="headerlink" title="强引用(StrongReference)"></a>强引用(StrongReference)</h3><p>指JVM内存管理器从根引用集合（RootSet）出发遍寻堆中所有到达对象的路径。当到达某对象的任意路径都不含有引用对象时，对这个对象的引用就被称为强引用。</p>
<h3 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用(SoftReference)"></a>软引用(SoftReference)</h3><p>具有较强的引用功能。只有当内存不够的时候，才回收这类内存，因此在内存足够的时候，它们通常不被回收。另外，这些引用对象还能保证在Java抛出OutOfMemory异常之前，被设置为null。</p>
<p>它可以用于实现一些常用资源的缓存，实现Cache的功能，保证最大限度的使用内存而不引起OutOfMemory。再者，<strong>软可到达对象的所有软引用都要保证在虚拟机抛出OutOfMemoryError之前已经被清除</strong>。否则，清除软引用的时间或者清除不同对象的一组此类引用的顺序将不受任何约束。然而，虚拟机实现不鼓励清除最近访问或使用过的软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//使用a</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//使用完了a,将它设置为soft引用类型并释放强引用</span></span><br><span class="line"><span class="type">SoftReference</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(a);</span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//下次使用时</span></span><br><span class="line"><span class="keyword">if</span>(sr != <span class="literal">null</span>)&#123;</span><br><span class="line">	a = sr.get();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//GC由于内存资源不足可能已经回收了</span></span><br><span class="line">	a = <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">	sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>软引用技术的引进，使Java应用可以更好地管理内存，稳定系统，防止系统内存溢出，避免系统崩溃（crash）。因此在处理一些占用内存较大而且声明周期较长，但使用并不频繁的对象时应尽量应用该技术。但是在某些时候对软引用的使用会降低应用的运行效率与性能。</p>
<h3 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h3><p>与Soft引用对象的最大不同就在于：GC在进行回收时，需要通过算法检查是否回收Soft引用对象，而对于Weak引用对象，GC总是进行回收。因此Weak引用对象会更容易、更快被GC回收。虽然GC在运行时一定回收Weak引用对象，但是复杂关系的Weak对象群常常需要好几次GC的运行才能完成。</p>
<p>Weak引用对象常常用于Map数据结构中，引用占用内存空间较大的对象，一旦该对象的强引用为null时，对这个对象引用就不存在了，GC能够快速地回收该对象空间。</p>
<p>弱引用技术主要适用于实现无法防止其键（或值）被回收的规范化映射。另外，弱引用分为“短弱引用（ShortWeekReference）”和“长弱引用（LongWeekReference）”，其区别是长弱引用在对象的Finalize方法被GC调用后依然追踪对象。基于安全考虑，不推荐使用长弱引用。</p>
<h3 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用(PhantomReference)"></a>虚引用(PhantomReference)</h3><p>用途较少，主要用于辅助finalize函数的使用。Phantom对象指一些执行完了finalize函数，并且为不可达对象，但是还没有被GC回收的对象。这种对象可以辅助finalize进行一些后期的回收工作，我们通过覆盖Reference的clear()方法，增强资源回收机制的灵活性。虚引用主要适用于以某种比java终结机制更灵活的方式调度pre-mortem清除操作。</p>
<p>在实际程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出等问题的产生</strong>。</p>
<h2 id="不可视阶段"><a href="#不可视阶段" class="headerlink" title="不可视阶段"></a>不可视阶段</h2><p>在一个对象经历了应用阶段之后，那么该对象便处于JVM对象生命周期的不可视阶段，说明我们在其他区域的代码中已经不可以再引用它，其强引用已经消失。</p>
<h2 id="不可到达阶段"><a href="#不可到达阶段" class="headerlink" title="不可到达阶段"></a>不可到达阶段</h2><p>处于JVM对象生命周期不可到达阶段的对象，在虚拟机所管理的对象引用根集合中再也找不到直接或间接的强引用，这些对象通常是指所有线程栈中的临时变量，所有已装载的类的静态变量或者对本地代码接口（JNI）的引用。这些对象都是要被垃圾回收器回收的预备对象，但此时该对象并不能被垃圾回收器直接回收。其实所有垃圾回收算法所面临的问题是相同的——找出由分配器分配的，但是用户程序不可到达的内存块。</p>
<h2 id="可收集阶段、终结阶段与释放阶段"><a href="#可收集阶段、终结阶段与释放阶段" class="headerlink" title="可收集阶段、终结阶段与释放阶段"></a>可收集阶段、终结阶段与释放阶段</h2><p>JVM对象生命周期的最后一个阶段是可收集阶段、终结阶段与释放阶段。当对象处于这个阶段的时候，可能处于下面三种情况：</p>
<blockquote>
<p>（1）垃圾回收器发现该对象已经不可到达。</p>
<p>（2）finalize方法已经被执行。</p>
<p>（3）对象空间已被重用。</p>
</blockquote>
<p>当对象处于上面的三种情况时，该对象就处于可收集阶段、终结阶段与释放阶段了。虚拟机就可以直接将该对象回收了。</p>
<h1 id="Q-A"><a href="#Q-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h1><h2 id="为什么老年代不使用和新生代一样的标记-复制算法呢？"><a href="#为什么老年代不使用和新生代一样的标记-复制算法呢？" class="headerlink" title="为什么老年代不使用和新生代一样的标记-复制算法呢？"></a>为什么老年代不使用和新生代一样的标记-复制算法呢？</h2><blockquote>
<p>新生代里绝大多数对象都是朝生夕死的，使用的标记-复制算法，空间占比可以8 : 1 : 1，但是老年代里对象存活率很高，这个占比明显不合适。</p>
<p>如果占比得设置得大 (例如50%)，又会浪费很多内存空间，而且由于对象很多都是存活的，复制移动也是一笔开销。所以标记-复制这个算法，不适合老年代这种对象存活率很高的区域。</p>
</blockquote>
<h2 id="标记-整理（压缩）算法，每次整理都消耗大量时间，能不能优化一下？"><a href="#标记-整理（压缩）算法，每次整理都消耗大量时间，能不能优化一下？" class="headerlink" title="标记-整理（压缩）算法，每次整理都消耗大量时间，能不能优化一下？"></a>标记-整理（压缩）算法，每次整理都消耗大量时间，能不能优化一下？</h2><blockquote>
<p>可以通过设置一个阈值或者临界点，当内存碎片化程度还在这个阈值范围内的时候，仅采用标记-清除算法。只有超过这个阈值，才进行整理。</p>
</blockquote>
<h2 id="什么是内存碎片？它会带来什么问题？"><a href="#什么是内存碎片？它会带来什么问题？" class="headerlink" title="什么是内存碎片？它会带来什么问题？"></a>什么是内存碎片？它会带来什么问题？</h2><blockquote>
<p>回收完成后，会产生很多不连续的内存空间，这就是内存碎片。</p>
<p>Java虚拟机对于大对象（例如很长的字符串、byte数组等等），都必须存储在连续的内存空间里，当一个大对象需要进入某个内存空间时，由于内存碎片过多，虽然剩余内存是远大于这个对象所需空间的，但就是找不到一块连续的内存空间来存储它，这会导致提前触发一次Full GC。</p>
</blockquote>
<h2 id="CPU飙高排查方案与思路？"><a href="#CPU飙高排查方案与思路？" class="headerlink" title="CPU飙高排查方案与思路？"></a>CPU飙高排查方案与思路？</h2><blockquote>
<ol>
<li><p>执行top命令：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。</p>
</li>
<li><p>执行top -Hp 进程号命令：查看java进程下的所有线程占CPU的情况。</p>
</li>
<li><p>执行“printf “%x\n 10”命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如，打印：a，那么在jstack中线程号就是0xa.</p>
</li>
<li><p>执行 “jstack 进程号 | grep 线程ID” 查找某进程下线程ID（jstack堆栈信息中的nid）&#x3D;0xa的线程状态。如果“”VM Thread” os_prio&#x3D;0 tid&#x3D;0x00007f871806e000 nid&#x3D;0xa runnable”，第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程了</p>
</li>
<li><p>执行“jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计）”，查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大，确认Full GC! 也可以使用“jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。</p>
</li>
<li><p>执行“jmap -dump:format&#x3D;b,file&#x3D;filename 进程ID”，导出某进程下内存heap输出到文件中。</p>
</li>
</ol>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="魚 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="魚 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/GC/" rel="tag"><i class="fa fa-tag"></i> GC</a>
              <a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a>
              <a href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/" rel="tag"><i class="fa fa-tag"></i> 字节码</a>
              <a href="/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/" rel="tag"><i class="fa fa-tag"></i> 类的加载</a>
              <a href="/tags/%E5%B8%B8%E9%87%8F%E6%B1%A0/" rel="tag"><i class="fa fa-tag"></i> 常量池</a>
              <a href="/tags/%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" rel="tag"><i class="fa fa-tag"></i> 对象的生命周期</a>
              <a href="/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/" rel="tag"><i class="fa fa-tag"></i> 反编译</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"><i class="fa fa-tag"></i> 面试题</a>
              <a href="/tags/%E5%BC%95%E7%94%A8/" rel="tag"><i class="fa fa-tag"></i> 引用</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/e41b8b68/" rel="prev" title="volatile & 内存屏障">
                  <i class="fa fa-angle-left"></i> volatile & 内存屏障
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/d366874c/" rel="next" title="集合">
                  集合 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81OTcxMi8zNjE3NA=="></div>
</div>
  </main>
  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">魚</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">109k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:17</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/third-party/comments/livere.js"></script>


  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
  <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
  <script async src="/js/cursor/explosion.min.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
