<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zcralx.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"show_result":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="[TOC] 接口Collection&lt;E&gt;接口Collection是单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是 java.util.List 与 java.util.Set。">
<meta property="og:type" content="article">
<meta property="og:title" content="集合">
<meta property="og:url" content="https://zcralx.github.io/posts/d366874c/index.html">
<meta property="og:site_name" content="zcralx&#39;s blog">
<meta property="og:description" content="[TOC] 接口Collection&lt;E&gt;接口Collection是单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是 java.util.List 与 java.util.Set。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zcralx.github.io/assets/img/01.jpg">
<meta property="article:published_time" content="2024-04-06T13:50:14.000Z">
<meta property="article:modified_time" content="2024-06-05T13:41:41.055Z">
<meta property="article:author" content="魚">
<meta property="article:tag" content="ArrayBlockingQueue">
<meta property="article:tag" content="ArrayList">
<meta property="article:tag" content="HashSet">
<meta property="article:tag" content="LinkedList">
<meta property="article:tag" content="Fail-Fast策略">
<meta property="article:tag" content="Spliterator">
<meta property="article:tag" content="TreeSet">
<meta property="article:tag" content="LinkedBlockingQueue">
<meta property="article:tag" content="抽象类">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zcralx.github.io/assets/img/01.jpg">


<link rel="canonical" href="https://zcralx.github.io/posts/d366874c/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zcralx.github.io/posts/d366874c/","path":"posts/d366874c/","title":"集合"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>集合 | zcralx's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">zcralx's blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">多喜乐，长安宁，愿你一切都好</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">29</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">12</span></a></li><li class="menu-item menu-item-象棋"><a href="/xiangqi/" rel="section"><i class="fa fa-chess-rook fa-fw"></i>象棋</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">
  
    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.</span> <span class="nav-text">Collection&lt;E&gt;接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.1.</span> <span class="nav-text">Collection接口定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SequencedCollection"><span class="nav-number">1.1.2.</span> <span class="nav-text">SequencedCollection&lt;E&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.3.</span> <span class="nav-text">List&lt;E&gt;接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">部分方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#replaceAll%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.3.1.1.</span> <span class="nav-text">replaceAll方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sort%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.3.1.2.</span> <span class="nav-text">sort方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.4.</span> <span class="nav-text">Set&lt;E&gt;接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E6%96%B9%E6%B3%95-1"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">部分方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.5.</span> <span class="nav-text">Queue&lt;E&gt;接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">Queue接口定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Deque%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">Deque&lt;E&gt;接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Deque%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.5.2.1.</span> <span class="nav-text">Deque接口定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BlockingQueue%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">BlockingQueue&lt;E&gt;接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BlockingQueue%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.5.3.1.</span> <span class="nav-text">BlockingQueue接口定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BlockingQueue%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">1.1.5.3.2.</span> <span class="nav-text">BlockingQueue主要实现类</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.</span> <span class="nav-text">Map&lt;K,V&gt;接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">Map接口定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#compute%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">compute方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merge%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">merge方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#replaceAll%E6%96%B9%E6%B3%95-1"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">replaceAll方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SafeVarargs%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">@SafeVarargs注解</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E5%85%88%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86"><span class="nav-number">2.1.</span> <span class="nav-text">需要先了解的一些知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97"><span class="nav-number">2.1.1.</span> <span class="nav-text">线程安全队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.1.2.</span> <span class="nav-text">抽象类的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8D%95%E6%8D%89%E5%AD%90%E7%B1%BB%E7%9A%84%E9%80%9A%E7%94%A8%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">捕捉子类的通用特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">定义抽象方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">实现接口的模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E7%B1%BB%E5%9E%8B%E7%BB%86%E8%8A%82"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">隐藏类型细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E6%89%A9%E5%B1%95%E6%80%A7"><span class="nav-number">2.1.2.5.</span> <span class="nav-text">模块化与扩展性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">2.1.2.6.</span> <span class="nav-text">防止实例化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractCollection"><span class="nav-number">2.1.3.</span> <span class="nav-text">AbstractCollection&lt;E&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AbstractList"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">AbstractList&lt;E&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#modCount"><span class="nav-number">2.1.3.1.1.</span> <span class="nav-text">modCount</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="nav-number">2.1.3.1.2.</span> <span class="nav-text">迭代器的一致性检查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Fail-Fast-%E7%AD%96%E7%95%A5"><span class="nav-number">2.1.3.1.3.</span> <span class="nav-text">Fail-Fast 策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AbstractSequentialList"><span class="nav-number">2.1.3.1.4.</span> <span class="nav-text">AbstractSequentialList&lt;E&gt;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomAccess"><span class="nav-number">2.1.4.</span> <span class="nav-text">RandomAccess</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cloneable"><span class="nav-number">2.1.5.</span> <span class="nav-text">Cloneable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#clone%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">clone方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serializable"><span class="nav-number">2.1.6.</span> <span class="nav-text">Serializable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SortedSet"><span class="nav-number">2.1.7.</span> <span class="nav-text">SortedSet&lt;E&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NavigableSet"><span class="nav-number">2.1.8.</span> <span class="nav-text">NavigableSet&lt;E&gt;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList"><span class="nav-number">2.2.</span> <span class="nav-text">ArrayList&lt;E&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">2.2.1.</span> <span class="nav-text">继承关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.2.</span> <span class="nav-text">成员属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">2.2.3.</span> <span class="nav-text">扩容机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">2.2.4.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E6%96%B9%E6%B3%95-2"><span class="nav-number">2.2.5.</span> <span class="nav-text">部分方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.2.6.</span> <span class="nav-text">add操作流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedList"><span class="nav-number">2.3.</span> <span class="nav-text">LinkedList&lt;E&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E6%96%B9%E6%B3%95-3"><span class="nav-number">2.3.2.</span> <span class="nav-text">部分方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">2.3.3.</span> <span class="nav-text">索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashSet"><span class="nav-number">2.4.</span> <span class="nav-text">HashSet&lt;E&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EHashMap"><span class="nav-number">2.4.1.</span> <span class="nav-text">基于HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet%E5%8E%BB%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">2.4.2.</span> <span class="nav-text">HashSet去重复的机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-2"><span class="nav-number">2.4.3.</span> <span class="nav-text">构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90-LoadFactor"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">加载因子(LoadFactor)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E6%96%B9%E6%B3%95-4"><span class="nav-number">2.4.4.</span> <span class="nav-text">部分方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashSet"><span class="nav-number">2.4.5.</span> <span class="nav-text">LinkedHashSet&lt;E&gt;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeSet"><span class="nav-number">2.5.</span> <span class="nav-text">TreeSet&lt;E&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-3"><span class="nav-number">2.5.1.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-1"><span class="nav-number">2.5.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="nav-number">2.5.3.</span> <span class="nav-text">对自定义类型对象如何进行排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparable%E4%B8%8EComparator"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">Comparable与Comparator</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">2.6.</span> <span class="nav-text">HashMap&lt;K,V&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-1"><span class="nav-number">2.6.1.</span> <span class="nav-text">继承关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E5%8F%98%E9%87%8F"><span class="nav-number">2.6.2.</span> <span class="nav-text">重要变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-4"><span class="nav-number">2.6.3.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK1-8%E4%B8%ADHashMap%E6%94%B9%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.6.4.</span> <span class="nav-text">JDK1.8中HashMap改了什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">2.6.5.</span> <span class="nav-text">HashMap的线程不安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashTable%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">2.6.5.1.</span> <span class="nav-text">HashTable如何保证线程安全？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">2.6.5.2.</span> <span class="nav-text">ConcurrentHashMap 如何保证线程安全？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">2.6.6.</span> <span class="nav-text">LinkedHashMap&lt;K,V&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-5"><span class="nav-number">2.6.6.1.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E6%96%B9%E6%B3%95-5"><span class="nav-number">2.6.6.2.</span> <span class="nav-text">部分方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#removeEldestEntry%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.6.6.2.1.</span> <span class="nav-text">removeEldestEntry使用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95"><span class="nav-number">2.6.6.3.</span> <span class="nav-text">实现LRU算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap"><span class="nav-number">2.7.</span> <span class="nav-text">TreeMap&lt;K,V&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-2"><span class="nav-number">2.7.1.</span> <span class="nav-text">继承关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">2.7.2.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-6"><span class="nav-number">2.7.3.</span> <span class="nav-text">构造器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">2.8.</span> <span class="nav-text">ArrayBlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.8.1.</span> <span class="nav-text">类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E9%98%9F%E9%80%BB%E8%BE%91"><span class="nav-number">2.8.2.</span> <span class="nav-text">入队逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BA%E9%98%9F%E9%80%BB%E8%BE%91"><span class="nav-number">2.8.3.</span> <span class="nav-text">出队逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E9%98%9F%E9%98%BB%E5%A1%9E%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.8.4.</span> <span class="nav-text">入队阻塞实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8put%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E9%98%BB%E5%A1%9E%E5%BC%8F%E5%85%A5%E9%98%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">2.8.5.</span> <span class="nav-text">调用put方法进行阻塞式入队的基本流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E6%97%B6%E7%9A%84%E5%85%A5%E9%98%9F"><span class="nav-number">2.8.6.</span> <span class="nav-text">限时的入队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BA%E9%98%9F%E9%98%BB%E5%A1%9E%E5%AE%9E%E7%8E%B0-%E9%99%90%E6%97%B6%E5%87%BA%E9%98%9F"><span class="nav-number">2.8.7.</span> <span class="nav-text">出队阻塞实现 &amp; 限时出队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">2.8.8.</span> <span class="nav-text">构造方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">2.9.</span> <span class="nav-text">LinkedBlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89-1"><span class="nav-number">2.9.1.</span> <span class="nav-text">类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="nav-number">2.9.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put%E6%96%B9%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">2.9.3.</span> <span class="nav-text">put方法是如何实现的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.9.3.1.</span> <span class="nav-text">出队操作</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spliterator"><span class="nav-number">3.1.</span> <span class="nav-text">Spliterator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">主要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.2.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ListIterator"><span class="nav-number">3.2.</span> <span class="nav-text">ListIterator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#descendingIterator"><span class="nav-number">3.3.</span> <span class="nav-text">descendingIterator</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="魚"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">魚</p>
  <div class="site-description" itemprop="description">yuyu6661@foxmail.com</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zcralx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zcralx" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/zzzzzzzzzzz-90-37" title="zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;zzzzzzzzzzz-90-37" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>zhihu</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zcralx.github.io/posts/d366874c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="魚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zcralx's blog">
      <meta itemprop="description" content="yuyu6661@foxmail.com">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="集合 | zcralx's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          集合
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-06 21:50:14" itemprop="dateCreated datePublished" datetime="2024-04-06T21:50:14+08:00">2024-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-05 21:41:41" itemprop="dateModified" datetime="2024-06-05T21:41:41+08:00">2024-06-05</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>31k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>56 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><img src="/assets/img/01.jpg" alt="桌面图片" title="蒙眼少女"></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1959528822&auto=0&height=66"></iframe>

<p>[TOC]</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection&lt;E&gt;接口"></a>Collection&lt;E&gt;接口</h2><p>Collection是<strong>单列</strong>集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是 <strong>java.util.List</strong> 与 <strong>java.util.Set</strong>。</p>
<span id="more"></span>

<h3 id="Collection接口定义"><a href="#Collection接口定义" class="headerlink" title="Collection接口定义"></a>Collection接口定义</h3><p>继承自Iterable&lt;E&gt;，方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>仅保留此列表中指定集合c中包含的元素</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span></span><br><span class="line">Object[] toArray()</span><br><span class="line"><span class="keyword">default</span> &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator)</span><br><span class="line">&lt;T&gt; T[] toArray(T[] a)</span><br></pre></td></tr></table></figure>
<h3 id="SequencedCollection"><a href="#SequencedCollection" class="headerlink" title="SequencedCollection&lt;E&gt;"></a>SequencedCollection&lt;E&gt;</h3><p>顺序集合，java21中新增特性，这里的顺序指的是在遍历一个集合时，集合中元素的出现顺序。</p>
<p>与顺序集合相关的操作包括：获取集合的第一个和最后一个元素、在集合的最前面和最后面插入或删除元素、按照逆序来遍历集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SequencedCollection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>/addLast(E e)</span><br><span class="line"><span class="keyword">default</span> E <span class="title function_">getFirst</span><span class="params">()</span>/getLast()</span><br><span class="line"><span class="keyword">default</span> E <span class="title function_">removeFirst</span><span class="params">()</span>/removeLast()</span><br><span class="line">SequencedCollection&lt;E&gt; <span class="title function_">reversed</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h3 id="List接口"><a href="#List接口" class="headerlink" title="List&lt;E&gt;接口"></a>List&lt;E&gt;接口</h3><p>List集合中的元素存储有序、可重复、可索引。</p>
<h4 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h4><p>List扩展了SequencedCollection接口，支持两端操作，并且可以在指定索引位置操作，并且支持自定义比较规则进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyOf</span><span class="params">(Collection&lt;? extends E&gt; coll)</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>/<span class="keyword">default</span> E <span class="title function_">getFirst</span><span class="params">()</span>/<span class="keyword">default</span> E <span class="title function_">getLast</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>/<span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span><span class="comment">//返回指定元素最后一次出现的索引</span></span><br><span class="line">ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span>/ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">of</span><span class="params">()</span><span class="comment">//返回一个空list</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">of</span><span class="params">(E e1,E e2,...)</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>/<span class="keyword">default</span> E <span class="title function_">removeFirst</span><span class="params">()</span>/<span class="keyword">default</span> E <span class="title function_">removeLast</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span></span><br><span class="line"><span class="keyword">default</span> List&lt;E&gt; <span class="title function_">reversed</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,E element)</span><span class="comment">//将List中指定位置的元素替换为指定元素。</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex,<span class="type">int</span> toIndex)</span><span class="comment">//类似于切片操作</span></span><br></pre></td></tr></table></figure>
<h5 id="replaceAll方法"><a href="#replaceAll方法" class="headerlink" title="replaceAll方法"></a>replaceAll方法</h5><p>按照替换规则替换列表中符合要求的所有元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, -<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">numbers.replaceAll(n -&gt; n &gt; <span class="number">0</span> ? n * <span class="number">2</span> : n);<span class="comment">// 数列变为 [2, -2, 6, -4, 10]</span></span><br></pre></td></tr></table></figure>

<h5 id="sort方法"><a href="#sort方法" class="headerlink" title="sort方法"></a>sort方法</h5><p><code>Comparator&lt;? super E&gt;</code>是一个比较器接口，用于定义元素间的比较规则。如果列表元素类型E自身实现了<code>Comparable</code>接口（如<code>String</code>、<code>Integer</code>等），则可以省略这个参数，使用元素自身的自然排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>);</span><br><span class="line">words.sort(Comparator.comparingInt(String::length));<span class="comment">// 数列现在变为 [&quot;cat&quot;, &quot;dog&quot;, &quot;apple&quot;, &quot;banana&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set&lt;E&gt;接口"></a>Set&lt;E&gt;接口</h3><p>元素不重复，存储无序。和List不一样，Set直接继承自Collection。</p>
<h4 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">copyOf</span><span class="params">(Collection&lt;? extends E&gt; coll)</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">of</span><span class="params">()</span>/<span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">of</span><span class="params">(E e1,...)</span></span><br></pre></td></tr></table></figure>

<p>Set不支持索引操作，也不支持两端操作，也没有看到有sort方法（Set接口定义的是共性的方法，但是不代表所有的Set都不可排序）。</p>
<h3 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue&lt;E&gt;接口"></a>Queue&lt;E&gt;接口</h3><p><code>Queue</code>也直接继承自<code>Collection</code>接口。</p>
<h4 id="Queue接口定义"><a href="#Queue接口定义" class="headerlink" title="Queue接口定义"></a>Queue接口定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;<span class="comment">//向队列中添加一个元素；成功返回true，失败则抛出异常</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;<span class="comment">//向队列中添加一个元素；成功返回true，否则返回false</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">()</span>;<span class="comment">//从队列中删除队首元素，并返回该元素，没有则抛出NoSuchElementException异常</span></span><br><span class="line">E <span class="title function_">poll</span><span class="params">()</span>;<span class="comment">//从队列中删除队首元素，并返回该元素，没有则返回null</span></span><br><span class="line">E <span class="title function_">element</span><span class="params">()</span>;<span class="comment">//从队列获取队首元素，没有元素则抛出NoSuchElementException异常</span></span><br><span class="line">E <span class="title function_">peek</span><span class="params">()</span>;<span class="comment">//从队列获取队首元素，没有元素则返回null</span></span><br></pre></td></tr></table></figure>

<h4 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque&lt;E&gt;接口"></a>Deque&lt;E&gt;接口</h4><p>双端队列，Deque继承自Queue接口和SequencedCollection接口。操作方法与<code>Queue</code>的操作方法类似，只是指定了在队首还是队尾进行元素操作。</p>
<h5 id="Deque接口定义"><a href="#Deque接口定义" class="headerlink" title="Deque接口定义"></a>Deque接口定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>/<span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>/ <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span>/E <span class="title function_">removeLast</span><span class="params">()</span></span><br><span class="line">E <span class="title function_">pollFirst</span><span class="params">()</span>/E <span class="title function_">pollLast</span><span class="params">()</span></span><br><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>/E <span class="title function_">getLast</span><span class="params">()</span> </span><br><span class="line">E <span class="title function_">peekFirst</span><span class="params">()</span>/ E <span class="title function_">peekLast</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span>/<span class="type">boolean</span> <span class="title function_">removeLastOccurrence</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">//从队列中删除第一次/最后一次出现的该元素</span></span><br><span class="line"><span class="keyword">default</span> Deque&lt;E&gt; <span class="title function_">reversed</span><span class="params">()</span></span><br><span class="line">E <span class="title function_">pop</span><span class="params">()</span>/E <span class="title function_">push</span><span class="params">()</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span> </span><br></pre></td></tr></table></figure>
<h4 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue&lt;E&gt;接口"></a>BlockingQueue&lt;E&gt;接口</h4><p>阻塞队列，在入队和出队时进行加锁，保证了队列线程安全；当队列满时，会阻塞入队的线程，直到队列不满；当队列为空时，会阻塞出队的线程，直到队列中有元素。</p>
<p>常用于<strong>生产者-消费者模型</strong>中，往队列里添加元素的是生产者，从队列中获取元素的是消费者；通常情况下生产者和消费者都是由多个线程组成。生产者和消费者之间通过队列平衡两者的的处理能力、进行解耦等。</p>
<h5 id="BlockingQueue接口定义"><a href="#BlockingQueue接口定义" class="headerlink" title="BlockingQueue接口定义"></a>BlockingQueue接口定义</h5><p>继承自Queue接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//入队一个元素，如果有空间则直接插入，如果没有空间则一直阻塞等待</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//入队一个元素，如果没有空间则等待timeout时间，插入失败则返回false</span></span><br><span class="line">E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//检索并出队一个元素，如果不可获元素得则一直阻塞等待</span></span><br><span class="line">E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//出队一个元素，如果元素不可获得则等待timeout时间，无元素则返回null</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remainingCapacity</span><span class="params">()</span><span class="comment">//返回该队列剩余的容量（如果没有限制则返回Integer.MAX_VALUE）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c)</span><span class="comment">//将队列中的所有元素出队，并添加到给定的集合c中，返回出队的元素数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c, <span class="type">int</span> maxElements)</span></span><br><span class="line"><span class="comment">//将队列中的元素出队，限制数量maxElements个，并添加到给定的集合c中，返回出队的元素数量</span></span><br></pre></td></tr></table></figure>

<h5 id="BlockingQueue主要实现类"><a href="#BlockingQueue主要实现类" class="headerlink" title="BlockingQueue主要实现类"></a>BlockingQueue主要实现类</h5><p>主要有5个实现类：</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ArrayBlockingQueue</strong></td>
<td>使用数组存储数据，初始化时需要指定其容量，所以是一个<strong>有界队列</strong>，还可以设置内部的ReentrantLock是否使用公平锁。但是公平性会在性能上付出代价，只有在的确非常需要的时候再使用它。是一个基于数组的阻塞循环队列。</td>
</tr>
<tr>
<td><strong>LinkedBlockingQueue</strong></td>
<td>使用链表存储数据，默认是一个大小为Integer.MAX_VALUE的无界队列（如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。尽量自己传值，避免队列过大造成机器负载或者内存爆满等情况）；也可以通过构造方法中的<code>capacity</code>设置最大元素数量，所以也可以作为<strong>有界队列</strong>。</td>
</tr>
<tr>
<td><strong>SynchronousQueue</strong></td>
<td>一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并且立刻消费。它的特别之处在于它内部没有容器，一个生产线程，当它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递），这样的一个过程称为一次配对过程(当然也可以先take后put,原理是一样的)。</td>
</tr>
<tr>
<td><strong>PriorityBlockingQueue</strong></td>
<td>内部由优先级堆支持的无界优先级队列，队列中的元素按优先级顺序被移除。底层基于数组实现，是一个<strong>无界队列</strong>。<strong>PriorityBlockingQueue就是PriorityQueue的加锁线程安全版。</strong></td>
</tr>
<tr>
<td><strong>DelayQueue</strong></td>
<td><strong>一个内部由优先级堆支持的、基于时间的调度队列</strong>。队列中存放Delayed元素，只有在延迟期满后才能从队列中提取元素。当一个元素的getDelay()方法返回值小于等于0时才能从队列中poll中元素，否则poll()方法会返回null。无界阻塞队列，该队列的头部是延迟期满后保存时间最长的Delayed 元素。缓存系统的设计，缓存中的对象，超过了空闲时间，需要从缓存中移出；任务调度系统，能够准确的把握任务的执行时间。我们可能需要通过线程处理很多时间上要求很严格的数据。可以考虑<code>DelayQueue</code>。</td>
</tr>
</tbody></table>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map&lt;K,V&gt;接口"></a>Map&lt;K,V&gt;接口</h2><p>双列集合的根接口，表明一种映射关系。</p>
<h3 id="Map接口定义"><a href="#Map接口定义" class="headerlink" title="Map接口定义"></a>Map接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> </span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">compute</span><span class="params">(K key,BiFunction&lt;? <span class="built_in">super</span> K,? <span class="built_in">super</span> V,? extends V&gt; remappingFunction)</span></span><br><span class="line"><span class="comment">//根据给定的键（key）和一个双参数函数（remappingFunction），计算并更新与该键相关联的值。</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">computeIfAbsent</span><span class="params">(K key,Function&lt;? <span class="built_in">super</span> K,? extends V&gt; mappingFunction)</span><span class="comment">//在键不存在时计算并插入新值</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">computeIfPresent</span><span class="params">(K key,BiFunction&lt;? <span class="built_in">super</span> K,? <span class="built_in">super</span> V,? extends V&gt; remappingFunction)</span><span class="comment">//仅在键存在时计算并更新现有值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>/<span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span></span><br><span class="line"><span class="keyword">static</span> &lt;K, V&gt; Map&lt;K,V&gt; <span class="title function_">copyOf</span><span class="params">(Map&lt;? extends K,? extends V&gt; map)</span></span><br><span class="line"><span class="keyword">static</span> &lt;K, V&gt; Map.Entry&lt;K,V&gt; <span class="title function_">entry</span><span class="params">(K k,V v)</span><span class="comment">//获取map的entry对象，常用于遍历</span></span><br><span class="line"><span class="meta">@SafeVarargs</span> <span class="keyword">static</span> &lt;K, V&gt; Map&lt;K,V&gt; <span class="title function_">ofEntries</span><span class="params">(Map.Entry&lt;? extends K,? extends V&gt;... entries)</span></span><br><span class="line"><span class="comment">//根据提供的entries可变参数创建并返回一个不可变的Map实例。注意，返回的映射是不可修改的（unmodifiable），即不能添加、删除或更新键值对。</span></span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()/Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>/Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>/<span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> K,? <span class="built_in">super</span> V&gt; action)</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key,V defaultValue)</span></span><br><span class="line"><span class="comment">//get or default，如果键key在映射中存在，方法会返回与该键关联的实际值；如果不存在返回默认值defaultValue</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>/<span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">merge</span><span class="params">(K key,V value,BiFunction&lt;? <span class="built_in">super</span> V,? <span class="built_in">super</span> V,? extends V&gt; remappingFunction)</span></span><br><span class="line"><span class="keyword">static</span> &lt;K, V&gt; Map&lt;K,V&gt; <span class="title function_">of</span><span class="params">()</span>/<span class="keyword">static</span> &lt;K, V&gt; Map&lt;K,V&gt; <span class="title function_">of</span><span class="params">(K,V,K,V,...)</span></span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span>/<span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K,? extends V&gt; m)</span>/<span class="keyword">default</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key,V value)</span></span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span>/<span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key,Object value)</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">replace</span><span class="params">(K key,V value)</span>/<span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key,V oldValue,V newValue)</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> K,? <span class="built_in">super</span> V,? extends V&gt; function)</span></span><br></pre></td></tr></table></figure>

<h4 id="compute方法"><a href="#compute方法" class="headerlink" title="compute方法"></a>compute方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; wordsMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;word&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">updateCount</span> <span class="operator">=</span> wordsMap.compute(a,(k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);<span class="comment">//word:1</span></span><br></pre></td></tr></table></figure>

<p>这里的compute的第二个参数是一个Lambda表达式，接收当前键K和值V，V为空则置为1，并将值返回给updateCount。本来key&#x3D;”word”对应的value为null，经过compute函数后，value&#x3D;1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count0</span> <span class="operator">=</span> wordsMap.computeIfAbsent(a, k -&gt; <span class="number">3</span>);<span class="comment">//不会修改，依旧是word:1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> wordsMap.computeIfAbsent(b, k -&gt; <span class="number">3</span>);<span class="comment">//word:1, world:3</span></span><br><span class="line"><span class="type">int</span> <span class="variable">updated</span> <span class="operator">=</span> wordsMap.computeIfPresent(b,(k,v) -&gt;  v == <span class="number">3</span> ? <span class="number">2</span> : <span class="number">4</span>);<span class="comment">//word:1,world:2</span></span><br></pre></td></tr></table></figure>

<h4 id="merge方法"><a href="#merge方法" class="headerlink" title="merge方法"></a>merge方法</h4><p>将指定的键值对（<code>key</code>和<code>value</code>）合并到映射中。如果映射中已经存在与该键关联的值，那么将使用提供的<code>remappingFunction</code>来决定如何合并新值和现有值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; wordCounts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> <span class="string">&quot;example&quot;</span>;<span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">mergedCount1</span> <span class="operator">=</span> wordCounts.merge(word,newValue,Integer::sum);<span class="comment">//5;   example:5</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mergedCount2</span> <span class="operator">=</span> wordCounts.merge(word,newValue,Integer::sum);<span class="comment">//10;   example:10</span></span><br></pre></td></tr></table></figure>

<h4 id="replaceAll方法-1"><a href="#replaceAll方法-1" class="headerlink" title="replaceAll方法"></a>replaceAll方法</h4><p>对于映射中的每个键值对，<code>function</code>都会被调用，其返回值将替换原有的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; employeeAges = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ... (填充映射数据)</span></span><br><span class="line">employeeAges.replaceAll((id, age) -&gt; age + <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h4 id="SafeVarargs注解"><a href="#SafeVarargs注解" class="headerlink" title="@SafeVarargs注解"></a>@SafeVarargs注解</h4><p>用于声明一个方法是类型安全的可变参数方法，消除编译器对**可变参数(varargs)**方法可能导致类型安全问题的警告，并告诉编译器开发者已经确保了在使用可变参数时不会出现类型不匹配或安全隐患。</p>
<h1 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h1><h2 id="需要先了解的一些知识"><a href="#需要先了解的一些知识" class="headerlink" title="需要先了解的一些知识"></a>需要先了解的一些知识</h2><h3 id="线程安全队列"><a href="#线程安全队列" class="headerlink" title="线程安全队列"></a>线程安全队列</h3><p>在Java中，提供了两种线程安全队列的实现方式：一种是<strong>阻塞机制</strong>，另一种是<strong>非阻塞机制</strong>。</p>
<p>使用阻塞机制的队列，是通过使用<strong>锁</strong>的方式来实现，在入队和出队时通过加锁避免并发操作，比如BlockingQueue就是一个线程安全的阻塞队列；</p>
<p>而使用非阻塞机制的队列，是通过使用<strong>CAS方式</strong>实现，比如ConcurrentLinkedQueue。</p>
<h3 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h3><h4 id="捕捉子类的通用特性"><a href="#捕捉子类的通用特性" class="headerlink" title="捕捉子类的通用特性"></a>捕捉子类的通用特性</h4><p>抽象类用于定义一组相关或相似类的共同属性和行为。这些类可能在某些方面有所不同，但在某些核心特征和功能上具有共性。</p>
<p>抽象类将这些共性抽取出来，形成一个通用模板，为子类提供一个统一的结构和接口。</p>
<p>子类可以从抽象类继承并专注于实现其特有的细节，而不必重复编写通用部分的代码。</p>
<h4 id="定义抽象方法"><a href="#定义抽象方法" class="headerlink" title="定义抽象方法"></a>定义抽象方法</h4><p>抽象类可以包含抽象方法（abstract关键字修饰），这些方法只有声明而没有具体实现。子类必须提供抽象方法的实现，否则子类自身也需要声明为抽象类。</p>
<p>这种机制强制子类对特定功能进行实现，确保了子类具备某种约定的能力，增强了代码的规范性和一致性。</p>
<h4 id="实现接口的模板"><a href="#实现接口的模板" class="headerlink" title="实现接口的模板"></a>实现接口的模板</h4><p>抽象类可以作为实现某个接口（或多个接口）的模板。它不仅定义了接口所需的方法签名，还可以提供部分或全部方法的默认实现。这样，子类可以直接继承抽象类，从而实现接口的同时，利用抽象类提供的默认行为，避免了重复实现接口中所有方法的繁琐工作。</p>
<p>这在Java 8之后引入的默认方法（default ）特性之前尤为有用，那时的接口不能包含方法实现。</p>
<h4 id="隐藏类型细节"><a href="#隐藏类型细节" class="headerlink" title="隐藏类型细节"></a>隐藏类型细节</h4><p>抽象类可用于隐藏具体类型的实现细节，对外提供一致的接口。客户端代码可以操作抽象类的实例，而不必关心实际使用的具体子类。</p>
<p>这种类型隐藏提高了代码的灵活性和可扩展性，因为可以随时替换为其他实现了相同抽象类的子类，而无需修改依赖抽象类的代码。</p>
<h4 id="模块化与扩展性"><a href="#模块化与扩展性" class="headerlink" title="模块化与扩展性"></a>模块化与扩展性</h4><p>模块或框架可以通过定义抽象类来规定其扩展点或插件接口。其他开发人员只需创建继承自该抽象类的子类，即可实现特定功能的扩展。</p>
<h4 id="防止实例化"><a href="#防止实例化" class="headerlink" title="防止实例化"></a>防止实例化</h4><p>抽象类不能直接被实例化，只能作为其他类的父类使用。这一特性确保了抽象类只能用于定义通用结构和行为，而非用于创建独立的对象实例。</p>
<p>这有助于避免因误用抽象类而导致的运行时错误。</p>
<h3 id="AbstractCollection"><a href="#AbstractCollection" class="headerlink" title="AbstractCollection&lt;E&gt;"></a>AbstractCollection&lt;E&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>实现了 <code>Collection</code> 接口的部分方法，提供了诸如元素计数、迭代器创建等通用功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> <span class="keyword">throws</span> UnsupportedOperationException,ClassCastException,NullPointerException,IllegalArgumentException,IllegalStateException</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="keyword">throws</span> </span><br><span class="line">UnsupportedOperationException,ClassCastException,NullPointerException,IllegalArgumentException,IllegalStateException</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedOperationException</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>/containsAll(Collection&lt;?&gt; c) <span class="keyword">throws</span> ClassCastException,NullPointerException</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>/removeAll(Collection&lt;?&gt; c) <span class="keyword">throws</span> </span><br><span class="line">UnsupportedOperationException,ClassCastException,NullPointerException </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> <span class="keyword">throws</span></span><br><span class="line">UnsupportedOperationException,ClassCastException,NullPointerException</span><br><span class="line">Object[] toArray()</span><br><span class="line">&lt;T&gt; T[] toArray(T[] a) <span class="keyword">throws</span> ArrayStoreException,NullPointerException </span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h4 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList&lt;E&gt;"></a>AbstractList&lt;E&gt;</h4><p><code>AbstractList</code> 主要目的是简化 <code>List</code> 接口的实现工作，特别是针对那些基于随机访问数据存储的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index,E element)</span>/<span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>/<span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index,Collection&lt;? extends E&gt; c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>/<span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>/<span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>/ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span>/ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>/<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex,<span class="type">int</span> toIndex)</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,E element)</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex,<span class="type">int</span> toIndex)</span></span><br></pre></td></tr></table></figure>

<h5 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h5><p>该类中还定义了modCount：<code>protected transient int modCount</code>，用于跟踪集合结构被修改的次数。</p>
<h5 id="迭代器的一致性检查"><a href="#迭代器的一致性检查" class="headerlink" title="迭代器的一致性检查"></a>迭代器的一致性检查</h5><p>当使用集合的迭代器进行遍历时，迭代器会记录一个初始的 <code>modCount</code> 值（即 <code>expectedModCount</code>）。在每次迭代过程中或执行迭代器方法（如 <code>next()</code> 或 <code>remove()</code>）时，迭代器会检查当前的 <code>modCount</code> 是否与 <code>expectedModCount</code> 相匹配。</p>
<p>如果在迭代过程中集合的结构发生了改变（如添加、删除、更新元素），会导致 <code>modCount</code> 增加。当发现 <code>modCount</code> 与 <code>expectedModCount</code> 不一致时，迭代器会立即抛出 <code>ConcurrentModificationException</code> 异常，这种机制称为 <strong>快速失败（Fail-Fast）</strong>。</p>
<p>它旨在尽早检测到并发修改，并阻止程序继续在已失效的迭代器上操作，从而避免潜在的不确定行为和数据不一致。</p>
<h5 id="Fail-Fast-策略"><a href="#Fail-Fast-策略" class="headerlink" title="Fail-Fast 策略"></a>Fail-Fast 策略</h5><p>Fail-Fast 是迭代器的一种设计选择，它不保证线程安全，而是选择在检测到并发修改时迅速失败，而不是冒着在不同步访问下产生不可预见结果的风险。</p>
<p>在多线程环境下，<code>modCount</code> 变量需要被声明为 <code>volatile</code>，确保其修改对所有线程立即可见。</p>
<h5 id="AbstractSequentialList"><a href="#AbstractSequentialList" class="headerlink" title="AbstractSequentialList&lt;E&gt;"></a>AbstractSequentialList&lt;E&gt;</h5><p>专门为那些支持顺序访问（sequential access）的列表实现设计的，与 <code>AbstractList&lt;E&gt;</code> 相比，<code>AbstractSequentialList&lt;E&gt;</code> 更侧重于简化对这种特定访问模式的支持，尤其是对于那些底层数据结构不适合随机访问的列表实现，如链表。</p>
<p>基于ListIterator来实现大部分List接口的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index,E element)</span>/<span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index,Collection&lt;? extends E&gt; c)</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>/E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>/E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,E element)</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>/<span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>

<h3 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h3><p>一个标记接口（tag interface），它没有定义任何方法，仅作为一种标识存在。当一个类（如 <code>ArrayList</code>）实现 <code>RandomAccess</code> 接口时，它表示该类支持快速随机访问元素。</p>
<h3 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h3><p>一个标记接口，表示类支持克隆操作。实现此接口的类可以被安全地复制，产生一个与原对象内容相同的新对象。</p>
<h4 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h4><p>由于clone返回的是Object对象，使用时可能需要强制转换成其他类型（如：ArrayList）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; originalList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ... 填充原始列表 ...</span></span><br><span class="line">ArrayList&lt;String&gt; clonedList = (ArrayList&lt;String&gt;) originalList.clone();</span><br></pre></td></tr></table></figure>

<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>表示类支持 Java 序列化机制。实现 <code>Serializable</code> 的类需要遵循一定的序列化规则，确保其实例在序列化和反序列化过程中保持语义上的正确性和一致性。</p>
<h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet&lt;E&gt;"></a>SortedSet&lt;E&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortedSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Set</span>&lt;E&gt;, SequencedSet&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>顾名思义，维持集合的有序。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addFirst,addLast,comparator,getFirst/getLast,spliterator,reversed</span><br><span class="line">E <span class="title function_">first</span><span class="params">()</span>/last() 返回最小/大元素</span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement)</span> <span class="comment">//包含集合中所有小于（或等于，取决于排序规则）toElement 的元素</span></span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement)</span>/SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement,E toElement)</span></span><br></pre></td></tr></table></figure>

<h3 id="NavigableSet"><a href="#NavigableSet" class="headerlink" title="NavigableSet&lt;E&gt;"></a>NavigableSet&lt;E&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NavigableSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">SortedSet</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>扩展了 SortedSet接口，提供了更丰富的排序和搜索功能。<code>NavigableSet</code> 主要用于存储唯一且有序的元素，并且允许高效地在有序集合中进行导航和范围查询。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">descendingIterator,descendingSet,pollFirst,pollLast,removeFirst,removeLast</span><br><span class="line">E <span class="title function_">ceiling</span><span class="params">(E e)</span><span class="comment">//返回集合中大于等于给定元素 e 的最小元素 </span></span><br><span class="line">E <span class="title function_">higher</span><span class="params">(E e)</span><span class="comment">// 返回集合中大于给定元素 e 的最小元素</span></span><br><span class="line">E <span class="title function_">floor</span><span class="params">(E e)</span><span class="comment">//返回集合中小于等于给定元素 e 的最大元素</span></span><br><span class="line">E <span class="title function_">lower</span><span class="params">(E e)</span><span class="comment">//返回集合中小于给定元素 e 的最大元素</span></span><br><span class="line">NavigableSet&lt;E&gt; headSet/tailSet(E,<span class="type">boolean</span> inclusive)<span class="comment">//inclusive:是否包含端点</span></span><br><span class="line">NavigableSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E,<span class="type">boolean</span> fromInclusive,E,<span class="type">boolean</span> ToInclusive)</span></span><br></pre></td></tr></table></figure>

<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList&lt;E&gt;"></a>ArrayList&lt;E&gt;</h2><p>基于数组实现的类，可扩容，非线程安全。</p>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认的空的数组，这个主要是在构造方法初始化一个空数组的时候使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//使用默认size大小的空数组实例，和EMPTY_ELEMENTDATA区分开来，这样可以知道当第一个元素添加的时候进行扩容至多少</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="comment">//一个空的实例elementData，为上面的DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>当加入新元素时，数组容量不足则需要扩容。计算扩容所需容量minCapacity，计算新数组容量newCapacity：旧容量的1.5倍。如果new小于min，则将min作为新数组容量；如果new小于0，抛出越界异常；如果new 大于<code> Integer.MAX_VALUE - 8</code>，则取<code>Integer.MAX_VALUE</code>或<code> Integer.MAX_VALUE - 8</code>为新的数组容量。最后通过Array.copyOf对新数组赋值。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造一个空的数组集合，初始的elementData的容量为0，第一次添加元素的时候则扩容elementData为10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//elementData才是实际存放元素的数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个集合转变为ArrayList，实际上就是将集合中的元素换为了数组的形式。如果传入的集合为null会抛出空指针异常（调用c.toArray()方法的时候）</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//c.toArray()可能不会正确地返回一个 Object[]数组，那么使用Arrays.copyOf()方法</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果集合转换为数组之后数组长度为0，就直接使用自己的空成员变量初始化elementData</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="部分方法-2"><a href="#部分方法-2" class="headerlink" title="部分方法"></a>部分方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">clone</span><span class="params">()</span><span class="comment">//返回ArrayList实例的浅拷贝，新创建的对象中的相应元素与原对象中的对应部分指向相同的内存位置。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span><span class="comment">//增加容量确保至少大于minCapacity</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span><span class="comment">//将列表的容量修剪至当前大小</span></span><br></pre></td></tr></table></figure>

<h3 id="add操作流程"><a href="#add操作流程" class="headerlink" title="add操作流程"></a>add操作流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为要添加元素，所以添加之后可能导致容量不够，所以需要在添加之前进行判断（扩容）：<code>ensureCapacityInternal(size + 1)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当要add进第一个元素时，minCapacity为size+1&#x3D;1，在Math.max()方法比较后，minCapacity为10。紧接着调用ensureExplicitCapacity更新modCount的值，并判断是否需要扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++; </span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>超出容量则需要扩容grow，grow的流程也就是上面提到的扩容机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意到这个hugeCapacity方法，简单看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList&lt;E&gt;"></a>LinkedList&lt;E&gt;</h2><p>基于双向链表实现的类，可索引但是比较慢，非线程安全。既可以作为双端队列使用，也可以作为栈使用，同时还支持快速地在列表中间进行插入和删除操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>在LinkedList中有两个成员变量<code>first</code>和<code>last</code>，分别表示链表的首尾节点。</p>
<h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>

<h3 id="部分方法-3"><a href="#部分方法-3" class="headerlink" title="部分方法"></a>部分方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span>/<span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span>/<span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> LinkedList&lt;E&gt; <span class="title function_">reversed</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>LinkedList的索引并不能像数组那样支持下标随机访问，他会先判断索引是在链表的前半部分还是后半部分，从而选择从前还是从后遍历，所以会有listIterator。</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet&lt;E&gt;"></a>HashSet&lt;E&gt;</h2><p>不允许重复元素，不可索引，元素存取顺序不一致，非线程安全。</p>
<p><strong>java8之前</strong>底层数据结构：数组+链表（使用链表处理冲突），新元素存入数组时占据老元素位置，老元素以链表形式接在新元素后面（如果链表太长会导致查询性能降低，数组就会扩容）。</p>
<p><strong>java8之后</strong>底层数据结构：数组+链表+红黑树，当链表长度超过8且数组长度&gt;&#x3D;64时，自动将链表转成红黑树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<h3 id="基于HashMap"><a href="#基于HashMap" class="headerlink" title="基于HashMap"></a>基于HashMap</h3><p>HashSet 的内部采用了HashMap作为数据存储，HashSet其实就是在操作HashMap的key，value值默认为null或new Object()。</p>
<p>因为HashMap是无序的，因此HashSet也不能保证元素的顺序。</p>
<h3 id="HashSet去重复的机制"><a href="#HashSet去重复的机制" class="headerlink" title="HashSet去重复的机制"></a>HashSet去重复的机制</h3><p>两个不同对象的hashcode一般不同，相同对象的hashcode一定相同。如果有两个相同内容的不同对象则不能去重，需要重写对象的hashCode()方法和equals()方法。</p>
<h3 id="构造器-2"><a href="#构造器-2" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet()<span class="comment">//底层的hashmap实例有默认的容量16以及加载因子0.75</span></span><br><span class="line">HashSet(<span class="type">int</span> initialCapacity)</span><br><span class="line">HashSet(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c)</span><br><span class="line">HashSet(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor)</span><br></pre></td></tr></table></figure>

<h4 id="加载因子-LoadFactor"><a href="#加载因子-LoadFactor" class="headerlink" title="加载因子(LoadFactor)"></a>加载因子(LoadFactor)</h4><p>用于控制其内部使用的 HashMap 容量调整策略的重要参数。加载因子是一个介于0和1之间的浮点数，它代表了 HashMap在其容量被元素填充到一定程度时触发扩容(rehashing)操作的比例阈值。扩容时通常将容量扩大至原来的两倍。</p>
<p>较高的加载因子意味着允许更高的空间利用率，但在添加元素时更可能遭遇哈希冲突，可能导致查找、添加、删除等操作的性能下降；</p>
<p>较低的加载因子则倾向于牺牲一定的空间利用率，换取更低的哈希冲突率和更稳定的性能。</p>
<h3 id="部分方法-4"><a href="#部分方法-4" class="headerlink" title="部分方法"></a>部分方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; HashSet&lt;T&gt; <span class="title function_">newHashSet</span><span class="params">(<span class="type">int</span> numElements)</span><span class="comment">//创建一个新的空的hashset以适合numElements个元素，默认loadfactor是0.75</span></span><br><span class="line"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span>/<span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet&lt;E&gt;"></a>LinkedHashSet&lt;E&gt;</h3><p>继承自HashSet，依然是基于数组、链表、红黑树，但是每个元素多了一个双链表机制记录它前后元素的位置，元素存取顺序一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">SequencedSet</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<p>构造函数也和HashSet一样，其他方法也一样，只不过LinkedHashSet可以在两端操作(First&#x2F;Last)。</p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet&lt;E&gt;"></a>TreeSet&lt;E&gt;</h2><p>有序，元素按照自然排序（元素的自然顺序）或者指定的排序方式（通过比较器）排列。使用红黑树来存储元素，插入、删除和查找操作的时间复杂度均为 O(log n)。底层实际上是TreeMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<h3 id="构造器-3"><a href="#构造器-3" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeSet()<span class="comment">//默认创建一个初始容量为 16 的 TreeSet，加载因子为 0.75。</span></span><br><span class="line">TreeSet(SortedSet&lt;E&gt; s)<span class="comment">//创建一个有相同元素并且排序顺序与s一样的TreeSet</span></span><br><span class="line">TreeSet(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)<span class="comment">//指定排序方式</span></span><br><span class="line"><span class="comment">//new TreeSet&lt;&gt;(Comparator.reverseOrder())</span></span><br><span class="line">TreeSet(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c)<span class="comment">//从现有集合创建</span></span><br></pre></td></tr></table></figure>

<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>懒得写了，可以看实现的接口和继承的类里有哪些方法。</p>
<h3 id="对自定义类型对象如何进行排序"><a href="#对自定义类型对象如何进行排序" class="headerlink" title="对自定义类型对象如何进行排序"></a>对自定义类型对象如何进行排序</h3><ol>
<li><p>让自定义类实现Comparable接口，重写compareTo方法；</p>
</li>
<li><p>调用TreeSet有参构造器：TreeSet(Comparator&lt;? super E&gt; comparator)</p>
</li>
</ol>
<h4 id="Comparable与Comparator"><a href="#Comparable与Comparator" class="headerlink" title="Comparable与Comparator"></a>Comparable与Comparator</h4><ul>
<li>Comparable是Java中的一个接口，它包含一个方法compareTo(Object obj)，该方法用于比较当前对象与传入的对象obj的大小关系。该方法返回一个整数值，表示当前对象与传入对象的大小关系：如果当前对象小于传入对象，则返回负数；·······。实现Comparable接口的类可以作为集合的元素，使得集合内部的元素能够自动排序。</li>
<li>Comparator也是Java中的一个接口，它包含一个方法compare(Object obj1, Object obj2)，该方法用于比较两个对象obj1和obj2的大小关系：如果第一个对象小于第二个对象，则返回负数；·········。通过实现Comparator接口，<strong>可以根据不同的需求定义多种排序规则</strong>。实现Comparator接口的类可以作为参数传递给Collections.sort()等方法，从而实现定制排序。</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap&lt;K,V&gt;"></a>HashMap&lt;K,V&gt;</h2><p>底层数据结构是哈希表（数组+链表+红黑树），参考HashSet。</p>
<h3 id="继承关系-1"><a href="#继承关系-1" class="headerlink" title="继承关系"></a>继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<h3 id="重要变量"><a href="#重要变量" class="headerlink" title="重要变量"></a>重要变量</h3><p><code>DEFAULT_INITIAL_CAPACITY</code>数组的默认初始长度：<code>1 &lt;&lt; 4</code>即2^4&#x3D;16。</p>
<p><code>MAXIMUM_CAPACITY</code>数组的最大长度： <code>1 &lt;&lt; 30</code>。</p>
<p><code>DEFAULT_LOAD_FACTOR</code> 负载因子：默认值为<code>0.75</code>。</p>
<p><code>TREEIFY_THRESHOLD</code> 链表树化阈值： 默认值为 <code>8</code> 。表示在一个链表中节点的个数大于8时，才会将链表转换成为红黑树。</p>
<p><code>MIN_TREEIFY_CAPACITY = 64</code> 最小树化阈值，当数组长度超过改值时，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）。</p>
<p><code>UNTREEIFY_THRESHOLD</code> 红黑树链化阈值： 默认值为 <code>6</code> 。 表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</p>
<h3 id="构造器-4"><a href="#构造器-4" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K,? extends V&gt; m)</span></span><br><span class="line">其他方法：  <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; HashMap&lt;K,V&gt; <span class="title function_">newHashMap</span><span class="params">(<span class="type">int</span> numMappings)</span></span><br></pre></td></tr></table></figure>

<h3 id="JDK1-8中HashMap改了什么？"><a href="#JDK1-8中HashMap改了什么？" class="headerlink" title="JDK1.8中HashMap改了什么？"></a>JDK1.8中HashMap改了什么？</h3><ol>
<li><p>由 数组+链表 的结构改为 数组+链表+红⿊树 。</p>
</li>
<li><p>优化了⾼位运算的hash算法：h^(h&gt;&gt;&gt;16)</p>
</li>
<li><p>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。(解决了死循环的问题)</p>
</li>
<li><p>jdk1.7中加入新结点是头结点插入，jdk1.8之后采用尾结点插入，防止扩容的时候出现倒序的情况。</p>
</li>
</ol>
<h3 id="HashMap的线程不安全性"><a href="#HashMap的线程不安全性" class="headerlink" title="HashMap的线程不安全性"></a>HashMap的线程不安全性</h3><p>HashMap是非线程安全的，并没有<strong>提供操作的原子性</strong>以及<strong>可见性</strong>保证，存在线程安全问题。</p>
<p>比如A希望插入一个key-value对到HashMap中，当获取到对应的链表结点位置时，此时线程A的时间片用完了，而此时线程B被调度得以执行，可能线程B占用了A计算得到的位置，插入了数值。而线程A被切换回来的时候，不知道B已经插入了元素，仍然将元素插入此前计算好的位置，这样就会将B线程的插入记录覆盖掉了。</p>
<h4 id="HashTable如何保证线程安全？"><a href="#HashTable如何保证线程安全？" class="headerlink" title="HashTable如何保证线程安全？"></a>HashTable如何保证线程安全？</h4><p>使用了synchronized关键字。尽管HashTable保证了线程安全，但使用synchronized会有一个问题，就是锁的粒度太大，同时只能有一个线程进行操作，导致并发度低下，影响了操作的性能。</p>
<p>比如：HashTable的get和put方法，都使用了关键字synchronized修饰，这就意味着当一个线程调用put方法添加元素时，其它线程不能再同时执行put添加元素，也不能调用get方法获取数据。</p>
<h4 id="ConcurrentHashMap-如何保证线程安全？"><a href="#ConcurrentHashMap-如何保证线程安全？" class="headerlink" title="ConcurrentHashMap 如何保证线程安全？"></a>ConcurrentHashMap 如何保证线程安全？</h4><p>cas+synchronized+volatile。为了解决synchronized并发度低的问题，ConcurrentHashMap使用了cas+synchronized解决共享遍历操作原子性问题，使用volatile保障共享变量的内存可见性问题。</p>
<p>分段锁的思想，将 HashMap 进行切割，把 HashMap 中的哈希数组切分成小数组，每个小数组有 n 个 HashEntry 组成，其中小数组继承自ReentrantLock（可重入锁），这个小数组名叫Segment（JDK1.7），JDK1.8中取消了Segment 分段锁，采用 CAS + synchronized 来保证并发安全，ConcurrentHashMap 中 synchronized 只锁定当前链表或红黑二叉树的首节点，只要节点 hash不冲突，就不会产生并发。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap&lt;K,V&gt;"></a>LinkedHashMap&lt;K,V&gt;</h3><p>在HashMap的基础上添加了双链表机制，能够记录存储元素的顺序，保持迭代顺序。</p>
<h4 id="构造器-5"><a href="#构造器-5" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor,<span class="type">boolean</span> accessOrder)</span><span class="comment">//指定迭代顺序，访问顺序为真，插入顺序为假</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K,? extends V&gt; m)</span></span><br></pre></td></tr></table></figure>

<h4 id="部分方法-5"><a href="#部分方法-5" class="headerlink" title="部分方法"></a>部分方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;K, V&gt; LinkedHashMap&lt;K,V&gt; newLinkedHashMap(int numMappings)</span><br><span class="line">public V putFirst(K k,V v)/putLast(K k,V v)</span><br><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</span><br><span class="line">SequencedMap&lt;K,V&gt; reversed()</span><br><span class="line">SequencedSet&lt;Map.Entry&lt;K,V&gt;&gt; sequencedEntrySet()/SequencedSet&lt;K&gt; sequencedKeySet()/SequencedCollection&lt;V&gt; sequencedValues()</span><br></pre></td></tr></table></figure>

<h5 id="removeEldestEntry使用场景"><a href="#removeEldestEntry使用场景" class="headerlink" title="removeEldestEntry使用场景"></a>removeEldestEntry使用场景</h5><ol>
<li>当<code>LinkedHashMap</code>用作缓存时，可以设置一个最大容量限制。一旦缓存大小超过阈值，通过<code>removeEldestEntry</code>返回<code>true</code>来自动移除最久未使用的条目（LRU缓存策略）。</li>
<li>可以根据条目的添加时间或其他时间相关的属性判断是否已超出有效期限，从而删除过期条目。</li>
</ol>
<h4 id="实现LRU算法"><a href="#实现LRU算法" class="headerlink" title="实现LRU算法"></a>实现LRU算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="literal">true</span>); <span class="comment">// 设置初始容量、负载因子和accessOrder为true（按访问顺序排序）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES; <span class="comment">// 当缓存大小超过最大值时，删除最老的条目</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类可自行定义淘汰策略。</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap&lt;K,V&gt;"></a>TreeMap&lt;K,V&gt;</h2><p>底层通过红黑树进行自动排序。</p>
<h3 id="继承关系-2"><a href="#继承关系-2" class="headerlink" title="继承关系"></a>继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable,java.io.Serializable</span><br></pre></td></tr></table></figure>

<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="构造器-6"><a href="#构造器-6" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p><strong>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。</strong></p>
<p><strong>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于 ：内存的使用上，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象</strong>。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
<p><strong>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于 ：ArrayBlockingQueue采用读写同一个锁，所以没法实现读写并行</strong>。如果头部和尾部的锁分离，则可以实现读写并行，<code>LinkedBlockingQueue</code>就是。</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">  <span class="comment">/** 使用数组存储队列中的元素 */</span></span><br><span class="line">  <span class="keyword">final</span> Object[] items;</span><br><span class="line">  <span class="comment">/** 下一个出队元素在items数组中的索引 */</span></span><br><span class="line">  <span class="type">int</span> takeIndex;</span><br><span class="line">  <span class="comment">/** 下一个入队元素需要存放在items数组中的索引 */</span></span><br><span class="line">  <span class="type">int</span> putIndex;</span><br><span class="line">  <span class="comment">/** 队列中的元素数量 */</span></span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">  <span class="comment">/** 使用在许多教科书中能找到的经典的双Condition算法进行并发控制 */</span></span><br><span class="line">  <span class="comment">/** 使用独占锁ReetrantLock */</span></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">  <span class="comment">/** 等待出队的条件 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">  <span class="comment">/** 等待入队的条件 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部的数组其实是作为循环数组使用的，当数组中的元素满时，此时入队新元素需要进行等待。</p>
<h3 id="入队逻辑"><a href="#入队逻辑" class="headerlink" title="入队逻辑"></a>入队逻辑</h3><p>在当前位置插入元素，并修改索引值，并唤醒非空队列的线程，只有在获取锁的情况才会调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">  <span class="comment">// 将元素插入到putIndex处</span></span><br><span class="line">  items[putIndex] = x;</span><br><span class="line">  <span class="comment">// 修改putIndex索引</span></span><br><span class="line">  <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">  <span class="comment">// 如果修改后putIndex超出items数组最大索引，则指向索引0处</span></span><br><span class="line">    putIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 元素数量+1</span></span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">// 唤醒一个非空队列中的线程</span></span><br><span class="line">  notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队逻辑"><a href="#出队逻辑" class="headerlink" title="出队逻辑"></a>出队逻辑</h3><p>在当前位置获取一个元素，并修改索引值，并唤醒非满队列的线程，只有在获取锁的情况下才会调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">  <span class="comment">// 获取当前索引处元素</span></span><br><span class="line">  <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">  <span class="comment">// 将当前索引处置为空</span></span><br><span class="line">  items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 修改takeIndex索引</span></span><br><span class="line">  <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">  <span class="comment">// 如果修改后takeIndex超出items数组最大索引，则指向索引0处</span></span><br><span class="line">     takeIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 元素数量-1</span></span><br><span class="line">  count--;</span><br><span class="line">  <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">     itrs.elementDequeued();</span><br><span class="line">  <span class="comment">// 唤醒一个非满队列中的线程</span></span><br><span class="line">  notFull.signal();</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入队阻塞实现"><a href="#入队阻塞实现" class="headerlink" title="入队阻塞实现"></a>入队阻塞实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       checkNotNull(e);</span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">       <span class="comment">// 加锁</span></span><br><span class="line">       lock.lockInterruptibly();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">             <span class="comment">// 如果队列已满，线程阻塞，并添加到notFull条件队列中等待唤醒</span></span><br><span class="line">             notFull.await();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果队列未满，则调用enqueue方法进行入队操作</span></span><br><span class="line">           enqueue(e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用put方法进行阻塞式入队的基本流程"><a href="#调用put方法进行阻塞式入队的基本流程" class="headerlink" title="调用put方法进行阻塞式入队的基本流程"></a>调用put方法进行阻塞式入队的基本流程</h3><ol>
<li><p>首先，在进行入队操作前，使用<code>ReentrantLock</code>进行加锁操作，保证只有一个线程执行入队或出队操作；如果锁被其他线程占用，则等待；</p>
</li>
<li><p>如果加锁成功，则首先判断队列是否满；如果队列已满，则调用<code>notFull.await()</code>，将当前线程阻塞，并添加到<code>notFull条件队列</code>中等待唤醒；如果队列不满，则直接调用<code>enqueue</code>方法，进行元素插入；</p>
</li>
<li><p>当前线程添加到<code>notFull</code>条件队列中后，只有当其他线程有出队操作时，会调用<code>notFull.signal()</code>方法唤醒等待的线程；当前线程被唤醒后，还需要再次进行一次队列是否满的判断，如果此时队列不满才可以进行<code>enqueue</code>操作，否则仍然需要再次阻塞等待，这也就是为什么在判断队列是否满时使用<code>while</code>的原因，即避免当前线程被意外唤醒，或者唤醒后被其他线程抢先完成入队操作。</p>
</li>
<li><p>最后，当完成入队操作后，在finally代码块中进行锁释放<code>lock.unlock</code>，完成<code>put</code>入队操作</p>
</li>
</ol>
<h3 id="限时的入队"><a href="#限时的入队" class="headerlink" title="限时的入队"></a>限时的入队</h3><p>其实大致上是差不多的，只是多了时间的判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  checkNotNull(e);</span><br><span class="line">  <span class="comment">// 获取剩余等待时间</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  lock.lockInterruptibly();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断队列是否满</span></span><br><span class="line">    <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">// 入队队列满，等待时间为0，则入队失败，返回false</span></span><br><span class="line">       <span class="comment">// 如果队列满，等待时间大于0，且未到等待时间，则继续等待nanos</span></span><br><span class="line">       nanos = notFull.awaitNanos(nanos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列不满，进行入队操作</span></span><br><span class="line">    enqueue(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队阻塞实现-限时出队"><a href="#出队阻塞实现-限时出队" class="headerlink" title="出队阻塞实现 &amp; 限时出队"></a>出队阻塞实现 &amp; 限时出队</h3><p><code>take</code>、<code>poll</code>与<code>put</code>、<code>offer</code>逻辑类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 判断队列是否为空，如果为空则线程阻塞，添加到notEmpty条件队列等待</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 队列不为空，进行出队操作</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 指定队列元素数量capacity，并默认使用非公平锁进行并发控制 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;<span class="built_in">this</span>(capacity, <span class="literal">false</span>);&#125;</span><br><span class="line"><span class="comment">/** 指定使用公平锁/非公平锁进行并发控制*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;········&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>基于<strong>单向链表</strong>的阻塞队列，其内部维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时，才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。</p>
<p><strong>而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</strong></p>
<p>与<code>ArrayBlockingQueue</code>不同的是，在<code>LinkedBlockingQueue</code>中，入队和出队分别使用不同的锁。</p>
<h3 id="类的定义-1"><a href="#类的定义-1" class="headerlink" title="类的定义"></a>类的定义</h3><p>感觉思想和<code>ArrayBlockingQueue</code>差不多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 队列的容量，如果不传则默认Integer.MAX_VALUE */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 当前队列中元素数量 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">transient</span> Node&lt;E&gt; head;<span class="comment">////链表的头指针，head.item = null</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;<span class="comment">// 链表的尾指针 last.next = null</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 出队操作锁 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 出队条件：非空队列 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 入队锁 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 入队条件：非满队列 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造方法，队列容量为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定队列容量的构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">// 初始化链表的头尾节点</span></span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于集合构建队列，默认容量为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    putLock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">            enqueue(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e));</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put方法是如何实现的"><a href="#put方法是如何实现的" class="headerlink" title="put方法是如何实现的"></a>put方法是如何实现的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="comment">// 入队锁上锁</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果队列中元素的数量等于队列的容量，则阻塞当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行入队操作</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// 元素数量增1，返回操作前的数量</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// c+1为当前队列的元素，如果小于容量，则唤醒notFull的等待线程，触发继续入队操作</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="comment">// 释放锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c为入队前的元素数量，也就是入队前队列为空，则需要唤醒非空条件notEmpty的等待线程，触发出队操作</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 唤醒出队等待的线程</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    <span class="comment">// 当前头结点（头结点不存储数据，第一个元素为head.next）</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// 当前队列中第一个元素</span></span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    <span class="comment">// 原头结点设置无效</span></span><br><span class="line">    h.next = h; </span><br><span class="line">    <span class="comment">// 最新的头结点指向第一个元素first</span></span><br><span class="line">    head = first;</span><br><span class="line">    <span class="comment">// 获得第一个元素的值</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">    <span class="comment">// 将第一个元素值设置为null，第一个元素变成头结点</span></span><br><span class="line">    first.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 返回第一个元素值</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="Spliterator"><a href="#Spliterator" class="headerlink" title="Spliterator"></a>Spliterator</h2><p>高效地遍历和分割数据源，特别关注于支持并行流（parallel streams）的高效处理。</p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><blockquote>
<p><code>tryAdvance(Consumer&lt;? super T&gt; action)</code>：接受一个 <code>Consumer</code> 函数式接口作为参数，尝试对下一个元素执行给定的操作。如果还有元素可处理，则返回 <code>true</code>；否则返回 <code>false</code>，表示遍历结束。</p>
<p><code>forEachRemaining(Consumer&lt;? super T&gt; action)</code>：对余下的所有元素执行给定的 <code>Consumer</code> 操作，直到数据源耗尽。这是对 <code>tryAdvance()</code> 的批处理版本，通常更高效。</p>
<p><code>trySplit()</code>：尝试将当前 Spliterator 分割成两个独立的 Spliterator，返回其中一个。返回 <code>null</code> 表示无法再分割（例如数据源太小或已遍历完毕）。此方法是实现并行处理的关键。</p>
<p><code>estimateSize()</code>：返回一个估计的剩余元素数量，可以是准确值，也可以是近似值。这个信息有助于并行框架合理分配任务和优化性能。</p>
<p><code>characteristics()</code>：返回一个包含 <code>Characteristic</code> 枚举值的位掩码（bitmask），表示数据源的特性。这些特性包括但不限于：<code>ORDERED</code>（有序）、<code>DISTINCT</code>（元素唯一）、<code>SORTED</code>（已排序）、<code>SIZED</code>（已知大小）、<code>NONNULL</code>（不包含 <code>null</code> 元素）、<code>IMMUTABLE</code>（数据源不可变）等。</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote>
<ul>
<li><p><strong>并行流处理</strong>：在使用 Java 8 的并行流（如 <code>Stream.parallel()</code>）时，流会自动使用数据源提供的 Spliterator 进行高效并行处理。</p>
</li>
<li><p><strong>自定义数据源遍历</strong>：如果需要为自定义数据结构提供高效的遍历接口，可以实现 Spliterator 接口以支持并行流和其他高级遍历操作。</p>
</li>
<li><p><strong>高性能数据处理库</strong>：在构建高性能数据处理库或框架时，Spliterator 是实现高效数据遍历和并行化的基础工具。</p>
</li>
</ul>
</blockquote>
<h2 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h2><p>支持从尾到头遍历、访问当前元素的前后元素、在迭代过程中直接修改列表以及定位到特定索引位置。</p>
<h2 id="descendingIterator"><a href="#descendingIterator" class="headerlink" title="descendingIterator"></a>descendingIterator</h2><p>该迭代器能够按照集合元素的从大到小顺序遍历集合。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="魚 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="魚 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/ArrayBlockingQueue/" rel="tag"><i class="fa fa-tag"></i> ArrayBlockingQueue</a>
              <a href="/tags/ArrayList/" rel="tag"><i class="fa fa-tag"></i> ArrayList</a>
              <a href="/tags/HashSet/" rel="tag"><i class="fa fa-tag"></i> HashSet</a>
              <a href="/tags/LinkedList/" rel="tag"><i class="fa fa-tag"></i> LinkedList</a>
              <a href="/tags/Fail-Fast%E7%AD%96%E7%95%A5/" rel="tag"><i class="fa fa-tag"></i> Fail-Fast策略</a>
              <a href="/tags/Spliterator/" rel="tag"><i class="fa fa-tag"></i> Spliterator</a>
              <a href="/tags/TreeSet/" rel="tag"><i class="fa fa-tag"></i> TreeSet</a>
              <a href="/tags/LinkedBlockingQueue/" rel="tag"><i class="fa fa-tag"></i> LinkedBlockingQueue</a>
              <a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag"><i class="fa fa-tag"></i> 抽象类</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/66c016fb/" rel="prev" title="JVM">
                  <i class="fa fa-angle-left"></i> JVM
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/f8ab35c0/" rel="next" title="JavaScript进阶题">
                  JavaScript进阶题 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81OTcxMi8zNjE3NA=="></div>
</div>
  </main>
  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">魚</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">109k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:17</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/third-party/comments/livere.js"></script>


  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
  <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
  <script async src="/js/cursor/explosion.min.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
