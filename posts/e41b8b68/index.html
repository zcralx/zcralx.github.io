<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zcralx.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"show_result":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="[TOC] volatile内存语义volatile通过内存屏障(Memory Barrier)实现其在内存中的语义，即可见性和禁止重排优化。 可见性当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中；">
<meta property="og:type" content="article">
<meta property="og:title" content="volatile &amp; 内存屏障">
<meta property="og:url" content="https://zcralx.github.io/posts/e41b8b68/index.html">
<meta property="og:site_name" content="zcralx&#39;s blog">
<meta property="og:description" content="[TOC] volatile内存语义volatile通过内存屏障(Memory Barrier)实现其在内存中的语义，即可见性和禁止重排优化。 可见性当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中；">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zcralx.github.io/assets/img/07.jpg">
<meta property="og:image" content="https://zcralx.github.io/assets/img/06.jpg">
<meta property="og:image" content="https://zcralx.github.io/assets/img/cpu.png">
<meta property="article:published_time" content="2024-04-02T14:59:02.000Z">
<meta property="article:modified_time" content="2024-06-05T13:34:30.465Z">
<meta property="article:author" content="魚">
<meta property="article:tag" content="CAS">
<meta property="article:tag" content="JMM">
<meta property="article:tag" content="指令重排">
<meta property="article:tag" content="CPU多级缓存">
<meta property="article:tag" content="MESI协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zcralx.github.io/assets/img/07.jpg">


<link rel="canonical" href="https://zcralx.github.io/posts/e41b8b68/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zcralx.github.io/posts/e41b8b68/","path":"posts/e41b8b68/","title":"volatile & 内存屏障"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>volatile & 内存屏障 | zcralx's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">zcralx's blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">多喜乐，长安宁，愿你一切都好</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">29</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">12</span></a></li><li class="menu-item menu-item-象棋"><a href="/xiangqi/" rel="section"><i class="fa fa-chess-rook fa-fw"></i>象棋</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">
  
    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">volatile内存语义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">禁止重排优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%BF%9D%E5%AE%88%E7%AD%96%E7%95%A5%E7%9A%84JMM%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E6%8F%92%E5%85%A5%E7%AD%96%E7%95%A5"><span class="nav-number">1.3.</span> <span class="nav-text">基于保守策略的JMM内存屏障插入策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E5%B1%95"><span class="nav-number">1.4.</span> <span class="nav-text">拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">volatile的典型应用场景：单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSR-133%EF%BC%9A%E9%A2%9D%E5%A4%96%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E9%99%90%E5%88%B6"><span class="nav-number">1.4.2.</span> <span class="nav-text">JSR-133：额外的重排序限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="nav-number">1.4.3.</span> <span class="nav-text">指令重排</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.4.</span> <span class="nav-text">内存可见性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">如何解决内存可见性问题？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-Java-Memory-Modle%EF%BC%8C-JMM"><span class="nav-number">1.4.5.</span> <span class="nav-text">Java内存模型(Java Memory Modle， JMM)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E5%88%86%E5%88%AB%E6%94%BE%E4%BB%80%E4%B9%88%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">主内存和本地内存分别放什么变量？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86"><span class="nav-number">1.4.5.1.1.</span> <span class="nav-text">本地内存和堆</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9ACAS"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">解决原子性问题：CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CAS-Compare-and-Swap"><span class="nav-number">1.4.5.3.1.</span> <span class="nav-text">CAS : Compare and Swap</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#CAS%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%91%A2%EF%BC%9F"><span class="nav-number">1.4.5.3.1.1.</span> <span class="nav-text">CAS为什么能保证原子性呢？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CAS%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.5.3.2.</span> <span class="nav-text">CAS实现原子操作三大问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.5.3.2.1.</span> <span class="nav-text">ABA问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%A4%A7"><span class="nav-number">1.4.5.3.2.2.</span> <span class="nav-text">循环时间长开销大</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.5.3.2.3.</span> <span class="nav-text">只能保证一个共享变量的原子操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7-1"><span class="nav-number">1.4.5.4.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-number">1.4.5.5.</span> <span class="nav-text">有序性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#happens-before%E5%8E%9F%E5%88%99"><span class="nav-number">1.4.5.6.</span> <span class="nav-text">happens-before原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS%E6%8B%93%E5%B1%95"><span class="nav-number">1.4.5.7.</span> <span class="nav-text">CAS拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6%E5%88%A9%E7%94%A8CAS"><span class="nav-number">1.4.5.7.1.</span> <span class="nav-text">锁机制利用CAS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AFCAS"><span class="nav-number">1.4.5.7.2.</span> <span class="nav-text">循环CAS</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-Memory-Barrier"><span class="nav-number">2.</span> <span class="nav-text">内存屏障(Memory Barrier)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">为什么需要内存屏障？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MESI%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.1.</span> <span class="nav-text">MESI协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MESI%E5%8D%8F%E8%AE%AE%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">MESI协议存在的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%93%E5%B1%95-1"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="nav-number">2.1.1.2.1.</span> <span class="nav-text">为什么要有缓存一致性协议？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CPU%E7%9A%84%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">2.1.1.2.2.</span> <span class="nav-text">CPU的多级缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E9%94%81-%E7%BC%93%E5%AD%98%E9%94%81"><span class="nav-number">2.1.1.2.3.</span> <span class="nav-text">总线锁 &amp; 缓存锁</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E5%B1%82%E9%9D%A2%E7%9A%84%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-number">2.2.</span> <span class="nav-text">CPU层面的内存屏障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM%E5%B1%82%E9%9D%A2%E7%9A%84%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-number">2.3.</span> <span class="nav-text">JMM层面的内存屏障</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="魚"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">魚</p>
  <div class="site-description" itemprop="description">yuyu6661@foxmail.com</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zcralx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zcralx" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/zzzzzzzzzzz-90-37" title="zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;zzzzzzzzzzz-90-37" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>zhihu</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zcralx.github.io/posts/e41b8b68/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="魚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zcralx's blog">
      <meta itemprop="description" content="yuyu6661@foxmail.com">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="volatile & 内存屏障 | zcralx's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          volatile & 内存屏障
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-02 22:59:02" itemprop="dateCreated datePublished" datetime="2024-04-02T22:59:02+08:00">2024-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-05 21:34:30" itemprop="dateModified" datetime="2024-06-05T21:34:30+08:00">2024-06-05</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><img src="/assets/img/07.jpg" alt="壁纸" title="好看"></p>
<p>[TOC]</p>
<h1 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h1><p>volatile通过内存屏障(Memory Barrier)实现其在内存中的语义，即可见性和禁止重排优化。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中；</p>
<span id="more"></span>

<p>当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量。</p>
<p>所以，volatile变量的修改对其他线程立即可见。</p>
<h2 id="禁止重排优化"><a href="#禁止重排优化" class="headerlink" title="禁止重排优化"></a>禁止重排优化</h2><p>由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说<strong>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</strong>。Memory Barrier的另外一个作用是<strong>强制刷出各种CPU的缓存数据</strong>，因此任何CPU上的线程都能读取到这些数据的最新版本。</p>
<h2 id="基于保守策略的JMM内存屏障插入策略"><a href="#基于保守策略的JMM内存屏障插入策略" class="headerlink" title="基于保守策略的JMM内存屏障插入策略"></a>基于保守策略的JMM内存屏障插入策略</h2><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障。</p>
<p>具体策略如下：</p>
<blockquote>
<ul>
<li>在每个volatile写操作前插入一个StoreStore屏障；</li>
<li>在每个volatile写操作后插入一个StoreLoad屏障；</li>
<li>在每个volatile读操作后插入一个LoadLoad屏障；</li>
<li>在每个volatile读操作后插入一个LoadStore屏障。</li>
</ul>
</blockquote>
<p>并且遵循这样的规则：</p>
<blockquote>
<ol>
<li><p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</p>
</li>
<li><p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p>
</li>
<li><p>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p>
</li>
</ol>
</blockquote>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="volatile的典型应用场景：单例模式"><a href="#volatile的典型应用场景：单例模式" class="headerlink" title="volatile的典型应用场景：单例模式"></a>volatile的典型应用场景：单例模式</h3><p>单例模式的对象，可以被volatile修饰从而避免重排序。</p>
<p>下面给出懒汉式单例模式的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new对象的过程中，<strong>初始化实例对象</strong> 与 <strong>将singleton指针指向该对象</strong>可能被重排序。正因为这个重排序，另一个线程执行getInstance方法时，会返回一个未完成初始化的对象。而加<code>volatile</code>就能解决这个问题。volatile严格限制了对volatile域的写和对普通域的读写的重排序，因此volatile能保证这两个步骤不进行重排序。</p>
<h3 id="JSR-133：额外的重排序限制"><a href="#JSR-133：额外的重排序限制" class="headerlink" title="JSR-133：额外的重排序限制"></a>JSR-133：额外的重排序限制</h3><p>JSR-133 提出禁止 <strong>volatile 的读写</strong>与<strong>普通变量的读写</strong>重排序</p>
<p>这种额外的限制是为了提供一种<strong>比锁更轻量级的线程之间通信的机制</strong>。通过增强 volatile 的内存语义，使得<strong>对volatile的写-读 和 锁(synchronized)的释放-获取 具有相同的内存语义</strong>。</p>
<p>在功能上，锁比 volatile 更强大；在性能上，volatile 更有优势。原因是 volatile 仅仅保证对单个 volatile 变量的读&#x2F;写具有原子性，而锁可以保证整个<strong>临界区代码</strong>的执行具有原子性。</p>
<blockquote>
<p><strong>临界区</strong>：指的是某一块代码区域，它同一时刻只能由一个线程执行。</p>
</blockquote>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分以下3种：</p>
<blockquote>
<ul>
<li><p>编译器优化的重排：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</p>
</li>
<li><p>指令并行的重排：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序</p>
</li>
<li><p>内存系统的重排：由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p>
</li>
</ul>
</blockquote>
<p>其中编译器优化的重排属于<strong>编译器重排</strong>，指令并行的重排和内存系统的重排属于<strong>处理器重排</strong>，在多线程环境中，这些重排优化可能会导致程序出现内存可见性问题。</p>
<h3 id="内存可见性问题"><a href="#内存可见性问题" class="headerlink" title="内存可见性问题"></a>内存可见性问题</h3><p>当线程1和线程2在未同步的情况下对共享内存（主内存）中的变量进行访问时，比如两个线程的操作都是对变量a进行加1操作。假设线程1首先获取主内存中变量a的值，随后线程2又获取了主内存变量a的值，此时它们工作内存中a的值都是1，它们各自将a的值加1操作，然后assign至工作内存，工作内存中变量a的值都是2，然后两个线程又将值刷新到主内存，最后的结果是主内存中变量a的值是2。虽然整体对a的值加1操作做了两次操作，但<strong>由于线程间的操作是互相隔离的，默认情况下无法感知内存变量的值在随后的变化，也就无法访问内存中最新的变量值</strong>，这就是内存可见性的问题。</p>
<h4 id="如何解决内存可见性问题？"><a href="#如何解决内存可见性问题？" class="headerlink" title="如何解决内存可见性问题？"></a>如何解决内存可见性问题？</h4><ol>
<li>对进入临界区的线程做同步处理，同一时刻仅有一个线程能够访问临界区的资源；</li>
<li>使用 volatile 关键字保证内存可见性，它能保证访问临界区资源的所有线程总能看到共享资源的最新值；</li>
<li>CAS无锁化。</li>
</ol>
<h3 id="Java内存模型-Java-Memory-Modle，-JMM"><a href="#Java内存模型-Java-Memory-Modle，-JMM" class="headerlink" title="Java内存模型(Java Memory Modle， JMM)"></a>Java内存模型(Java Memory Modle， JMM)</h3><p>这是一个抽象的概念，用来描述或者规范访问内存变量的方式。 Java内存规定了所有变量都存储在主内存（Main Memory）中，各个线程又有自己的本地内存（工作内存），本地内存保存着主内存中部分变量。</p>
<p>参考流程如下：</p>
<p><a href=""><img src="/assets/img/06.jpg" alt="内存模型" title="访问内存变量的流程"></a></p>
<ol>
<li><strong>lock加锁：</strong>为了保证访问主内存变量的线程安全性，在访问前一般会加锁处理；</li>
<li><strong>read读：</strong>从主内存中读取一个变量到工作内存；</li>
<li><strong>load加载：</strong>把read读到的变量加载到工作内存的变量副本中；</li>
<li><strong>use使用：</strong>此时线程可以使用其工作内存中的变量了；</li>
<li><strong>assign赋值：</strong>将处理后的变量赋值给工作内存中的变量；</li>
<li><strong>store存储：</strong>将工作内存中的变量存储到主内存中，以新建new 一个新变量的方式存储；</li>
<li><strong>write写：</strong>将store存在的新变量的引用赋值给被处理的变量；</li>
<li><strong>unload解锁：</strong>所有的工作做完，最后解锁释放资源。</li>
</ol>
<h4 id="主内存和本地内存分别放什么变量？"><a href="#主内存和本地内存分别放什么变量？" class="headerlink" title="主内存和本地内存分别放什么变量？"></a>主内存和本地内存分别放什么变量？</h4><p>根据虚拟机规范，对于一个实例对象中的<strong>成员方法</strong>而言，如果方法中包含本地变量是基本数据类型，将直接存储在工作内存的帧栈结构中；倘若本地变量是引用类型，那么该变量的引用会存储在工作内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。</p>
<p>但对于实例对象的<strong>成员变量</strong>，不管它是基本数据类型或者包装类型还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存。</p>
<h5 id="本地内存和堆"><a href="#本地内存和堆" class="headerlink" title="本地内存和堆"></a>本地内存和堆</h5><p>从上面可以看到：Java线程持有堆对象的引用，那会直接操作堆吗？</p>
<p>堆是 Java 内存结构的一部分，属于共享区域，如果线程直接操作堆，就与JMM冲突了。</p>
<p>虽然Java采用直接指针的方式访问对象，但实际上<strong>并不会直接操作堆对象</strong>，毕竟堆也属于内存，也就是JMM的主存区域，Java线程的做法是：<strong>将堆对象拷贝到线程自己的本地内存来进行操作</strong>（如果对象很大只会拷贝一部分）。本地内存确实是线程私有的，但请不要和「JVM运行时数据结构的那些线程私有的栈等」划上等号，本地内存是抽象的。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>一个或多个操作要么全执行成功要么全执行失败（全不执行）。Java内存模型只保证单一的操作具有原子性，比如<code>int a = 1</code>; 是一个原子的操作，所以具有原子性；但是<code>a++</code>在底层会分为三个操作：</p>
<ol>
<li><p>读取a的值给临时变量；</p>
</li>
<li><p>临时变量a的值加1操作；</p>
</li>
<li><p>将加操作后的值赋值给a。</p>
</li>
</ol>
<p>每个操作都是原子的，但Java内存模型在多线程下并不能保证多操作具有整体原子性。需要对响应的代码块做同步处理，比如使用 <strong>有锁的synchronized</strong> 或 <strong>无锁的CAS</strong>。</p>
<h4 id="解决原子性问题：CAS"><a href="#解决原子性问题：CAS" class="headerlink" title="解决原子性问题：CAS"></a>解决原子性问题：CAS</h4><p>Java解决原子性问题，最核心的机制是：CAS。CAS是一条CPU并发原语</p>
<h5 id="CAS-Compare-and-Swap"><a href="#CAS-Compare-and-Swap" class="headerlink" title="CAS : Compare and Swap"></a>CAS : Compare and Swap</h5><p>用于<strong>在硬件层面上提供原子性操作</strong>。在 Intel 处理器中，CAS通过指令<code>cmpxchg</code>实现。 比较是否和给定的数值一致，如果一致则修改，不一致则不修改。</p>
<p>CAS有如下三个变量：</p>
<ul>
<li>V：要更新的变量(var)</li>
<li>E：预期值(expected)， 就是旧值</li>
<li>N：新值(new)</li>
</ul>
<p>CAS操作：判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。</p>
<p>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>
<h6 id="CAS为什么能保证原子性呢？"><a href="#CAS为什么能保证原子性呢？" class="headerlink" title="CAS为什么能保证原子性呢？"></a>CAS为什么能保证原子性呢？</h6><p>比如说，会不会出现两个线程同时做CAS并发现<code>Var = Eepected</code>，然后同时修改呢？</p>
<p><strong>CAS是一条CPU的原子指令，是CPU层面保证的。</strong>Linux的X86下主要是通过<code>cmpxchgl</code>这个指令，但在多处理器情况下必须使用<code>lock</code>指令加锁来完成。不同的操作系统和处理器的实现各不相同。</p>
<h5 id="CAS实现原子操作三大问题"><a href="#CAS实现原子操作三大问题" class="headerlink" title="CAS实现原子操作三大问题"></a>CAS实现原子操作三大问题</h5><h6 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h6><p>A-&gt;B-&gt;A，CAS检查不出变化。</p>
<p>ABA问题的本质是：一次CAS的旧值与另一次CAS的新值完全一样。</p>
<p>因此我们可以：加上<strong>版本号或者时间戳</strong>。</p>
<p>JUC解决ABA问题：AtomicStampedReference：这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查标志stamped是否为预期标志，如果全部一致，则继续；加上版本号。</p>
<h6 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h6><p>如果自旋CAS长时间不成功，会占用大量的CPU资源。</p>
<p>如果JVM能支持处理器提供的<strong>pause指令</strong>，那么效率会有一定的提升。</p>
<p>pause指令的两个作用：</p>
<ol>
<li><p>它可以延迟流水线执行指令，使CPU不会消耗过多的执行资源</p>
</li>
<li><p>它可以避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空</p>
</li>
</ol>
<h6 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h6><p>如果要保证多个变量的操作的原子性，CAS就无能为力了。我们有两种解决方案：</p>
<ul>
<li>锁机制，保证临界区的代码只有一个线程可以执行；</li>
<li>把多个共享变量合并成一个共享变量来操作；</li>
<li>使用JDK 1.5提供的<code>AtomicReference</code>类保证对象的原子性，把多个变量放在一个对象里。</li>
</ul>
<h4 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h4><p>这里指的是内存可见性。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>线程内的所有操作都是有序的，既程序执行的顺序按照代码的先后顺序执行。</p>
<h4 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h4><p>在JMM中，提供happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据。</p>
<p>具体内容如下：</p>
<blockquote>
<p><strong>程序顺序原则</strong>：即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</p>
<p><strong>锁规则</strong>： 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</p>
<p><strong>volatile规则</strong>： volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</p>
<p><strong>线程启动规则</strong>： 线程的start方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</p>
<p><strong>传递性</strong>： A先于B ，B先于C ，那么A必然先于C</p>
<p><strong>线程终止规则</strong>： 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</p>
<p><strong>线程中断规则</strong> ：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</p>
<p><strong>对象终结规则</strong> ：对象的构造函数执行，结束先于finalize()方法</p>
</blockquote>
<h4 id="CAS拓展"><a href="#CAS拓展" class="headerlink" title="CAS拓展"></a>CAS拓展</h4><h5 id="锁机制利用CAS"><a href="#锁机制利用CAS" class="headerlink" title="锁机制利用CAS"></a>锁机制利用CAS</h5><p>除了偏向锁，JVM实现锁的方式都用了循环CAS，也就是几乎所有的Java的锁实现都依赖于CAS操作。</p>
<p>实现逻辑：</p>
<blockquote>
<p>定义一个锁的状态；<br>状态状态值&#x3D;0 则表示没有线程获取到该锁；<br>状态状态值&#x3D;1 则表示有线程已经持有该锁；</p>
</blockquote>
<p>CAS 获取锁：将该锁的状态从 0 改为 1。</p>
<p>能够修改成功 cas 成功则表示获取锁成功<br>如果获取锁失败——修改失败，则不会阻塞而是通过循环（自旋来控制重试）</p>
<p>CAS 释放锁：将该锁的状态从 1 改为 0 。</p>
<p>如果能够改成功 cas 成功则表示释放锁成功</p>
<h5 id="循环CAS"><a href="#循环CAS" class="headerlink" title="循环CAS"></a>循环CAS</h5><p>循环CAS 就是在一个循环里不断的做cas 操作，直到成功为止。 </p>
<h1 id="内存屏障-Memory-Barrier"><a href="#内存屏障-Memory-Barrier" class="headerlink" title="内存屏障(Memory Barrier)"></a>内存屏障(Memory Barrier)</h1><p>内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性。</p>
<h2 id="为什么需要内存屏障？"><a href="#为什么需要内存屏障？" class="headerlink" title="为什么需要内存屏障？"></a>为什么需要内存屏障？</h2><p>这就需要了解一下MESI协议。</p>
<h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>一种比较常用的缓存一致性协议（不同处理器使用的缓存一致性协议可能不一样），M、E、S、I分别代表缓存行的四种状态。</p>
<blockquote>
<p><strong>M(Modify)</strong> 表示共享数据只缓存在当前 CPU 缓存中，并且是被修改状态（也就是缓存的数据和主内存中的数据不一致）</p>
<p><strong>E(Exclusive)</strong> 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改</p>
<p><strong>S(Shared)</strong> 表示数据可能被多个 CPU 缓存，并且各个缓存中的数据和主内存数据一致</p>
<p><strong>I(Invalid)</strong> 表示缓存已经失效</p>
</blockquote>
<p>在 MESI 协议中，每个缓存的缓存控制器不仅知道自己的读写操作，而且也监听(snoop)其它CPU的读写操作。</p>
<p>对于 MESI 协议，从 CPU 读写角度来说会遵循以下原则：<br>CPU读请求：缓存处于 M、E、S 状态都可以被读取，I 状态CPU 只能从主存中读取数据<br>CPU写请求：缓存处于 M、E 状态才可以被写。对于S状态的写，需要将其他CPU中缓存行置为无效才行。</p>
<h4 id="MESI协议存在的问题"><a href="#MESI协议存在的问题" class="headerlink" title="MESI协议存在的问题"></a>MESI协议存在的问题</h4><p>由于各个CPU缓存行的状态是通过消息传递来进行的，如果CPU0要对一个在缓存中共享的变量进行写入，首先需要发送一个失效的消息给到其他缓存了该数据的 CPU。并且要等到他们的确认回执。CPU0在这段时间内都会处于阻塞状态。</p>
<p>为了避免阻塞带来的资源浪费，CPU中引入了<strong>store bufferes</strong>：CPU0 只需要在写入共享数据时，直接把数据写入到 store bufferes中，同时发送invalidate消息，然后继续去处理其他指令（异步）， 当收到其他所有 CPU 发送了invalidate acknowledge消息时，再将store bufferes中的数据数据存储至缓存行中，最后再从缓存行同步到主内存。</p>
<p>但是这种优化就会带来了可见性问题，也可以认为是CPU的乱序执行引起的或者说是指令重排序。</p>
<p>所以CPU层面就提供了内存屏障，使得软件层面可以决定在适当的地方来插入内存屏障来禁止指令重排序。</p>
<h4 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h4><h5 id="为什么要有缓存一致性协议？"><a href="#为什么要有缓存一致性协议？" class="headerlink" title="为什么要有缓存一致性协议？"></a>为什么要有缓存一致性协议？</h5><p>这就需要先了解CPU的缓存机制了</p>
<h5 id="CPU的多级缓存"><a href="#CPU的多级缓存" class="headerlink" title="CPU的多级缓存"></a>CPU的多级缓存</h5><p>线程是CPU调度的最小单元，线程设计的目的最终仍然是更充分的利用计算机处理的效能，但是绝大部分的运算任务不能只依靠处理器计算就能完成，处理器还需要与内存交互，比如读取运算数据、存储运算结果，这个 I&#x2F;O 操作是很难消除的。</p>
<p>而由于计算机的存储设备与处理器的运算速度差距非常大，所以现代计算机系统都会<strong>增加一层</strong>读写速度尽可能接近处理器运算速度的<strong>高速缓存</strong>来作为内存和处理器之间的缓冲：<strong>将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步到内存之中</strong>。</p>
<p><a href=""><img src="/assets/img/cpu.png" alt="CPU多级缓存" title="多级缓存"></a></p>
<p>从上图可以看出，CPU有L1、L2、L3三级缓存，L1和L2缓存为各个CPU独有，而有了高速缓存的存在以后，每个 CPU 的处理过程是，先将计算需要用到的数据缓存在 CPU 高速缓存中，在 CPU进行计算时，直接从高速缓存中读取数据并且在计算完成之后写入到缓存中。在整个运算过程完成后，再把缓存中的数据同步到主内存。</p>
<p>由于在多 CPU 中，每个线程可能会运行在不同的 CPU 内，并且每个线程拥有自己的高速缓存。同一份数据可能会被缓存到多个 CPU 中，如果在不同 CPU 中运行的不同线程看到同一份内存的缓存值不一样就会存在缓存不一致的问题，那么怎么<strong>解决缓存一致性问题</strong>呢？</p>
<p>CPU层面提供了两种解决方法：<strong>总线锁</strong>和<strong>缓存锁</strong>。</p>
<h5 id="总线锁-缓存锁"><a href="#总线锁-缓存锁" class="headerlink" title="总线锁 &amp; 缓存锁"></a>总线锁 &amp; 缓存锁</h5><p>总线锁：在多CPU下，当其中一个处理器要对共享内存进行操作的时候，在总线上发出一个 LOCK#信号，这个信号使得其他处理器无法通过总线来访问到共享内存中的数据。总线锁定把 CPU 和内存之间的通信锁住了(CPU和内存之间通过总线进行通讯)，这使得锁定期间，其他处理器不能操作其他内存地址的数据。</p>
<p>然而这种做法的代价显然太大，那么如何优化呢？优化的办法就是<strong>降低锁的粒度</strong>，所以CPU就<strong>引入了缓存锁</strong>。</p>
<p>缓存锁：缓存锁的核心机制是基于缓存一致性协议来实现的，一个处理器的缓存回写到内存会导致其他处理器的缓存无效，IA-32处理器和Intel 64处理器使用MESI实现缓存一致性协议。</p>
<h2 id="CPU层面的内存屏障"><a href="#CPU层面的内存屏障" class="headerlink" title="CPU层面的内存屏障"></a>CPU层面的内存屏障</h2><p>通过防止 CPU 对内存的乱序访问来保证共享数据在多线程并行执行下的可见性</p>
<blockquote>
<p><strong>写屏障(Store Memory Barrier)：</strong>告诉处理器在写屏障之前的所有已经存储在存储缓存(store bufferes)中的数据同步到主内存，简单来说就是使得写屏障之前的指令的结果对写屏障之后的读或者写是可见的。</p>
<p><strong>读屏障(Load Memory Barrier)：</strong>处理器在读屏障之后的读操作，都在读屏障之后执行。配合写屏障，使得写屏障之前的内存更新对于读屏障之后的读操作是可见的。</p>
<p><strong>全屏障(Full Memory Barrier)：</strong>确保屏障前的内存读写操作的结果提交到内存之后，再执行屏障后的读写操作。</p>
</blockquote>
<h2 id="JMM层面的内存屏障"><a href="#JMM层面的内存屏障" class="headerlink" title="JMM层面的内存屏障"></a>JMM层面的内存屏障</h2><p>在JMM中把内存屏障分为4类，LoadLoad、StoreStore、LoadStore、StoreLoad。</p>
<p>StoreLoad Barriers是一个全能型的屏障，它同时具有其他3个屏障的效果。现代的多数处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="魚 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="魚 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/CAS/" rel="tag"><i class="fa fa-tag"></i> CAS</a>
              <a href="/tags/JMM/" rel="tag"><i class="fa fa-tag"></i> JMM</a>
              <a href="/tags/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/" rel="tag"><i class="fa fa-tag"></i> 指令重排</a>
              <a href="/tags/CPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/" rel="tag"><i class="fa fa-tag"></i> CPU多级缓存</a>
              <a href="/tags/MESI%E5%8D%8F%E8%AE%AE/" rel="tag"><i class="fa fa-tag"></i> MESI协议</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/862c3f1c/" rel="prev" title="Stream流式编程">
                  <i class="fa fa-angle-left"></i> Stream流式编程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/66c016fb/" rel="next" title="JVM">
                  JVM <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81OTcxMi8zNjE3NA=="></div>
</div>
  </main>
  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">魚</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">109k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:17</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/third-party/comments/livere.js"></script>


  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
  <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
  <script async src="/js/cursor/explosion.min.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
