<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker</title>
    <url>/posts/f5f9fa9b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker入门"><a href="#Docker入门" class="headerlink" title="Docker入门"></a>Docker入门</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>brew install --cask --appdir=/Applications docker</code></p>
<p><code>docker version</code>查看详细信息</p>
<p>设置镜像源</p>
<blockquote>
<p>“registry-mirrors”: [<br>    “<a href="https://docker.m.daocloud.io/">https://docker.m.daocloud.io</a>“,<br>    “<a href="https://docker.nju.edu.cn/">https://docker.nju.edu.cn</a>“,<br>    “<a href="https://dockerproxy.com/">https://dockerproxy.com</a>“<br>  ]</p>
</blockquote>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p><code>docker pull xxxx</code>默认latest版本，镜像的仓库名称中还应该添加仓库地址（即registry，注册服务器）作为前缀，只是我们默认使用的是Docker Hub服务，该前缀可以忽略。</p>
<p>从非官方源拉取：docker pull hub.c.163.com&#x2F;public&#x2F;ubuntu:14.04</p>
<p>查看镜像信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% docker images</span><br><span class="line">REPOSITORY  TAG    IMAGE ID    CREATED    SIZE</span><br><span class="line">nginx    latest  786a14303c96  2 days ago  193MB</span><br><span class="line">python    3.8    99e30d37509d  5 weeks ago  1GB</span><br></pre></td></tr></table></figure>

<p>为本地镜像任意添加新的标签<code>docker tag python:3.8 mypython:3.8</code></p>
<p>执行之后再列出镜像信息会多出一个镜像，但是它和原镜像实际指向同一个镜像文件，只是别名不同而已。</p>
<p><code>docker inspect xxxx</code>查看xxxx镜像详细信息</p>
<p><code>docker history xxxx</code> 查看镜像历史</p>
<p>docker search命令可以搜索远端仓库中共享的镜像</p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p><code>docker rmi mypython:3.8</code></p>
<p>当同一个镜像拥有多个标签的时候，docker rmi命令只是删除该镜像多个标签中的指定标签而已，并不影响镜像文件</p>
<p>但当镜像只剩下一个标签的时候就要小心了，此时再使用docker rmi命令会彻底删除镜像。</p>
<p><code>docker rmi +镜像id</code> 会先尝试删除所有指向该镜像的标签，然后删除该镜像文件本身。</p>
<p>当有该镜像创建的容器存在时，镜像文件默认是无法被删除的</p>
<h2 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h2><h3 id="创建和运行容器"><a href="#创建和运行容器" class="headerlink" title="创建和运行容器"></a>创建和运行容器</h3><p>使用docker create命令新建一个容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% docker create -it python:3.8</span><br><span class="line">845c0fae8bef1a9f65c77af13a795836ce82186a0d03848681133aac53b359e3</span><br></pre></td></tr></table></figure>

<p>docker ps -a命令可以看到本机上存在的所有容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE        COMMAND     CREATED              STATUS    PORTS     NAMES</span><br><span class="line">845c0fae8bef   python:3.8   &quot;python3&quot;   About a minute ago   Created             festive_easley</span><br></pre></td></tr></table></figure>

<p>使用docker create命令新建的容器处于停止状态，使用docker start命令来启动它，使用docker ps查看运行中的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% docker start 845c0fae8bef</span><br><span class="line">845c0fae8bef</span><br><span class="line">% docker ps</span><br><span class="line">CONTAINER ID   IMAGE        COMMAND     CREATED         STATUS          PORTS     NAMES</span><br><span class="line">845c0fae8bef   python:3.8   &quot;python3&quot;   6 minutes ago   Up 14 seconds             festive_easley</span><br></pre></td></tr></table></figure>

<p>当然也可以直接新建并启动容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% docker run -it python:3.8 /bin/bash 启动一个bash终端，允许用户进行交互</span><br><span class="line">root@ae2d080e12d6:/# </span><br></pre></td></tr></table></figure>

<p>-t选项让Docker分配一个伪终端并绑定到容器的标准输入上，-i则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/# ls</span><br><span class="line">bin  boot  dev	etc  home  lib	media  mnt  opt  proc  root  run  sbin	srv  sys  tmp  usr  var</span><br><span class="line">/# ps 查看进程</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 pts/0    00:00:00 bash</span><br><span class="line">    8 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>当利用docker run来创建并启动容器时，Docker在后台运行的标准操作包括：</p>
<blockquote>
<p>检查本地是否存在指定的镜像，不存在就从公有仓库下载；</p>
<p>利用镜像创建一个容器，并启动该容器；</p>
<p>分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层；</p>
<p>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中；</p>
<p>从网桥的地址池配置一个IP地址给容器；</p>
<p>执行用户指定的应用程序；</p>
<p>执行完毕后容器被自动终止。</p>
</blockquote>
<p>输入exit命令来退出容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<h4 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h4><p>添加-d参数让Docker容器在后台以守护态（Daemonized）形式运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d ubuntu  /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">...</span><br><span class="line">$ docker logs ce5获取输出信息，ce5是id的简写</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这个时候如果需要进入容器进行操作，有多种方法，包括使用官方的attach或exec命令，以及第三方的nsenter工具等。</p>
<h5 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h5><p><code>docker attach [--detach-keys[=[]]] [--no-stdin] [--sig-proxy[=true]] CONTAINER</code></p>
<blockquote>
<p>支持三个主要选项：<br>–detach-keys[&#x3D;[]]：指定退出attach模式的快捷键序列，默认是CTRL-p CTRL-q；<br>–no-stdin&#x3D;true|false：是否关闭标准输入，默认是保持打开；<br>–sig-proxy&#x3D;true|false：是否代理收到的系统信号给应用进程，默认为true。</p>
</blockquote>
<p>但是当多个窗口同时用attach命令连到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时，其他窗口也无法执行操作了。</p>
<h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h5><p><code>docker exec [-d|--detach] [--detach-keys[=[]]] [-i|--interactive] [--privileged] [-t|--tty] [-u|--user[=USER]] CONTAINER COMMAND [ARG...]</code></p>
<blockquote>
<p>-i，–interactive&#x3D;true|false：打开标准输入接受用户输入命令，默认为false；<br>–privileged&#x3D;true|false：是否给执行命令以高权限，默认为false；<br>-t，–tty&#x3D;true|false：分配伪终端，默认为false；<br>-u，–user&#x3D;””：执行命令的用户名或ID。</p>
</blockquote>
<p>例如进入到刚创建的容器中，并启动一个bash：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker exec -it 243c32535da7 /bin/bash</span><br><span class="line">root@243c32535da7:/#</span><br></pre></td></tr></table></figure>

<p>exec是最推荐的方式。</p>
<h5 id="nsenter工具"><a href="#nsenter工具" class="headerlink" title="nsenter工具"></a>nsenter工具</h5><p>懒得看</p>
<h3 id="终止与启动容器"><a href="#终止与启动容器" class="headerlink" title="终止与启动容器"></a>终止与启动容器</h3><p><code>docker stop[-t|--time[=10]][CONTAINER...]</code></p>
<p>首先向容器发送SIGTERM信号，等待一段超时时间（默认为10秒）后，再发送SIGKILL信号来终止容器。</p>
<p>docker kill命令会直接发送SIGKILL信号来强行终止容器。</p>
<p>此外，当Docker容器中指定的应用终结时，容器也会自动终止。例如对于上面只启动了一个终端的容器，用户通过exit命令或Ctrl+d来退出终端时，所创建的容器立刻终止，处于stopped状态。</p>
<p>查看所有容器的id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> % docker ps -qa</span><br><span class="line">ae2d080e12d6</span><br><span class="line">845c0fae8bef</span><br></pre></td></tr></table></figure>

<p>处于终止状态的容器，可以通过docker start命令来重新启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% docker start ae2</span><br><span class="line">ae2</span><br></pre></td></tr></table></figure>

<p>docker restart命令会将一个运行态的容器先终止，然后再重新启动它。</p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>直接打开docker desktop删除就行。</p>
<p><code>docker rm[-f|--force][-l|--link][-v|--volumes]CONTAINER[CONTAINER...]</code></p>
<blockquote>
<p>-f，–force&#x3D;false：是否强行终止并删除一个运行中的容器；<br>-l，–link&#x3D;false：删除容器的连接，但保留容器；<br>-v，–volumes&#x3D;false：删除容器挂载的数据卷。</p>
</blockquote>
<h3 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h3><p>导出一个已经创建的容器到一个文件<code>docker export[-o|--output[=&quot;&quot;]]CONTAINER</code>，-o选项来指定导出的tar文件名，也可以直接通过重定向来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker export -o test_for_run.tar ce5</span><br></pre></td></tr></table></figure>

<p>导出的文件又可以使用docker import命令导入变成镜像<code>docker import [-c|--change[=[]]] [-m|--message[=MESSAGE]] file|URL|-[REPOSITORY [:TAG]]</code></p>
<p>可以通过-c，–change&#x3D;[]选项在导入的同时执行对容器进行修改的Dockerfile指令。</p>
<p>既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以使用docker import命令来导入一个容器快照到本地镜像库。</p>
<p>这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记</p>
<p>录，体积也更大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
]]></content>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/posts/66c016fb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://baike.baidu.com/item/%E7%81%AB%E7%81%B5%E5%84%BF/16416703"><img src="/assets/img/02.png" alt="桌面图片" title="火灵儿"></a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2141280035&auto=1&height=66"></iframe>

<p>[TOC]</p>
<h1 id="前言：了解一下JVM-java虚拟机"><a href="#前言：了解一下JVM-java虚拟机" class="headerlink" title="前言：了解一下JVM(java虚拟机)"></a>前言：了解一下JVM(java虚拟机)</h1><p>当前市面上使用范围最广的，是Sun&#x2F;OracleJDK或者OpenJDK中默认的 HotSpot 虚拟机。</p>
<p>市面上还存在很多非常优秀的Java虚拟机，它们都遵循Java虚拟机规范，但具体的实现上各有特点，在某一个领域拥有突出的性能优势是它们最重要的卖点。例如IBM的J9，Azul Systems 的 Azul VM 等等。</p>
<span id="more"></span>



<h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><h3 id="何时开始？"><a href="#何时开始？" class="headerlink" title="何时开始？"></a>何时开始？</h3><p>JVM在Java程序开始运行的时候，它才运行，程序结束的时它就停止。一个Java程序会开启一个JVM进程，如果一台机器上运行3个Java程序，那么就会有3个运行中的JVM进程。</p>
<p>JVM中的线程分为两种：守护线程和普通线程<br><strong>守护线程</strong>是JVM自己使用的线程，比如垃圾回收（GC）就是一个守护线程。<br><strong>普通线程</strong>一般是Java程序的线程，只要JVM中有普通线程在执行，那么JVM就不会停止。</p>
<h3 id="何时结束？"><a href="#何时结束？" class="headerlink" title="何时结束？"></a>何时结束？</h3><p>在如下几种情况下，Java虚拟机将结束生命周期：</p>
<ol>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而终止进程</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ol>
<h2 id="JVM执行引擎"><a href="#JVM执行引擎" class="headerlink" title="JVM执行引擎"></a>JVM执行引擎</h2><p>Java虚拟机相当于一台虚拟的物理机，这两种机器都有代码执行能力，区别主要是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而JVM的执行引擎是自己实现的，因此程序员可以自行制定指令集和执行引擎的结构体系。</p>
<p>执行引擎的主要职责，就是把这些自行制定的指令集翻译成硬件所支持的指令集格式，然后执行。</p>
<p>在JVM规范中制定了虚拟机字节码执行引擎的概念模型，这个模型称之为JVM执行引擎的统一外观，各个Java 虚拟机的发行厂商都需要按照这个规范来实现。</p>
<p>在不同的虚拟机实现中，可能会有两种的执行方式：解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码）。虚拟机可以按自身的需求，采用一种或同时采用多种组合的方式来实现执行引擎。但无论内部怎么实现，都要遵循<strong>输入的是字节码文件、处理过程是等效字节码解析过程、输出的是执行结果</strong>这个JVM规范要求。</p>
<h2 id="javap反编译"><a href="#javap反编译" class="headerlink" title="javap反编译"></a>javap反编译</h2><p>javap是java内置的反编译命令。</p>
<p><code>javap -v -p Main.class</code>：-v 显示附加信息，如局部变量表、操作码等；-p 显示所有类和成员，包括私有的。</p>
<p><code>javap -help</code>：查看javap的基本用法。</p>
<p><code>Classfile .....</code>第一行表示字节码文件的位置。</p>
<p><code>Last modified....</code>这一行表示字节码文件的修改信息。</p>
<p><code>SHA-256 checksum.....</code>字节码文件的 SHA-256 值，用于校验文件的完整性。</p>
<p><code>Compiled from.....</code>说明该字节码文件编译自xxxx.java 源文件。</p>
<p><code>public class.....</code>类访问修饰符和类型，表明这是一个公开的类，名为 xxxx。</p>
<p><code>minor version</code>次版本号， <code>major version</code>主版本号。</p>
<p><code> flags:....</code>类访问标记，一共有 8 种：</p>
<p><img src="/assets/img/bytecode.png" title="类访问标记"></p>
<p><code>this_class: #3</code>当前类的索引，指向常量池中下标为 3 的常量，类似的，<code>super_class: #4</code>父类的索引。</p>
<p><code>interfaces: 0, fields: 1, methods: 2, attributes: 1</code>当前类有 0 个接口，1 个字段（age），2 个方法（write方法和缺省的默认构造方法）。</p>
<p>后面还有一大堆，不想看了，原文在<a href="https://javabetter.cn/jvm/bytecode.html">https://javabetter.cn/jvm/bytecode.html</a></p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>常量池就是Class文件里的一大段内容（通常是最大的一段内容），它主要存放着 字面量、符号引用 等信息，在JVM把Class文件加载完成后，Class 常量池里的数据会存放到<strong>运行时常量池</strong>中。</p>
<h3 id="字面量（Literal）-符号引用（Symbolic-References）"><a href="#字面量（Literal）-符号引用（Symbolic-References）" class="headerlink" title="字面量（Literal） &amp; 符号引用（Symbolic References）"></a>字面量（Literal） &amp; 符号引用（Symbolic References）</h3><p>字面量：类似 Java 中的常量概念，比如文本字符串，final 常量等。</p>
<p>符号引用，包括以下三种：</p>
<ul>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
</ul>
<p>jvm先从常量池获取对应的符号引用，然后在类创建或者运行时解析并翻译到具体的内存地址上。</p>
<h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>运行时常量池是方法区（Method Area）的一部分，运行时常量池中存储的，是基本类型的数据和对象的引用。</p>
<p>Java虚拟机在加载Class文件时，Class文件内容里常量池的数据会放入运行时常量池。每一个加载好的Class对象里都会有一个运行时常量池。</p>
<h3 id="字符串常量池（String-Constant-Pool）-其他包装类型里实现的常量池"><a href="#字符串常量池（String-Constant-Pool）-其他包装类型里实现的常量池" class="headerlink" title="字符串常量池（String Constant Pool） &amp; 其他包装类型里实现的常量池"></a>字符串常量池（String Constant Pool） &amp; 其他包装类型里实现的常量池</h3><p>字符串由一个char[]构成，当我们的Java程序里频繁出现相同字面量的代码时，重复的创建和销毁对象是一件很浪费资源的事情，所以Java实现了一个字符串常量池。</p>
<p>JDK7之后，字符串常量池从方法区迁移到了堆区，它的底层实现可以理解为是一个<strong>HashTable</strong>。Jvm中只会存在一份字符串常量池。字符串常量池里，存放的数据可以是引用也可以是对象实例本身。</p>
<p>字符串常量池也具备运行时常量池动态性的特征，它支持运行期间将新的常量放入池中，这种特性被开发人员利用比较多的就是 String.intern() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>当以上代码运行时，JVM会到字符串常量池查找 “aaa” 这个字面量对象是否存在：</p>
<p><strong>存在</strong>：则返回该对象的引用给变量 <strong>str1</strong> 。</p>
<p><strong>不存在</strong>：则创建一个对象，同时将引用返回给变量 <strong>str1 。</strong>（JDK8之后，对象实例直接存储在字符串常量池里）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//返回TRUE</span></span><br></pre></td></tr></table></figure>

<p>因为变量<strong>str1</strong> 和<strong>str2</strong> 都指向同一个对象，所以返回true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//返回FALSE</span></span><br></pre></td></tr></table></figure>

<p>当我们使用了<strong>new</strong>来构造字符串对象的时候，不管字符串常量池中是否有相同内容的对象的引用，新的字符串对象都会创建。因为两个指向的是不同的对象，所以返回FALSE 。</p>
<h4 id="String-intern-方法"><a href="#String-intern-方法" class="headerlink" title="String.intern()方法"></a>String.intern()方法</h4><p>对于使用了new 创建的字符串对象，如果想要将这个对象添加到字符串常量池，可以使用intern() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">interns</span> <span class="operator">=</span> str3.intern();</span><br><span class="line">System.out.println(interns == str1);<span class="comment">//返回TRUE</span></span><br></pre></td></tr></table></figure>

<p>intern() 方法会检查字符串常量池中是否有与之匹配的对象，并做如下操作：</p>
<p>存在：直接返回对象引用给interns变量。</p>
<p>不存在：将这个对象引用加入到常量池，再返回对象引用给interns变量。</p>
<h4 id="以下创建了多少个对象呢？"><a href="#以下创建了多少个对象呢？" class="headerlink" title="以下创建了多少个对象呢？"></a>以下创建了多少个对象呢？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>+<span class="string">&quot;efg&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;abcefg&quot;</span>;</span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//返回TRUE</span></span><br></pre></td></tr></table></figure>

<p>答案是三个。第一个：”abc” ，第一个：”efg”，第三个：”abc”+”efg”（”abcefg”）</p>
<p>String str5 &#x3D; “abcefg”; 这句代码并没有创建对象，它从常量池中找到了”abcefg” 的引用，所以str4 &#x3D;&#x3D; str5 返回TRUE，因为它们都指向一个相同的对象。</p>
<h4 id="基本类型的包装类和常量池"><a href="#基本类型的包装类和常量池" class="headerlink" title="基本类型的包装类和常量池"></a>基本类型的包装类和常量池</h4><p>Byte、Short、Integer、Long、Character、Boolean、String 这 7 种包装类都各自实现了自己的常量池。</p>
<p>Float 和Double 这两个浮点类型没有实现常量池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出TRUE</span></span><br></pre></td></tr></table></figure>

<p>Byte、Short、Integer、Long、Character这5种包装类都默认创建了数值[-128 , 127]的缓存数据。<strong>当这5个类型的数据不在这个区间内的时候，将会去创建新的对象，并且不会将这些新的对象放入常量池中。</strong></p>
<h1 id="JVM之字节码与类的加载"><a href="#JVM之字节码与类的加载" class="headerlink" title="JVM之字节码与类的加载"></a>JVM之字节码与类的加载</h1><h2 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h2><p>Class文件由Java编译器生成，我们创建的.Java文件在经过编译器后，会变成.Class的文件，这样才能被JVM所识别并运行。</p>
<p>Class文件的核心设计思想是<strong>平台无关性</strong>，它存储的不是操作系统可以直接识别的二进制本地机器码，而是根据Java虚拟机规范所自定义的指令集、符号表和一些其他信息，所以只要任何一个操作系统下开发有对应的Java虚拟机，开发者的Java程序就能跑起来。</p>
<h3 id="查看Class文件"><a href="#查看Class文件" class="headerlink" title="查看Class文件"></a>查看Class文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxd Hello.class</span><br></pre></td></tr></table></figure>
<h3 id="Class文件组成"><a href="#Class文件组成" class="headerlink" title="Class文件组成"></a><a href="https://javabetter.cn/jvm/class-file-jiegou.html">Class文件组成</a></h3><h4 id="魔数（cafebabe）"><a href="#魔数（cafebabe）" class="headerlink" title="魔数（cafebabe）"></a>魔数（cafebabe）</h4><p>第一行中有一串特殊的字符 <code>cafebabe</code>，它就是一个魔数，是 JVM 识别 class 文件的标志，JVM 会在验证阶段检查 class 文件是否以该魔数开头，如果不是则会抛出 <code>ClassFormatError</code>。</p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>紧跟着魔数后面的四个字节 <code>0000 0037</code> 分别表示副版本号和主版本号。也就是说，主版本号为 55（0x37 的十进制），也就是 Java 11 对应的版本号，副版本号为 0。</p>
<h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p>紧跟在版本号之后的是常量池，它包含了类、接口、字段和方法的符号引用，以及字符串字面量和数值常量。这些信息在编译时被创建，并在运行时被JVM使用。</p>
<h4 id="访问标记-Access-flags"><a href="#访问标记-Access-flags" class="headerlink" title="访问标记(Access flags)"></a>访问标记(Access flags)</h4><p>紧跟着常量池之后的区域就是访问标记，这个标记用于识别类或接口的访问信息。</p>
<h4 id="类索引、父类索引和接口索引"><a href="#类索引、父类索引和接口索引" class="headerlink" title="类索引、父类索引和接口索引"></a>类索引、父类索引和接口索引</h4><p>这三部分用来确定类的继承关系，this_class 为当前类的索引，super_class 为父类的索引，interfaces 为接口。</p>
<h5 id="如何通过索引值定位到在Class文件中的位置？"><a href="#如何通过索引值定位到在Class文件中的位置？" class="headerlink" title="如何通过索引值定位到在Class文件中的位置？"></a>如何通过索引值定位到在Class文件中的位置？</h5><blockquote>
<p>在Java类文件中，常量池是一个索引表，它从索引值1开始计数，每个条目都有一个唯一的索引。</p>
<ul>
<li>常量池计数器：在常量池之前，类文件有一个16位的常量池计数器，表示常量池中有多少项。它的值比实际常量数大1（因为索引从1开始）。</li>
<li>常量池条目：每个常量池条目的开始是一个标签（1个字节），表明了常量的类型（如Class、Fieldref、Methodref等）。根据这个类型，后面跟着的数据结构也不同。</li>
</ul>
<p>定位过程大致如下：</p>
<ul>
<li><strong>读取常量池计数器</strong>：首先，从类文件的开头读取常量池计数器的值，确定常量池中有多少条目。</li>
<li><strong>遍历常量池</strong>：从常量池的第一项开始遍历。由于不同类型的常量长度不同，需要根据每个常量的类型来确定它的长度。</li>
<li><strong>根据索引定位</strong>：继续遍历，直到到达所需的索引值。每次遍历时，根据条目类型读取相应长度的数据，直到达到目标索引。</li>
</ul>
</blockquote>
<h4 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h4><p>一个类中定义的字段会被存储在字段表（fields）中，包括静态的和非静态的。</p>
<h4 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h4><p>方法表和字段表类似，区别是用来存储方法的信息，包括方法名，方法的参数，方法的签名。</p>
<h4 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h4><p>属性表是 class 文件中的最后一部分，通常出现在字段和方法中。</p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>也可以称之为类加载器，JVM默认提供三个类加载器</p>
<h3 id="了解类加载器"><a href="#了解类加载器" class="headerlink" title="了解类加载器"></a>了解类加载器</h3><p>1、<strong>Bootstrap ClassLoader：</strong>称之为启动类加载器，是最顶层的类加载器，负责加载JDK中的核心类库，如 rt.jar、resources.jar、charsets.jar等。<br>2、<strong>Extension ClassLoader：</strong>称之为扩展类加载器，负责加载Java的扩展类库，默认加载$JAVA_HOME中jre&#x2F;lib&#x2F;*.jar 或 -Djava.ext.dirs指定目录下的jar包。<br>3、<strong>Application ClassLoader：</strong>称之为系统类加载器，负责加载应用程序classpath目录下所有jar和class文件。</p>
<p>除了Java默认提供的三个加载器之外，我们还可以根据自身需求自定义ClassLoader，自定义的类加载器必须继承自 java.lang.ClassLoader 类。</p>
<p>除了 BootStrap ClassLoader 之外的两个默认加载器都是继承自 java.lang.ClassLoader ，BootStrap ClassLoader 不是一个普通的Java类，它底层由C++编写，已嵌入到了JVM的内核当中。</p>
<p>当JVM启动后，BootStrap ClassLoader 也随之启动，负责加载完核心类库，并构造Extension ClassLoader 和App ClassLoader 类加载器。</p>
<h4 id="命名空间：存储加载的类"><a href="#命名空间：存储加载的类" class="headerlink" title="命名空间：存储加载的类"></a>命名空间：存储加载的类</h4><p>每个类加载器都拥有一个自己的命名空间，用于<strong>存储被自身加载过的所有类的全限定名</strong>。子类加载器可以检查父类加载器中加载的类，通过拿类的全限定名在父类的命名空间内搜索匹配。<strong>但父类不可以看子类加载了哪些类</strong>。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><strong>任何一个类加载器在接到一个类的加载请求时，都会先让其父类进行加载，只有父类无法加载（或者没有父类）的情况下，才尝试自己加载。</strong><br>父子关系：Boot &gt; Extension &gt; App &gt; 用户自定义</p>
<p><strong>好处：</strong><br>先了解一个知识点：不同的类加载器，加载同一个类，结果是虚拟机里会存在两份这个类的信息，所以当判断这两个类是否“相等”时，必定是不相等的。</p>
<p>使用双亲委派模型可以保证每一个类只会有一个类加载器。例如Java最基础的Object类，它存放在 rt.jar 之中，这是 Bootstrap 的职责范围，当向上委派到 Bootstrap 时就会被加载。</p>
<p>但如果没有使用双亲委派模式，可以任由自定义加载器进行加载的话，Java这些核心类的API就会被随意篡改。</p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>类加载机制指的是将.class文件中的二进制数据读入到内存中，并对数据进行校验，解析和初始化。最终，每一个类都会在方法区保存一份它的元数据，在堆中创建一个与之对应的Class对象。</p>
<p>类的生命周期，经历7个阶段，分别是加载、验证、准备、解析、初始化、使用、卸载。<br>除了<strong>使用</strong>和<strong>卸载</strong>两个过程，前面的5个阶段 <strong>加载、验证、准备、解析、初始化</strong> 的执行过程，就是类的加载过程。5个阶段并不是严格意义上的按顺序完成，在类加载的过程中，这些阶段会互相混合，交叉运行，最终完成类的加载和初始化。</p>
<p>对于什么时候加载，Java虚拟机规范中并没有约束，各个虚拟机都可以按自身需要来自由实现。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段，虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名去找到其对应的.class文件（类加载器执行）</li>
<li>将这个.class文件内的二进制数据读取出来，转化成方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范。例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型 …… 等等</p>
<p><strong>元数据验证</strong>：对字节码描述的元数据信息进行语义分析，要符合Java语言规范。例如：是否继承了不允许被继承的类（例如final修饰过的）、类中的字段、方法是否和父类产生矛盾 …… 等等</p>
<p><strong>字节码验证</strong>：对类的方法体进行校验分析，确保这些方法在运行时是合法的、符合逻辑的。</p>
<p><strong>符号引用验证</strong>：发生在<strong>解析</strong>阶段，符号引用转为直接引用的时候，例如：确保符号引用的全限定名能找到对应的类、符号引用中的类、字段、方法允许被当前类所访问 …… 等等</p>
<p>验证阶段不是必须的，虽然这个阶段非常重要。Java虚拟机允许程序员主动取消这个阶段，用来缩短类加载的时间，可以根据自身需求，使用 -Xverify:none参数来关闭大部分的类验证措施。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>这个阶段，类的静态字段信息会得到内存分配，并且设置为初始值。初始值指的是变量数据类型的默认值，而不是被在Java代码中被显式地赋予的值。但是，当字段信息被 final 修饰成常量（ConstantValue）时，这个初始值就是Java代码中显式地赋予的值。</p>
<p>在JDK8取消永久代后，方法区变成了一个逻辑上的区域，这些类变量的内存实际上是分配在Java堆中的。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>这个阶段，虚拟机会把Class文件中，<strong>常量池内的符号引用转换为直接引用</strong>。可以理解为当前加载的这个类，和它所引用的类，正式进行连接的过程。</p>
<blockquote>
<p>符号引用：代码在编译期间，是不知道最终引用的类型具体指向内存中哪个位置的，这时候会用一个符号引用，来表示具体引用的目标。</p>
<p>直接引用：直接引用就是可以直接或间接指向目标内存位置的指针或句柄。</p>
</blockquote>
<h5 id="引用的类型，还未加载初始化怎么办？"><a href="#引用的类型，还未加载初始化怎么办？" class="headerlink" title="引用的类型，还未加载初始化怎么办？"></a>引用的类型，还未加载初始化怎么办？</h5><p>当出现这种情况，会触发这个引用对应类型的加载和初始化。</p>
<h5 id="解析的时机"><a href="#解析的时机" class="headerlink" title="解析的时机"></a>解析的时机</h5><p>解析并不只出现在类加载过程，有些方法可能是真正被调用时才做解析操作。通常类加载时的解析包括了描述唯一版本的方法的符号引用，比如：final修饰的方法，版本唯一确定，就更适合在类加载阶段直接替换为直接引用。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化的过程，就是执行类构造器 &lt;clinit&gt;()方法的过程。&lt;clinit&gt;() 方法 和 &lt;init&gt; 方法不同，它们一个是“类构造器”，一个是实例构造器。</p>
<p>Java虚拟机会保证在子类&lt;clinit&gt;() 方法在执行前，父类的 &lt;clinit&gt;() 已经执行完毕。而 &lt;init&gt; 方法则需要显性的调用父类的构造器。&lt;clinit&gt;() 方法<strong>由编译器自动生成</strong>，但不是必须生成的，只有这个类存在static修饰的变量，或者类中存在静态代码块但时候，才会自动生成&lt;clinit&gt;()方法。</p>
<h5 id="方法的作用是什么？"><a href="#方法的作用是什么？" class="headerlink" title="&lt;clinit&gt;() 方法的作用是什么？"></a>&lt;clinit&gt;() 方法的作用是什么？</h5><p>上面提到在准备阶段，已经对类中static修饰的变量赋予了初始值。&lt;clinit&gt;() 方法的作用，就是给这些变量赋予程序员实际定义的值。同时类中如果存在static代码块，也会执行这个静态代码块里面的代码。</p>
<h5 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a>初始化时机</h5><p>Java虚拟机规范有明确规定，当符合以下条件时（包括但不限于），虚拟机内存中没有找到对应类型信息，则必须对类进行<strong>初始化</strong>操作：</p>
<blockquote>
<p>使用new实例化对象时；</p>
<p>读取或者设置一个类的静态字段或方法时；</p>
<p>反射调用时，例如 Class.forName(“com.xxx.MyTest”)；</p>
<p>初始化一个类的子类，会首先初始化子类的父类；</p>
<p>Java虚拟机启动时标明的启动类；</p>
<p>JDK8 之后，接口中存在default方法，这个接口的实现类初始化时，接口会其之前进行初始化；</p>
</blockquote>
<p>初始化阶段开始之前，自然还是要先经历 加载、验证、准备 、解析的。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>有了class对象，就可以在堆上为这个类分配实例对象，或者调用它的静态方法了。</p>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>卸载类即该类的 Class 对象被 GC。</p>
<p>卸载类需要满足 3 个要求:</p>
<blockquote>
<ol>
<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器的实例已被 GC</li>
</ol>
</blockquote>
<p>没有实例对象，没有被引用，且类加载器还要被GC，因此类的class对象被GC是一件不太容易发生的事件。</p>
<p><strong>只有自定义类加载器加载的类才有可能被卸载，JVM三个自带的类加载器加载的Class永远不会被卸载</strong>。</p>
<h1 id="JVM之内存与垃圾回收"><a href="#JVM之内存与垃圾回收" class="headerlink" title="JVM之内存与垃圾回收"></a>JVM之内存与垃圾回收</h1><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><h3 id="堆内存（java-heap"><a href="#堆内存（java-heap" class="headerlink" title="堆内存（java heap)"></a>堆内存（java heap)</h3><h4 id="堆内存的分区"><a href="#堆内存的分区" class="headerlink" title="堆内存的分区"></a>堆内存的分区</h4><p>堆内存通常被划分为不同的子区域，以更好地适应对象生命周期的不同阶段以及提高内存管理效率。</p>
<p>常见的一种分区方式是将堆分为年轻代、老年代和「永久代（PermGen）与元空间（Metaspace）」。</p>
<p>在早期的JVM版本中，永久代用于存储类的元数据信息，如类名、方法名、字段名等符号引用以及静态变量、常量池等。然而，永久代在JDK 8及以后的版本中已被元空间（Metaspace）所取代。</p>
<p>元空间不在堆内存中，而是使用本地内存（Native Memory），用于存储类的元数据和方法区数据。</p>
<h4 id="堆内存的基本知识"><a href="#堆内存的基本知识" class="headerlink" title="堆内存的基本知识"></a>堆内存的基本知识</h4><p>堆区负责存放对象实例，当Java创建一个类的实例对象或者数组时，都会在堆中为新的对象分配内存。</p>
<p>虚拟机中只有一个堆，程序中所有的线程都共享它。堆的存取方式为管道类型，先进先出。</p>
<p>在程序运行中，可以动态的分配堆的内存大小：</p>
<blockquote>
<ul>
<li><code>-Xms</code>：设定JVM初始堆内存大小。设置此值可以避免程序在运行初期因频繁的堆内存扩容而导致性能下降。</li>
<li><code>-Xmx</code>：设定JVM最大堆内存大小。超出此值，若无法进一步分配内存，则会导致<code>OutOfMemoryError</code>异常。</li>
<li>理想情况下，<code>-Xms</code>和<code>-Xmx</code>应设为相同的值，以减少堆内存动态扩展带来的额外开销。</li>
</ul>
</blockquote>
<p>堆的内存资源回收是交给GC进行管理的。</p>
<h4 id="TLAB（Thread-Local-Allocation-Buffer）"><a href="#TLAB（Thread-Local-Allocation-Buffer）" class="headerlink" title="TLAB（Thread Local Allocation Buffer）"></a>TLAB（Thread Local Allocation Buffer）</h4><p>为了提高对象分配的并发性和减少多线程竞争，JVM允许为每个线程分配一个私有的小块内存区域，称为TLAB。</p>
<p>线程在分配新对象时，优先在自己的TLAB中寻找空闲空间，只有当TLAB空间不足时，才会尝试锁定全局堆内存进行分配。</p>
<p>这种方式可以降低锁的竞争，提升分配效率。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区用于存储JVM加载完成的类型信息、常量、静态变量、即时编译器编译后的代码缓存，方法区和 Java 堆区一样，都是线程共享的内存区域。</p>
<p>在JDK8以前，使用永久代的方式来实现方法区，可以像java堆一样去管理方法区的内存，而它会更容易导致内存溢出的问题（永久代有上限，参数：-XX:MaxPermSize，即使不设置也会有默认大小）；到了JDK7，尝试将字符串常量池、静态变量移出来；JDK8以后，永久代的概念被废弃了，方法区改用和 JRockit、J9一样的<strong>在本地内存中实现的元空间（Meta Space）</strong>来代替，好处是元空间会在运行时根据需要动态调整，只要没有超过当前进程可用的内存上限，就不会出现溢出的问题。</p>
<p>当需要扩展时空间不足，会抛出OutOfMemoryError 异常。</p>
<h4 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h4><h5 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h5><p>类或接口的全限定名（包名+类名），如 <code>java.lang.String</code>；类的直接父类的全限定名（对于接口则是其直接父接口列表）；修饰符和类型标志：如 public、final、abstract 等修饰符，以及是否为接口、枚举、注解等类型标志；类或接口直接实现或继承的接口列表。</p>
<h5 id="常量池-2"><a href="#常量池-2" class="headerlink" title="常量池"></a>常量池</h5><p>字符串、整型、浮点数等基本类型的常量值；符号引用</p>
<h5 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h5><p>类或接口中声明的所有字段（成员变量）的相关数据；类型（完全限定名）；初始值或默认值（对于非final的静态变量，初始值在准备阶段设定；对于实例变量，其默认值在对象初始化时设定）；<br>字段的声明顺序。</p>
<h5 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h5><p>方法的名称、返回类型、参数列表及其类型、修饰符（如 public、private、synchronized、abstract、native 等）；方法的字节码：描述方法执行的具体指令序列；方法的附加信息；局部变量表：描述各局部变量的名称、类型和作用域；操作数栈和帧数据区大小：与方法执行时的栈帧结构相关；异常表：记录方法内特定指令可能抛出的异常处理信息（如catch块的位置）。</p>
<h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>非final的静态变量：类或接口中声明的静态变量，它们不属于常量池的一部分，而是存储在方法区中供所有实例共享。<br>全局常量(final static) ：虽然也在方法区中，但通常会被编译器优化并直接嵌入到使用它们的类文件中。</p>
<h5 id="类加载器引用"><a href="#类加载器引用" class="headerlink" title="类加载器引用"></a>类加载器引用</h5><p>指向加载该类或接口的类加载器的引用，用于确定类的加载来源和进行类加载器相关的沙箱隔离。</p>
<h5 id="Class对象引用"><a href="#Class对象引用" class="headerlink" title="Class对象引用"></a>Class对象引用</h5><p>每个被加载的类或接口都会在堆中生成一个对应的<code>java.lang.Class</code>对象，方法区中存储的是指向该对象的引用。</p>
<h5 id="方法表-1"><a href="#方法表-1" class="headerlink" title="方法表"></a>方法表</h5><p>有时也称为方法描述符表，它是一个列表，包含了类或接口中所有方法的描述符，用于快速查找和访问方法。</p>
<h4 id="简单认识一下栈、方法区与堆之间的联系"><a href="#简单认识一下栈、方法区与堆之间的联系" class="headerlink" title="简单认识一下栈、方法区与堆之间的联系"></a>简单认识一下栈、方法区与堆之间的联系</h4><p><img src="/assets/img/09.png" alt="认识联系" title="区分"></p>
<p>等号左边的A为类型信息，存储于方法区中；a为变量，存放于局部变量表中，也就是存于栈中；等号右边的new A()，也就是对象的创建，就是创建在堆中。</p>
<h3 id="程序计数器（PC-Register）"><a href="#程序计数器（PC-Register）" class="headerlink" title="程序计数器（PC Register）"></a>程序计数器（PC Register）</h3><p>在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>JVM的多线程是<strong>通过线程轮流切换并分配处理器执行时间</strong>的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以<strong>每条线程都会有一个独立的程序计数器</strong>，就是一个指针，指向方法区中的方法字节码，由执行引擎读取下一条指令。</p>
<p>程序计数器仅占很小的一块内存空间。</p>
<p>当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址。如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>JVM在运行Java应用程序时为每个线程创建的一个线程私有的内存区域，虚拟机栈主要用于存储和管理Java方法的调用过程中的各种数据和指令。</p>
<h4 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h4><h5 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h5><p>每个线程都有独立的虚拟机栈，不同线程之间的栈数据相互隔离，因此保证了线程间的独立性和安全性。</p>
<h5 id="栈帧（Stack-Frame）"><a href="#栈帧（Stack-Frame）" class="headerlink" title="栈帧（Stack Frame）"></a>栈帧（Stack Frame）</h5><p>每当一个方法被调用时，虚拟机栈上会创建一个新的栈帧来存储该方法的局部变量表、操作数栈、动态链接和方法出口信息。</p>
<p>栈帧的入栈和出栈顺序与方法的调用和返回顺序一致，遵循后进先出原则。</p>
<blockquote>
<ul>
<li><strong>局部变量表</strong>：存储方法内的基本类型变量、对象引用和其他引用类型的数据。</li>
<li><strong>操作数栈</strong>：作为计算单元，用于存放方法执行过程中的临时数据，支持算术运算、类型转换等操作。</li>
<li><strong>动态链接</strong>：指向方法调用的实际代码实现，因为Java支持方法的重载和动态绑定。</li>
<li><strong>方法出口</strong>：记录方法结束的位置，无论是正常返回还是异常返回，都需要通过它来恢复调用者的执行状态。</li>
</ul>
</blockquote>
<h5 id="方法调用与栈帧生命周期"><a href="#方法调用与栈帧生命周期" class="headerlink" title="方法调用与栈帧生命周期"></a>方法调用与栈帧生命周期</h5><p>方法的调用过程就是相应的栈帧压入虚拟机栈的过程；方法的执行完毕则是栈帧弹出的过程。</p>
<p>如果线程请求的栈深度大于虚拟机允许的最大深度，将会抛出 <code>StackOverflowError</code> 异常；如果虚拟机栈容量无法动态扩展，并且栈内存不足时，会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h5 id="异常处理与回溯"><a href="#异常处理与回溯" class="headerlink" title="异常处理与回溯"></a>异常处理与回溯</h5><p>当方法执行过程中发生异常时，虚拟机会通过异常处理表找到合适的异常处理器，并通过栈帧的连接关系找到异常抛出前的位置，从而继续执行异常处理逻辑。</p>
<h5 id="栈大小的限制与调整"><a href="#栈大小的限制与调整" class="headerlink" title="栈大小的限制与调整"></a>栈大小的限制与调整</h5><p>在启动Java虚拟机时，可以指定虚拟机栈的大小。</p>
<h3 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h3><p>本地方法栈的功能和JVM栈非常类似，区别在于虚拟机栈执行的是Java方法，本地方法栈执行的是本地（Native）方法服务，存储的也是本地方法的局部变量表，本地方法的操作数栈等信息。</p>
<p>栈内的数据在超出其作用域后，会被自动释放掉，它不由GC管理。</p>
<h4 id="启用时机"><a href="#启用时机" class="headerlink" title="启用时机"></a>启用时机</h4><p>本地方法栈是在 程序调用 或 JVM调用 <strong>本地方法接口（Native）</strong>时候启用。</p>
<p>本地方法都不是使用Java语言编写的，它们可能由C或其他语言编写，本地方法也不由JVM去运行，所以本地方法的运行不受JVM管理。</p>
<p>HotSpot VM将本地方法栈和JVM栈合并了。</p>
<h4 id="本地方法接口-JNI"><a href="#本地方法接口-JNI" class="headerlink" title="本地方法接口(JNI)"></a>本地方法接口(JNI)</h4><p>JNI是Java Native interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C和C++）。</p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>当我们有一些旧的库，已经使用C语言编写好了，如果要移植到Java上来，非常浪费时间，而JNI可以支持Java程序与C语言编写的库进行交互，这样就不必要进行移植了。或者是与硬件、操作系统进行交互、提高程序的性能等，都可以使用JNI。</p>
<h5 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h5><p>一旦使用JNI，Java程序将丢失了Java平台的两个优点：</p>
<ol>
<li>程序不再跨平台，要想跨平台，必须在不同的系统环境下程序编译配置本地语言部分。</li>
<li>程序不再是绝对安全的，本地代码的使用不当可能会导致整个程序崩溃。一个通用规则是，调用本地方法应该集中在少数的几个类当中，这样就降低了Java和其他语言之间的耦合。</li>
</ol>
<h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><ol>
<li>将需要用C&#x2F;C++实现的方法用native关键字声明</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用静态代码块进行动态链接库加载jnidemo.dll&#x2F;jnidemo.so</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">       System.loadLibrary(<span class="string">&quot;jnidemo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>用javac -h .  JNIDemo.java生成头文件（旧版本为javah)，执行完后生成一个的.h头文件和class文件。</li>
<li>实现对应的函数：创建.cpp文件，写代码，将.h头文件里函数的声明复制过来,加上需要用的参数名。</li>
<li>将C&#x2F;C++编译成动态链接库,mac用jnilib文件，win用dll文件<br><strong>查找jdk安装位置：&#x2F;usr&#x2F;libexec&#x2F;java_home</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -o javafirst.jnilib -fPIC -shared -I/Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home/include -I/Library/Java/JavaVirtualMachines/jdk-21.jdk/Contents/Home/include/darwin java_first.cpp</span><br></pre></td></tr></table></figure>
<p>两个路径一个是jni.h的，一个是jni_md.h的</p>
<ul>
<li>shared: 表示创建一个共享目标文件，即动态链接库</li>
<li>fPIC: 生成位置无关代码（Position Independent Code），这是在创建共享库时必须的选项。</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="复制-Copying-算法（标记-复制算法）"><a href="#复制-Copying-算法（标记-复制算法）" class="headerlink" title="复制(Copying)算法（标记-复制算法）"></a>复制(<code>Copying</code>)算法（标记-复制算法）</h3><p>将可用内存分为两块，每次只用其中一块，当一块内存用完了，就将还存活的对象复制到另外一块上，然后再把已经使用过的内存空间一次性清理掉，循环下去。这样每次只需对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。</p>
<p>优点：实现简单；不产生内存碎片</p>
<p>缺点：内存缩小为原来的一半，代价太高</p>
<blockquote>
<p>现在商用虚拟机都采用复制算法来回收新生代，不过<code>1:1</code>的比例非常不科学，因此新生代的内存被划分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间，每次使用<code>Eden</code>和其中一块<code>Survivor</code>。</p>
<p>每次回收时，将<code>Eden</code>和<code>Survivor</code>中还存活着的对象一次性复制到另外一块<code>Survivor</code>空间上，最后清理掉<code>Eden</code>和刚才用过的<code>Survivor</code>空间。</p>
<p><code>HotSpot</code>虚拟机默认<code>Eden</code>区和<code>Survivor</code>区的比例为<code>8:1</code>，意思是每次新生代中可用内存空间为整个新生代容量的<code>90%</code>。当然，我们无法保证每次回收都少于<code>10%</code>的对象存活，当<code>Survivor</code>空间不够用时，需要依赖老年代进行分配担保(<code>Handle Promotion</code>)。</p>
</blockquote>
<h4 id="分配担保机制"><a href="#分配担保机制" class="headerlink" title="分配担保机制"></a>分配担保机制</h4><p>虽然根据IBM的研究，每次GC新生代里98%的对象都会被回收，但这不是百分之百的几率，极端情况下可能会出现超过10%的对象存活。分配担保机制就是为了保证当出现这种情况时，有其他内存空间来进行兜底。</p>
<p>通常这个“担保人”是老年代，当存活的对象超过Survivor空间大小时，这些存活的对象会忽略年龄，直接进入老年代里。</p>
<h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(<code>Mark-Sweep</code>)</h3><p>首先标记出所有需要回收的对象，标记完成后回收所有被标记的对象。</p>
<p>从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象，如果活着，就标记。只有全部标记完毕的时候，清理动作才开始。在清理的时候，没有标记的对象将会被释放，不会发生任何动作。但是剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就得重新整理剩下的对象。</p>
<p>优点：标记—清除算法中每个活着的对象的引用只需要找到一个即可，找到一个就可以判断它为活的。此外，更重要的是，这个算法并不移动对象的位置。</p>
<p>缺点：不足主要体现在效率和空间，从效率的角度讲，标记和清除效率都不高（递归与全堆对象遍历），每个活着的对象都要在标记阶段遍历一遍，所有对象都要在清除阶段扫描一遍，因此算法复杂度较高；从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致需要分配较大对象时，无法找到足够的连续内存而提前触发一次垃圾收集动作。</p>
<h3 id="标记-压缩算法（标记-整理）-Mark-Compact"><a href="#标记-压缩算法（标记-整理）-Mark-Compact" class="headerlink" title="标记-压缩算法（标记-整理）(Mark-Compact)"></a>标记-压缩算法（标记-整理）(<code>Mark-Compact</code>)</h3><p>过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。</p>
<p>优点：该算法不会像标记-清除算法那样产生大量的碎片空间。</p>
<p>缺点：如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>当程序创建一个新的对象或者基本类型的数据，内存空间不足时，会触发GC的执行。</p>
<p>GC只回收<strong>堆区和方法区</strong>内的基本类型数据和对象。</p>
<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>只回收新生代区域，通常频率较高但耗时较短。</p>
<h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>只回收老年代区域。只有CMS实现了Major GC，所以在老年代里，触发GC，除了CMS和G1之外的其他收集器，大多数触发的其实是 Full GC。</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>回收整个堆区和方法区，开销较大，尽量避免过于频繁的发生。</p>
<h3 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h3><p>回收整个新生代和部分老年代。G1收集器实现了这个类型。</p>
<h3 id="Stop-The-World-STW"><a href="#Stop-The-World-STW" class="headerlink" title="Stop The World(STW)"></a>Stop The World(STW)</h3><p><strong>Stop The World</strong> 会在任何一种GC算法中发生，其实可以把它理解为GC在清理内存时需要暂停所有用户线程。当 STW发生时，除GC所需的线程外，所有的线程都进入等待状态，直到 GC 任务完成。每一代的Java垃圾回收器，都把缩减 <strong>Stop The World</strong> 停顿时间作为很重要的目标。</p>
<h3 id="判断对象是否可以回收"><a href="#判断对象是否可以回收" class="headerlink" title="判断对象是否可以回收"></a>判断对象是否可以回收</h3><p>需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>（主要）。</p>
<ul>
<li><p>引用计数算法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，但是无法解决对象相互循环引用的问题，就是互相引用的对象。</p>
</li>
<li><p>可达性分析算法（Reachability Analysis）（根搜索算法）：通过一系列可被作为 <strong>GC Roots</strong> 的根对象来作为起始节点，从这些节点开始，根据引用关系向下搜索，搜索过程的就是一条<strong>引用链（Reference Chain）</strong>，没有在这个链条上面的对象，也就是根节点通过引用链不可达到这个对象时，就认为这个对象是可以被回收的。当一个对象到<code>GC Roots</code>不可达时，在下一个垃圾回收周期中尝试回收该对象，如果对象重写了<code>finalize()</code>，并在这个方法中成功自救(将自身赋予某个引用)，那么这个对象不会被回收。但如果这个对象没有重写<code>finalize()</code>方法或已执行过这个方法，该对象将会被回收。</p>
</li>
</ul>
<h4 id="可以作为根节点-GC-Roots-的对象"><a href="#可以作为根节点-GC-Roots-的对象" class="headerlink" title="可以作为根节点(GC Roots)的对象"></a>可以作为根节点(<code>GC Roots</code>)的对象</h4><blockquote>
<ul>
<li><p>虚拟机栈中引用的对象，例如线程调用方法时，使用或产生的参数、局部变量、临时变量等；</p>
</li>
<li><p>方法区中类的引用类型静态变量或常量；</p>
</li>
<li><p>本地方法栈中<code>JNI</code>引用的对象。</p>
</li>
<li><p>在JVM内部的对象，例如基本数据类型的Class对象，一些常驻的异常对象（NullPointExcepiton），系统类加载器等。</p>
</li>
<li><p>所有synchronized同步锁的持有对象。</p>
</li>
<li><p>反映JVM内部情况的JMXBean、JVMTI注册的回调、本地代码缓存等。</p>
</li>
</ul>
</blockquote>
<h4 id="如何找到GC-Roots"><a href="#如何找到GC-Roots" class="headerlink" title="如何找到GC Roots?"></a>如何找到GC Roots?</h4><p>虽然我们明确知道哪些对象可以作为 GC Roots ，但是遍历整个方法区，栈，常量池等，显然效率太低。</p>
<p>HotSpot使用OopMap来实现，他将所有可能的GC Roots记录下来，这样直接从OopMap里就可以拿到GC Roots。</p>
<p>但是，会导致OopMap变化的操作太多了，因此，只会在安全点记录OopMap。</p>
<p>在找到GC Roots的这个过程，是一定会导致STW的。暂停所有线程是需要一个合适的时机的，执行代码不是说停就能停的。</p>
<p>所以专门有<strong>安全点和安全区域</strong>两个概念作为线程由于某种原因需要暂停的暂停点。当用户线程执行到安全点或安全区域的代码处才可以被暂停。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>垃圾回收器并不是特指一种，Java官方本身就提供了很多个GC回收器供用户选择，还有各个Java虚拟机厂商（例如 Azul 的PCG、C4）也自己设计开发了很多优秀的垃圾回收器。</p>
<p>就目前来说，JVM 的垃圾收集器主要分为两大类：<strong>分代收集器</strong>和<strong>分区收集器</strong>，分代收集器的代表是 CMS，分区收集器的代表是 G1 和 ZGC。</p>
<h3 id="Serial-XX-UseSerialGC-SerialOld"><a href="#Serial-XX-UseSerialGC-SerialOld" class="headerlink" title="Serial(-XX:+UseSerialGC) &amp; SerialOld"></a>Serial(-XX:+UseSerialGC) &amp; SerialOld</h3><p>Serial 是Java虚拟机初代收集器，在JDK1.3之前是Jvm<strong>新生代收集器</strong>的唯一选择，这是一个<strong>单线程</strong>工作的收集器。在进行垃圾回收的时候，需要STW，直到回收结束。</p>
<p>虽然历史久远，但它依然是HotSpot虚拟机运行在客户端模式下，或者4核4GB以下服务端的默认新生代收集器，这种核心数和内存空间较小的场景下，它单线程的优势就体现出来了，没有线程交互的开销，加上内存空间不大，单次回收耗时几十毫秒，这点停顿时间，完全是可以接受的。</p>
<p>Serial 负责收集新生代区域，它采用<strong>标记-复制</strong>算法。</p>
<p>SerialOld 负责收集老年代区域，它采用<strong>标记-整理</strong>算法。</p>
<h3 id="ParNew-XX-UseParNewGC-CMS-XX-UseConcMarkSweepGC"><a href="#ParNew-XX-UseParNewGC-CMS-XX-UseConcMarkSweepGC" class="headerlink" title="ParNew(-XX:+UseParNewGC) &amp; CMS(-XX:+UseConcMarkSweepGC)"></a>ParNew(-XX:+UseParNewGC) &amp; CMS(-XX:+UseConcMarkSweepGC)</h3><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>ParNew 就是 在Serial 收集器的基础之上，实现了它的多线程版本。它可以多条线程同时进行垃圾收集，这也是它和 Serial 收集器的最大的区别，其他的功能性、配置、策略等等的和 Serial 基本一致。</p>
<p>在JDK9之后，Java官方取消了ParNew和除了CMS收集器之外的所有老年代收集器的搭配，而且还取消了 - XX:+UseParNewGC 这个参数，只能和CMS搭配使用。</p>
<p>ParNew 负责收集新生代区域，它采用<strong>标记-复制</strong>算法。</p>
<p>ParNew 是JDK7之前 Server VM 模式下的首选的新生代收集器。但是在单CPU的情况下，它的效率不会比 Serial收集器高的。</p>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>CMS (Concurrent Mark Sweep) 是JDK1.4后期推出的GC收集器，它是一款并发低停顿的收集器，<strong>对于响应速度有较高要求，对停顿时间忍受度低的应用，非常适合使用CMS作为垃圾收集器</strong>。</p>
<p><strong>第一个关注 GC 停顿时间（STW 的时间）的垃圾收集器</strong>。</p>
<p>CMS 负责收集老年代区域，它采用<strong>标记-清除</strong>算法。</p>
<h5 id="CMS运行过程"><a href="#CMS运行过程" class="headerlink" title="CMS运行过程"></a>CMS运行过程</h5><p>可以分为四个步骤：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
</ol>
<p>这个阶段<strong>需要</strong> Stop The World（暂停暂停所有用户线程），但这个阶段的速度很快，因为只标记和根节点（GC Roots）直接关联的对象。</p>
<ol start="2">
<li>并发标记（CMS Concurrent mark）</li>
</ol>
<p>这个阶段<strong>不需要</strong> Stop The World，在初始标记完成后，并发标记从GC Roots直接关联的对象开始，遍历整个引用链，这个阶段耗时较长，但<strong>用户线程可以和GC线程一起并发执行</strong>。</p>
<ol start="3">
<li>重新标记（CMS remark）</li>
</ol>
<p>这个阶段<strong>需要</strong> Stop The World，因为并发标记阶段，用户线程和标间线程同时在运行，相当于一边扫地一边丢垃圾，重新标记就是修正用户线程继续运行，导致的变动的那一部分对象。这一阶段的耗时比初始标记长一些，但远没有达到并发标记阶段那么长的时间。这个阶段可以多线程并行标记。</p>
<ol start="4">
<li>并发清理（Concurrent sweep）</li>
</ol>
<p>这个阶段<strong>不需要</strong> Stop The World，执行到这里，说明标记阶段已经完成，此时遍历整个老年代的内存空间，清理掉可回收的对象，由于不需要移动整理存活的对象，这个阶段可以允许用户线程和回收线程并发执行。在清理完成后，会重置CMS收集器的数据结构，等待下一次垃圾回收。</p>
<p>以上4个步骤可以看出，CMS之所以能实现低延迟，是因为它把垃圾搜集分成了几个明确的步骤，在一些耗时较长的阶段实现了用户线程和GC线程并发执行的能力。<strong>用两次短暂的 Stop Tow World 来代替了其他收集器一整段长时间的 Stop Tow World</strong>。</p>
<h5 id="CMS的缺点"><a href="#CMS的缺点" class="headerlink" title="CMS的缺点"></a>CMS的缺点</h5><ol>
<li><p>由于使用了标记-清理算法，回收结束后会产生大量不连续的内存空间，也就是内存碎片。</p>
</li>
<li><p>由于使用了并发处理，很多情况下都是GC线程和应用线程并发执行的，GC线程肯定会占用一部分计算资源。默认情况下，CMS 启用的垃圾回收线程数是<strong>（CPU数量 + 3)&#x2F;4</strong>，当 CPU 数量很大时，启用的垃圾回收线程数占比就越小。但如果 CPU 数量很小，例如只有 2 个 CPU，垃圾回收线程占用就达到了 50%，这极大地降低系统的吞吐量，无法接受。</p>
</li>
<li><p>CMS有两个阶段是可以用户线程和GC线程并发执行的，用户线程的继续执行自然会伴随垃圾的不断产生，这些就是浮动垃圾。这些垃圾只能等下次触发GC的时候才能清除了，也因为这些浮动垃圾的存在，CMS收集器需要留一手，JDK5的时候，在老年代内存空间使用了68%的时候就会触发一次GC，到了JDK6，觉得JDK5的这个设置太保守了，所以调整到了92%。(可以通过-XX:CMSInitiatingOccupancyFraction 调整这个阈值)</p>
</li>
</ol>
<h3 id="Parallel-Scavenge-XX-UseParallelGC-Parallel-Old-XX-UseParallelOldGC"><a href="#Parallel-Scavenge-XX-UseParallelGC-Parallel-Old-XX-UseParallelOldGC" class="headerlink" title="Parallel Scavenge(-XX:+UseParallelGC) &amp; Parallel Old(-XX:+UseParallelOldGC)"></a>Parallel Scavenge(-XX:+UseParallelGC) &amp; Parallel Old(-XX:+UseParallelOldGC)</h3><h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>和 ParNew 很相似，都是新生代的收集器，支持多线程并行回收，也同样是使用<strong>标记-复制</strong>来作为回收算法。</p>
<p>但 Parallel Scavenge 的关注点不一样，它的目标是实现一个可控制吞吐量的垃圾收集器。</p>
<blockquote>
<p>吞吐量的计算公式：运行用户代码时间 &#x2F; (运行用户代码时间 + 运行垃圾收集时间)</p>
</blockquote>
<h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>就像 Serial Old 是 Serial 的老年代版本一样，Parallel Old 是 Parallel Scavenge 的老年代版本。</p>
<p>Parallel Old 也支持多线程并行回收的能力，使用<strong>标记-整理</strong>来作为回收算法。这个收集器是JDK6的时候推出的，和 Parallel Scavenge 搭配，在多CPU核心和大内存的场景下，吞吐性能优秀。</p>
<p>在注重吞吐量和多CPU核心的情况下，都可以优先考虑 Parallel Scavenge + Parallelo Old 收集器，这也是JDK8的默认收集器组合。</p>
<h3 id="Garbage-First（G1）"><a href="#Garbage-First（G1）" class="headerlink" title="Garbage First（G1）"></a>Garbage First（G1）</h3><p>在JDK9 的时候成为了服务端模式下的默认垃圾收集器。</p>
<p>G1 收集器的设计理念是：实现一个<strong>停顿时间可控的低延迟垃圾收集器</strong></p>
<p>G1 基于分代的思想进行设计，对堆内存进行了重新布局，把堆区划分成很多个大小相同的区域（Region），新、老年代也不再固定在某个区域了，每一个Region都可以根据运行情况的需要，扮演Eden、Survivor、老年代区域、或者Humongous区域。</p>
<p>可以通过 <code>-XX:G1HeapRegionSize=n</code> 来设置 Region 的大小，可以设定为 1M、2M、4M、8M、16M、32M（不能超过）。</p>
<p>大对象（超过了一个 Region 大小的 50%）会被存储到Humongous区域，G1大多数情况下会把这个区域当作老年代来看待。如果对象占用空间超过Region的容量，就会存放到N个连续的 Humongous Region 中。</p>
<p>G1 可以以增量方式执行垃圾回收，这意味着它不需要一次性回收整个堆空间，而是可以逐步、增量地清理。有助于控制停顿时间，尤其是在处理大型堆时。</p>
<p>G1 垃圾回收器可以并行回收垃圾，这意味着它可以利用多个 CPU 来加速垃圾回收的速度，这一特性在年轻代的垃圾回收（Minor GC）中特别明显，因为年轻代的回收通常涉及较多的对象和较高的回收速率。</p>
<p>在进行老年代的垃圾回收时，G1 使用标记-整理算法。</p>
<h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><p>大致分成四个步骤：</p>
<blockquote>
<p><strong>初始标记（Initial Marking）- Stop The World</strong></p>
<p>只标记 GC Roots 能直接关联的对象，还有一些额外的细节操作例如修改TAMS指针的值，保证后续阶段用户程序并发运行的时候，新对象分配在正确的位置。这个阶段需要暂停用户线程，但耗时很短。</p>
<p><strong>并发标记（Concurrent Marking）- No Stop The World</strong></p>
<p>从根节点（GC Root）开始，顺着引用链遍历整个堆，找出存活的对象。这个步骤耗时较长，但用户线程可以和GC线程并发执行。</p>
<p><strong>最终标记（Final Marking）- Stop The World</strong></p>
<p>处理并发标记阶段，用户线程继续运行产生的引用变动，这个阶段需要暂停用户线程，支持并行处理。</p>
<p><strong>筛选回收（Live Data Counting and Evacuation）- Stop The World</strong></p>
<p>根据以上三个阶段标记完成的数据，计算出各个Region的回收价值和成本，再根据用户期望的停顿时间来决定要回收多少个Region。回收使用的是复制算法，把需要回收的这些Region里存活的对象，复制到空闲的Region中，然后清理掉旧Region全部空间。因为需要移动存活的对象，所以不可避免的要暂停用户线程，这个步骤支持多条线程并行回收。</p>
</blockquote>
<h4 id="三种GC-模式"><a href="#三种GC-模式" class="headerlink" title="三种GC 模式"></a>三种GC 模式</h4><p>G1 中存在三种 GC 模式，分别是 Young GC、Mixed GC 和 Full GC。</p>
<p>当 Eden 区的内存空间无法支持新对象的内存分配时，G1 会触发 Young GC。</p>
<p>当需要分配对象到 Humongous 区域或者堆内存的空间占比超过 <code>-XX:G1HeapWastePercent</code> 设置的 InitiatingHeapOccupancyPercent 值时，G1 会触发一次 concurrent marking，它的作用就是计算老年代中有多少空间需要被回收，当发现垃圾的占比达到 <code>-XX:G1HeapWastePercent</code> 中所设置的 G1HeapWastePercent 比例时，在下次 Young GC 后会触发一次 Mixed GC。</p>
<p>Mixed GC 是指回收年轻代的 Region 以及一部分老年代中的 Region。Mixed GC 和 Young GC 一样，采用的也是复制算法。</p>
<p>在 Mixed GC 过程中，如果发现老年代空间还是不足，此时如果 G1HeapWastePercent 设定过低，可能引发 Full GC。<code>-XX:G1HeapWastePercent</code> 默认是 5，意味着只有 5% 的堆是“浪费”的。如果浪费的堆的百分比大于 G1HeapWastePercent，则运行 Full GC。</p>
<p>在以 Region 为最小管理单元以及所采用的 GC 模式的基础上，G1 建立了停顿预测模型，即 Pause Prediction Model 。这也是 G1 非常被人所称道的特性。</p>
<p>我们可以借助 <code>-XX:MaxGCPauseMillis</code> 来设置期望的停顿时间（默认 200ms），G1 会根据这个值来计算出一个合理的 Young GC 的回收时间，然后根据这个时间来制定 Young GC 的回收计划。</p>
<h4 id="G1是如何保证停顿时间可控的？"><a href="#G1是如何保证停顿时间可控的？" class="headerlink" title="G1是如何保证停顿时间可控的？"></a>G1是如何保证停顿时间可控的？</h4><p>首先G1把内存区域分成了若干个相同大小的 Region 区，在执行回收的时候，根据标记阶段统计到的数据，计算出各个 Region 区的回收价值和成本，有了这些数据之后，就可以计算出回收哪几个Region价值最高，且符合用户预期的停顿时间。</p>
<h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a><a href="https://javabetter.cn/jvm/gc-collector.html">ZGC</a></h3><p>JDK11 推出的一款低延迟垃圾收集器，适用于大内存低延迟服务的内存管理和回收，SPEC jbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。</p>
<p>ZGC 很强大，它的目标是：</p>
<blockquote>
<ul>
<li>停顿时间不超过 10ms；</li>
<li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li>
<li>支持 8MB~4TB 级别的堆，未来支持 16TB。</li>
</ul>
</blockquote>
<h4 id="G1的性能瓶颈（为什么ZGC能做到停顿时间如此短暂？"><a href="#G1的性能瓶颈（为什么ZGC能做到停顿时间如此短暂？" class="headerlink" title="G1的性能瓶颈（为什么ZGC能做到停顿时间如此短暂？)"></a>G1的性能瓶颈（为什么ZGC能做到停顿时间如此短暂？)</h4><p>前面讲 G1 垃圾收集器的时候提到过，Young GC 和 Mixed GC 均采用的是复制算法，复制算法主要包括以下 3 个阶段：</p>
<p>①、标记阶段，从 GC Roots 开始，分析对象可达性，标记出活跃对象。</p>
<p>②、对象转移阶段，把活跃对象复制到新的内存地址上。</p>
<p>③、重定位阶段，因为转移导致对象地址发生了变化，在重定位阶段，所有指向对象旧地址的引用都要调整到对象新的地址上。</p>
<p>标记阶段因为只标记 GC Roots，耗时较短。但转移阶段和重定位阶段需要处理所有存活的对象，耗时较长，并且转移阶段是 STW 的，因此，<strong>G1 的性能瓶颈就主要卡在转移阶段</strong>。</p>
<p>与 G1 和 CMS 类似，<strong>ZGC 也采用了复制算法，只不过做了重大优化，ZGC 在标记、转移和重定位阶段几乎都是并发的，这是 ZGC 实现停顿时间小于 10ms 的关键所在。</strong></p>
<h4 id="ZGC-是怎么做到的：指针染色-读屏障"><a href="#ZGC-是怎么做到的：指针染色-读屏障" class="headerlink" title="ZGC 是怎么做到的：指针染色 &amp; 读屏障"></a>ZGC 是怎么做到的：指针染色 &amp; 读屏障</h4><ul>
<li>指针染色（Colored Pointer）：一种用于标记对象状态的技术。</li>
<li>读屏障（Load Barrier）：一种在程序运行时插入到对象访问操作中的特殊检查，用于确保对象访问的正确性。</li>
</ul>
<p>这两种技术可以让所有线程在并发的条件下就指针的颜色 (状态) 达成一致，而不是对象地址。因此，ZGC 可以并发的复制对象，这大大的降低了 GC 的停顿时间。</p>
<blockquote>
<p><strong>指针染色（空间换时间）</strong></p>
<p>在一个指针中，除了存储对象的实际地址外，还有额外的位被用来存储关于该对象的元数据信息。这些信息可能包括：</p>
<ul>
<li>对象是否被移动了（即它是否在回收过程中被移动到了新的位置）。</li>
<li>对象的存活状态。</li>
<li>对象是否被锁定或有其他特殊状态。</li>
</ul>
<p>通过在指针中嵌入这些信息，ZGC 在标记和转移阶段会更快，因为通过指针上的颜色就能区分出对象状态，不用额外做内存访问。</p>
<p>ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间。</p>
<p><strong>读屏障</strong></p>
<p>当程序尝试读取一个对象时，读屏障会触发以下操作：</p>
<ul>
<li>检查指针染色：读屏障首先检查指向对象的指针的颜色信息。</li>
<li>处理移动的对象：如果指针表示对象已经被移动（例如，在垃圾回收过程中），读屏障将确保返回对象的新位置。</li>
<li>确保一致性：通过这种方式，ZGC 能够在并发移动对象时保持内存访问的一致性，从而减少对应用程序停顿的需要。</li>
</ul>
<p>读屏障可能被GC线程和业务线程触发，并且只会在访问堆内对象时触发，访问的对象位于GC Roots时不会触发，这也是扫描GC Roots时需要STW的原因。</p>
</blockquote>
<p>简化的示例代码，展示了读屏障的触发时机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> obj.FieldA   <span class="comment">// 从堆中读取引用，需要加入屏障</span></span><br><span class="line">&lt;Load barrier&gt;</span><br><span class="line"><span class="type">Object</span> <span class="variable">p</span> <span class="operator">=</span> o  <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line">o.dosomething() <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  obj.FieldB  <span class="comment">//无需加入屏障，因为不是对象引用</span></span><br></pre></td></tr></table></figure>

<h3 id="查看我的GC器"><a href="#查看我的GC器" class="headerlink" title="查看我的GC器"></a>查看我的GC器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;GarbageCollectorMXBean&gt; beans = ManagementFactory.getGarbageCollectorMXBeans();</span><br><span class="line"><span class="keyword">for</span> (GarbageCollectorMXBean bean : beans) &#123;System.out.println(bean.getName());&#125;</span><br></pre></td></tr></table></figure>

<p>我的结果：</p>
<blockquote>
<p>G1 Young Generation<br>G1 Concurrent GC<br>G1 Old Generation</p>
</blockquote>
<h2 id="分代垃圾回收策略"><a href="#分代垃圾回收策略" class="headerlink" title="分代垃圾回收策略"></a>分代垃圾回收策略</h2><p>JVM分代垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p>试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。</p>
<p>因此，分代垃圾回收<strong>采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上</strong>，不同代上采用最适合它的垃圾回收方式进行回收。</p>
<p>虚拟机中堆的共划分为三个代：年轻代(YoungGeneration)、年老代(OldGeneration)和<del>持久代(PermanentGeneration)</del>。年轻代和年老代对垃圾收集影响较大。</p>
<h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p>所有新生成的对象首先都是放在年轻代的。年轻代分三个区。一个Eden区(Eden Space伊甸园区)，两个Survivor区(Survivor Space 0 幸存者区0和 Survivor Space 1幸存者区1，也称为from区和to区)（默认8:1:1）。</p>
<p>大部分对象在Eden区中生成。当Eden空间不足时，触发Minor GC，存活下来的对象会被复制到From区，这时Eden区就干净了，Eden区可以继续创建新对象，再次满时，触发GC，将Eden区与From区还在被使用的对象复制到To区，再下一次GC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。经过若干次GC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是还没有被回收，就会被复制到老年代。「对于一些大的对象（指需要占用大量连续内存空间的对象）则直接进入到老年代。」</p>
<p><strong>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</strong></p>
<p>Survivor的两个区是对称的，没先后关系。Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的(多于两个)，这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p>
<p>由于新生代中的对象大多都是临时对象，死亡率较高，因此采用复制算法。在进行Minor GC时，会先标记出伊甸园区和其中一个幸存者区中的存活对象，并将它们复制到另一个幸存者区中，最后清空原来的两个区域。这样既能高效地回收大量死亡对象，又保持了内存的连续性。</p>
<h4 id="为什么要两块Survivor空间？"><a href="#为什么要两块Survivor空间？" class="headerlink" title="为什么要两块Survivor空间？"></a>为什么要两块Survivor空间？</h4><p>因为复制算法必须要有一块空间是空闲的。想象一下，如果只有一块Eden空间 + 一块Survivor空间。当GC回收完成后，Eden中存活的对象会移动到Survivor空间。程序继续运行，新的对象又会进入Eden空间，此时就会出现 Eden 和 Survivor 空间里都有对象，复制算法也就进行不下去了。</p>
<h3 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a>年老代</h3><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
<p>老年代中的对象生命周期更长，存活率高，不适合频繁地进行复制操作。因此，在老年代上一般采用标记-清除或者标记-压缩算法。</p>
<h3 id="跨代引用的问题"><a href="#跨代引用的问题" class="headerlink" title="跨代引用的问题"></a>跨代引用的问题</h3><p>举个例子，新生代中的对象很有可能会被老年代里的对象所引用，当新生代触发GC的时候，只搜索新生代的区域明显是不够的，还得搜索老年代的对象是否引用了新生代中非 GC Roots 引用链上的对象，来确保正确性。但这样做会带来很大的性能开销。为了解决这个问题，Java定义了一种名为记忆集的抽象的数据结构，用于记录存在跨区域引用的对象指针集合。</p>
<p>大多数的虚拟机，都采用一种名为<strong>卡表（Card Table）</strong>的方式去实现记忆集，卡表由一个数组构成，每一个元素都对应着一块特定大小的内存区域，这块内存区域被称之为卡页（Card Page），每一个卡页，可能会包含N个存在跨区域引用的对象，只要存在跨区域引用的对象，这个卡页就会被标识为1。当GC发生的时候，就不需要扫描整个区域了，只需要把这些被标识为1的卡页加入对应区域的 GC Roots 里一起扫描即可。</p>
<h1 id="JVM之对象的生命周期"><a href="#JVM之对象的生命周期" class="headerlink" title="JVM之对象的生命周期"></a>JVM之对象的生命周期</h1><p>在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段：创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）。</p>
<h2 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h2><p>在对象创建阶段，系统要通过下面的步骤，完成对象的创建过程：</p>
<blockquote>
<ol>
<li><p>为对象分配存储空间。</p>
</li>
<li><p>开始构造对象。</p>
</li>
<li><p>递归调用其超类的构造方法。</p>
</li>
<li><p>进行对象实例初始化与变量初始化。</p>
</li>
<li><p>执行构造方法体。</p>
</li>
</ol>
</blockquote>
<p>在创建对象时，我们应该遵循一些基本的规则，以提高应用的性能：</p>
<blockquote>
<ol>
<li><p>避免在循环体中创建对象，即使该对象占用内存空间不大。</p>
</li>
<li><p>尽量及时使对象符合垃圾回收标准。</p>
</li>
<li><p>不要采用过深的继承层次。</p>
</li>
<li><p>访问本地变量优于访问类中的变量。</p>
</li>
</ol>
</blockquote>
<h2 id="应用阶段"><a href="#应用阶段" class="headerlink" title="应用阶段"></a>应用阶段</h2><p>在这个阶段，对象具备下列特征：</p>
<ul>
<li>系统至少维护着对象的一个强引用（StrongReference）</li>
<li>所有对该对象的引用全部是强引用（除非我们显式地使用了：软引用（SoftReference）、弱引用（WeakReference）或虚引用（PhantomReference））</li>
</ul>
<h3 id="强引用-StrongReference"><a href="#强引用-StrongReference" class="headerlink" title="强引用(StrongReference)"></a>强引用(StrongReference)</h3><p>指JVM内存管理器从根引用集合（RootSet）出发遍寻堆中所有到达对象的路径。当到达某对象的任意路径都不含有引用对象时，对这个对象的引用就被称为强引用。</p>
<h3 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用(SoftReference)"></a>软引用(SoftReference)</h3><p>具有较强的引用功能。只有当内存不够的时候，才回收这类内存，因此在内存足够的时候，它们通常不被回收。另外，这些引用对象还能保证在Java抛出OutOfMemory异常之前，被设置为null。</p>
<p>它可以用于实现一些常用资源的缓存，实现Cache的功能，保证最大限度的使用内存而不引起OutOfMemory。再者，<strong>软可到达对象的所有软引用都要保证在虚拟机抛出OutOfMemoryError之前已经被清除</strong>。否则，清除软引用的时间或者清除不同对象的一组此类引用的顺序将不受任何约束。然而，虚拟机实现不鼓励清除最近访问或使用过的软引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//使用a</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//使用完了a,将它设置为soft引用类型并释放强引用</span></span><br><span class="line"><span class="type">SoftReference</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(a);</span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//下次使用时</span></span><br><span class="line"><span class="keyword">if</span>(sr != <span class="literal">null</span>)&#123;</span><br><span class="line">	a = sr.get();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//GC由于内存资源不足可能已经回收了</span></span><br><span class="line">	a = <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">	sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>软引用技术的引进，使Java应用可以更好地管理内存，稳定系统，防止系统内存溢出，避免系统崩溃（crash）。因此在处理一些占用内存较大而且声明周期较长，但使用并不频繁的对象时应尽量应用该技术。但是在某些时候对软引用的使用会降低应用的运行效率与性能。</p>
<h3 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h3><p>与Soft引用对象的最大不同就在于：GC在进行回收时，需要通过算法检查是否回收Soft引用对象，而对于Weak引用对象，GC总是进行回收。因此Weak引用对象会更容易、更快被GC回收。虽然GC在运行时一定回收Weak引用对象，但是复杂关系的Weak对象群常常需要好几次GC的运行才能完成。</p>
<p>Weak引用对象常常用于Map数据结构中，引用占用内存空间较大的对象，一旦该对象的强引用为null时，对这个对象引用就不存在了，GC能够快速地回收该对象空间。</p>
<p>弱引用技术主要适用于实现无法防止其键（或值）被回收的规范化映射。另外，弱引用分为“短弱引用（ShortWeekReference）”和“长弱引用（LongWeekReference）”，其区别是长弱引用在对象的Finalize方法被GC调用后依然追踪对象。基于安全考虑，不推荐使用长弱引用。</p>
<h3 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用(PhantomReference)"></a>虚引用(PhantomReference)</h3><p>用途较少，主要用于辅助finalize函数的使用。Phantom对象指一些执行完了finalize函数，并且为不可达对象，但是还没有被GC回收的对象。这种对象可以辅助finalize进行一些后期的回收工作，我们通过覆盖Reference的clear()方法，增强资源回收机制的灵活性。虚引用主要适用于以某种比java终结机制更灵活的方式调度pre-mortem清除操作。</p>
<p>在实际程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出等问题的产生</strong>。</p>
<h2 id="不可视阶段"><a href="#不可视阶段" class="headerlink" title="不可视阶段"></a>不可视阶段</h2><p>在一个对象经历了应用阶段之后，那么该对象便处于JVM对象生命周期的不可视阶段，说明我们在其他区域的代码中已经不可以再引用它，其强引用已经消失。</p>
<h2 id="不可到达阶段"><a href="#不可到达阶段" class="headerlink" title="不可到达阶段"></a>不可到达阶段</h2><p>处于JVM对象生命周期不可到达阶段的对象，在虚拟机所管理的对象引用根集合中再也找不到直接或间接的强引用，这些对象通常是指所有线程栈中的临时变量，所有已装载的类的静态变量或者对本地代码接口（JNI）的引用。这些对象都是要被垃圾回收器回收的预备对象，但此时该对象并不能被垃圾回收器直接回收。其实所有垃圾回收算法所面临的问题是相同的——找出由分配器分配的，但是用户程序不可到达的内存块。</p>
<h2 id="可收集阶段、终结阶段与释放阶段"><a href="#可收集阶段、终结阶段与释放阶段" class="headerlink" title="可收集阶段、终结阶段与释放阶段"></a>可收集阶段、终结阶段与释放阶段</h2><p>JVM对象生命周期的最后一个阶段是可收集阶段、终结阶段与释放阶段。当对象处于这个阶段的时候，可能处于下面三种情况：</p>
<blockquote>
<p>（1）垃圾回收器发现该对象已经不可到达。</p>
<p>（2）finalize方法已经被执行。</p>
<p>（3）对象空间已被重用。</p>
</blockquote>
<p>当对象处于上面的三种情况时，该对象就处于可收集阶段、终结阶段与释放阶段了。虚拟机就可以直接将该对象回收了。</p>
<h1 id="Q-A"><a href="#Q-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h1><h2 id="为什么老年代不使用和新生代一样的标记-复制算法呢？"><a href="#为什么老年代不使用和新生代一样的标记-复制算法呢？" class="headerlink" title="为什么老年代不使用和新生代一样的标记-复制算法呢？"></a>为什么老年代不使用和新生代一样的标记-复制算法呢？</h2><blockquote>
<p>新生代里绝大多数对象都是朝生夕死的，使用的标记-复制算法，空间占比可以8 : 1 : 1，但是老年代里对象存活率很高，这个占比明显不合适。</p>
<p>如果占比得设置得大 (例如50%)，又会浪费很多内存空间，而且由于对象很多都是存活的，复制移动也是一笔开销。所以标记-复制这个算法，不适合老年代这种对象存活率很高的区域。</p>
</blockquote>
<h2 id="标记-整理（压缩）算法，每次整理都消耗大量时间，能不能优化一下？"><a href="#标记-整理（压缩）算法，每次整理都消耗大量时间，能不能优化一下？" class="headerlink" title="标记-整理（压缩）算法，每次整理都消耗大量时间，能不能优化一下？"></a>标记-整理（压缩）算法，每次整理都消耗大量时间，能不能优化一下？</h2><blockquote>
<p>可以通过设置一个阈值或者临界点，当内存碎片化程度还在这个阈值范围内的时候，仅采用标记-清除算法。只有超过这个阈值，才进行整理。</p>
</blockquote>
<h2 id="什么是内存碎片？它会带来什么问题？"><a href="#什么是内存碎片？它会带来什么问题？" class="headerlink" title="什么是内存碎片？它会带来什么问题？"></a>什么是内存碎片？它会带来什么问题？</h2><blockquote>
<p>回收完成后，会产生很多不连续的内存空间，这就是内存碎片。</p>
<p>Java虚拟机对于大对象（例如很长的字符串、byte数组等等），都必须存储在连续的内存空间里，当一个大对象需要进入某个内存空间时，由于内存碎片过多，虽然剩余内存是远大于这个对象所需空间的，但就是找不到一块连续的内存空间来存储它，这会导致提前触发一次Full GC。</p>
</blockquote>
<h2 id="CPU飙高排查方案与思路？"><a href="#CPU飙高排查方案与思路？" class="headerlink" title="CPU飙高排查方案与思路？"></a>CPU飙高排查方案与思路？</h2><blockquote>
<ol>
<li><p>执行top命令：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。</p>
</li>
<li><p>执行top -Hp 进程号命令：查看java进程下的所有线程占CPU的情况。</p>
</li>
<li><p>执行“printf “%x\n 10”命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如，打印：a，那么在jstack中线程号就是0xa.</p>
</li>
<li><p>执行 “jstack 进程号 | grep 线程ID” 查找某进程下线程ID（jstack堆栈信息中的nid）&#x3D;0xa的线程状态。如果“”VM Thread” os_prio&#x3D;0 tid&#x3D;0x00007f871806e000 nid&#x3D;0xa runnable”，第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程了</p>
</li>
<li><p>执行“jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计）”，查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大，确认Full GC! 也可以使用“jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。</p>
</li>
<li><p>执行“jmap -dump:format&#x3D;b,file&#x3D;filename 进程ID”，导出某进程下内存heap输出到文件中。</p>
</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>GC</tag>
        <tag>JVM</tag>
        <tag>字节码</tag>
        <tag>类的加载</tag>
        <tag>常量池</tag>
        <tag>对象的生命周期</tag>
        <tag>反编译</tag>
        <tag>面试题</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶题</title>
    <url>/posts/f8ab35c0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/assets/img/09.jpg" alt="图片" title="hi"></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2122308127&auto=0&height=66"></iframe>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于我没有系统的学习前端三件套，只是了解一点，所以下面的部分解释可能并不正确。</p>
<h1 id="闭包代码的提权漏洞"><a href="#闭包代码的提权漏洞" class="headerlink" title="闭包代码的提权漏洞"></a>闭包代码的提权漏洞</h1><p>看这样一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = (</span><br><span class="line">    <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = &#123;</span><br><span class="line">            <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">k</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj[k];</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure>

<p>现在要求在不修改上面代码的情况下修改obj对象，该怎么做？</p>
<span id="more"></span>

<p>先看一下这个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="title function_">get</span>(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="title function_">get</span>(<span class="string">&#x27;sb&#x27;</span>)); <span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="title function_">get</span>(<span class="string">&#x27;valueOf&#x27;</span>)); <span class="comment">//[Function: valueOf]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="title function_">get</span>(<span class="string">&#x27;valueOf&#x27;</span>)());<span class="comment">//这里会报错：Cannot convert undefined or null to object，实际上是this指向的问题</span></span><br></pre></td></tr></table></figure>

<p>我们会发现 obj实际上继承了 Object.prototype.valueOf，所以可以用原型修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(Object.prototype, &#x27;hack&#x27;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里用原型新增了一个属性hack，然后就可以修改了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> v = o.<span class="title function_">get</span>(<span class="string">&#x27;hack&#x27;</span>);<span class="comment">//这里可以打印一下v看看：&#123; a: 1, b: 2 &#125;</span></span><br><span class="line">v.<span class="property">a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="title function_">get</span>(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//10，成功</span></span><br></pre></td></tr></table></figure>

<p>那么该如何防御呢？</p>
<p>将obj的原型设置为null，在源代码中加上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>或者在function里加上一个判断：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(k)) &#123;<span class="keyword">return</span> obj[k];&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架</title>
    <url>/posts/62d904b9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/assets/img/12.jpg" alt="桌面图片" title="森林"></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2041899354&auto=0&height=66"></iframe>

<h1 id="Spring核心"><a href="#Spring核心" class="headerlink" title="Spring核心"></a>Spring核心</h1><h2 id="Spring的关键策略"><a href="#Spring的关键策略" class="headerlink" title="Spring的关键策略"></a>Spring的关键策略</h2><p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略:</p>
<blockquote>
<p>基于POJO的轻量级和最小侵入性编程；</p>
<p>通过依赖注入和面向接口实现松耦合；</p>
<p>基于切面和惯例进行声明式编程；</p>
<p>通过切面和模板减少样板式代码。</p>
</blockquote>
<p>几乎Spring所做的任何事情都可以追溯到上述的一条或多条策略。</p>
<span id="more"></span>

<h2 id="部分概念"><a href="#部分概念" class="headerlink" title="部分概念"></a>部分概念</h2><h3 id="POJO-Plain-Ordinary-Java-Object"><a href="#POJO-Plain-Ordinary-Java-Object" class="headerlink" title="POJO(Plain Ordinary Java Object )"></a>POJO(Plain Ordinary Java Object )</h3><p>简单Java对象，又普通又老的对象。</p>
<p>POJO的内在含义是指：那些没有继承任何类、也没有实现任何接口，更没有被其它框架侵入的java对象。</p>
<p>它仅包含自身的属性以及自身属性的getter和setter方法，这意味者POJO可以方便的从一个框架迁移到另一个框架中，或者框架升级也会对代码毫无影响，因此而得到复用。</p>
<p>Spring竭力避免因自身的API而弄乱你的应用代码。Spring不会强迫你实现Spring规范的接口或继承Spring规范的类，相反，在基于Spring构建的应用中，它的类通常没有任何痕迹表明你使用了Spring。最坏的场景是，一个类或许会使用Spring注解，但它依旧是POJO。</p>
<p>Spring通过DI来装配POJO。</p>
<h3 id="PO-Persistence-Object"><a href="#PO-Persistence-Object" class="headerlink" title="PO(Persistence Object )"></a>PO(Persistence Object )</h3><p>持久层对象，对象字段持有的数据需要被持久化到数据表中，参与到持久化操作的对象就被称为持久化对象。</p>
<p>面对不同的数据源时，PO是DAO层为进行持久化操作而准备的对象。</p>
<blockquote>
<p>DAO层则负责与数据源进行交互，执行持久化操作，包括保存、更新、删除等。</p>
</blockquote>
<p>PO是在ORM（对象关系映射）中与数据表的一条记录相匹配，自身属性与数据表字段一一对应。可以将数据表中的一条记录作为一个对象处理，并可以转化为其它对象。</p>
<p>包含getter、setter方法；一般不包含业务逻辑与数据库的访问方法；PO平常不一定需要实现序列化，只是当采用分布式存储或者需要作为前端输出及远程调用使用时，应该实现序列化。</p>
<p>在《阿里巴巴开发手册》中，PO也叫DO（Data Object）数据对象，与数据库表结构一一对应，通过DAO层向上传输数据源对象。</p>
<h3 id="DAO-Data-Access-Object-层"><a href="#DAO-Data-Access-Object-层" class="headerlink" title="DAO(Data Access Object)层"></a>DAO(Data Access Object)层</h3><p>数据访问对象，DAO模型就是写一个类，把访问数据库的代码封装起来，DAO在数据库与业务逻辑（Service）之间。</p>
<p>DAO的作用是封装对数据库的访问：增删改查，不涉及业务逻辑，只是达到按某个条件获得指定数据的要求。</p>
<h3 id="DTO-Data-Transfer-Object"><a href="#DTO-Data-Transfer-Object" class="headerlink" title="DTO(Data Transfer Object)"></a>DTO(Data Transfer Object)</h3><p> 数据传输对象，在应用网络层需要传输的对象，是一个为了减少方法调用次数而在进程间传输数据的对象。</p>
<p>在《阿里巴巴开发手册中》规定是Service 或 Manager 向外传输的对象。</p>
<blockquote>
<p>DTO模式诞生的背景是分布式通信。</p>
<p>考虑到网络传输的损耗与不可靠性，设计分布式服务需遵循一个总体原则：尽可能设计粗粒度的服务，每个服务的方法应代表一个完整的功能，而不是功能的一个步骤。粗粒度服务可以减少服务调用的次数，从而减少不必要的网络通信，同时也能避免对分布式事务的支持。</p>
</blockquote>
<h4 id="DTO详解"><a href="#DTO详解" class="headerlink" title="DTO详解"></a>DTO详解</h4><p>从输入来看，在进行请求时，应用在接口接收传入对象，然后又转换成实体进行持久化。在此过程中，传入的对象就是DTO。</p>
<p>它的命名方式可能是Param、Query 、Command等。Param 为查询参数对象，适用于各层，一般用做接受前端参数对象。Param 和 Query 的出现是为了不使用 Map 做为接收参数的对象。</p>
<p>从输出来看，在进行返回响应时，若数据表有100个字段，那么PO中就有100个属性，而界面可能只需要其中10个属性，那么查询数据库后，对象就需要由PO转化成DTO。</p>
<p>DTO可能还需要组合多个表查询到的对象成为一个大对象，以便减少网络的调用，或者给前端传输一些不在数据库中查到的属性，所以需要添加属性。</p>
<p>一般不建议创建DTO，因为里面就一些属性和getter、setter方法，业务价值小，作用仅仅是在一次调用中传输几部分信息。</p>
<p>其中，属性必须为原始数据类型，因为DTO需要被序列化以便能在连接中传播。它只包含自身数据的存储，而不包含业务逻辑。</p>
<p>在不同的客户端之间，通常需要<strong>DTO组装器</strong>完成领域对象和DTO之间的转化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DTOAssembler</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> DTO <span class="title function_">createDTO</span><span class="params">(DO domainObject)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDO</span><span class="params">(DTO  dataTransferObject)</span>;</span><br><span class="line">	<span class="keyword">public</span> DO <span class="title function_">createDO</span><span class="params">(DTO  dataTransferObject)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VO-value-object）"><a href="#VO-value-object）" class="headerlink" title="VO(value object）"></a>VO(value object）</h3><p>值对象，通常用于业务层之间的数据传递，仅仅包含自身的数据。</p>
<p>值对象通常是小而简单的对象，判断相等时不根据标识ID；值对象易于创建，参数传递时通常是传递值，而不是传递引用；值对象不应被持久化，这个对象被创建后只能被引用，当没有引用时交给垃圾回收自动处理。</p>
<h3 id="BO-business-object"><a href="#BO-business-object" class="headerlink" title="BO(business object)"></a>BO(business object)</h3><p>业务对象，就是把业务逻辑封装为一个对象，这个业务对象可以包括一个或多个其它的对象。</p>
<p>业务对象（BO）通常是<strong>实体</strong>，或者是<strong>聚合根</strong>，包含多个实体或值对象，内部实现业务逻辑。</p>
<h3 id="Entity层"><a href="#Entity层" class="headerlink" title="Entity层"></a>Entity层</h3><p>放一个个实体的层。</p>
<p>实体需要给予一个唯一标识，以区分其它实体；实体应该有一个生命周期，是有状态的。</p>
<p>如果想要对数据库进行一些操作的话，就要先写entity层。</p>
<h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><p>业务逻辑层，它处理逻辑上的业务，而不去考虑具体的实现。</p>
<h3 id="Servlet层"><a href="#Servlet层" class="headerlink" title="Servlet层"></a>Servlet层</h3><p>小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。</p>
<h4 id="Servlet实现过程"><a href="#Servlet实现过程" class="headerlink" title="Servlet实现过程"></a>Servlet实现过程</h4><blockquote>
<ol>
<li>客户端发送请求至服务器端；</li>
<li>服务器将请求信息发送至 Servlet；</li>
<li>Servlet 生成响应内容并将其传给服务器。响应内容动态生成，通常取决于客户端的请求；</li>
<li>服务器将响应返回给客户端。</li>
</ol>
</blockquote>
<h4 id="Servlet完成的任务"><a href="#Servlet完成的任务" class="headerlink" title="Servlet完成的任务"></a>Servlet完成的任务</h4><blockquote>
<ol>
<li>动态生成HTML文档；</li>
<li>将请求转发给Servlet组件；</li>
<li>读取客户端的Cookie，以及向客户端写入Cookie；</li>
<li>访问服务器的资源，如数据库、 XML、文件对像等。</li>
</ol>
</blockquote>
<h4 id="Servlet的特点"><a href="#Servlet的特点" class="headerlink" title="Servlet的特点"></a>Servlet的特点</h4><blockquote>
<ol>
<li>Servlet对像，由Servlet容器（Tomcat）创建；</li>
<li>Servlet是一个接口：位于javax.servlet包中;</li>
<li>service方法用于接收用户的请求并返回响应;</li>
<li>用户访问时多次被执行（可以统计网站的访问量）。</li>
</ol>
</blockquote>
<h3 id="Utils层"><a href="#Utils层" class="headerlink" title="Utils层"></a>Utils层</h3><p>Utiliy的缩写，是一个多功能、基于工具的包。如字符串处理、日期处理等，(建立数据库之间的连接），是通用的、与业务无关的，可以独立出来，可供其他项目使用。</p>
<h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><p>Controller负责请求转发，接受页面过来的参数，传给Service处理，接到返回值，再传给页面。</p>
<h2 id="IOC（Inversion-of-Control）"><a href="#IOC（Inversion-of-Control）" class="headerlink" title="IOC（Inversion of Control）"></a>IOC（Inversion of Control）</h2><p>IoC：控制反转，对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p>
<p>控制反转指的是由开发者来控制创建对象变成了由Spring容器来控制创建对象，创建对象和销毁对象的过程都由Spring来控制。以Spring框架为开发基础的应用尽量不要自己创建对象，应全部交由Spring容器管理。</p>
<p>Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。</p>
<p>Spring 容器使用DI来管理组成一个应用程序的组件，这些对象被称为 Spring Beans。</p>
<p>通过阅读配置元数据提供的指令，容器知道对哪些对象进行实例化，配置和组装。配置元数据可以通过 XML，Java 注释或 Java 代码来表示。</p>
<p>IoC 容器利用 Java 的 POJO 类和配置元数据来生成完全配置和可执行的系统或应用程序。</p>
<p>IoC容器负责实例化，配置和组装对象。 IoC容器从XML文件获取信息并相应地工作。</p>
<h3 id="BeanFactory-ApplicationContext"><a href="#BeanFactory-ApplicationContext" class="headerlink" title="BeanFactory &amp; ApplicationContext"></a>BeanFactory &amp; ApplicationContext</h3><p>Spring 提供了两种不同类型的IoC容器：</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="left">容器 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">BeanFactory ，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略（lazy-load）。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">ApplicationContext ，在BeanFactory的基础上构建，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等，ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</td>
</tr>
</tbody></table>
<p>ApplicationContext接口建立在BeanFactory接口的顶部，它比BeanFactory增加了一些额外的功能，例如与Spring的AOP的简单集成，消息资源处理(用于I18N)，事件传播，Web应用程序的特定于应用程序层的上下文(例如WebApplicationContext)。</p>
<p>BeanFactory 仍可用于轻量级的应用程序，如移动设备或基于 applet 的应用程序。</p>
<p>无论使用哪个容器，我们都需要通过某种方法告诉容器关于对象依赖的信息，只有这样，容器才能合理地创造出对象。</p>
<h4 id="BeanFactory使用示例"><a href="#BeanFactory使用示例" class="headerlink" title="BeanFactory使用示例"></a>BeanFactory使用示例</h4><p>XmlBeanFactory是BeanFactory接口的实现类。要使用BeanFactory，我们需要创建XmlBeanFactory类的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource resource=<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">BeanFactory factory=<span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resource);</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<p>HelloWorld.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String message;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.message  = message;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Your Message : &quot;</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MainApp.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">XmlBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;xxxx.xml&quot;</span>));</span><br><span class="line">      <span class="type">HelloWorld</span> <span class="variable">obj</span> <span class="operator">=</span> (HelloWorld) factory.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">      obj.getMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ApplicationContext使用示例"><a href="#ApplicationContext使用示例" class="headerlink" title="ApplicationContext使用示例"></a>ApplicationContext使用示例</h4><p>ClassPathXmlApplicationContext类是ApplicationContext接口的实现类。我们需要实例化ClassPathXmlApplicationContext类以使用ApplicationContext：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>ClassPathXmlApplicationContext类的构造函数接收字符串，因此我们可以传递xml文件的名称来创建ApplicationContext的实例。</p>
<h5 id="最常被使用的-ApplicationContext-接口实现"><a href="#最常被使用的-ApplicationContext-接口实现" class="headerlink" title="最常被使用的 ApplicationContext 接口实现"></a>最常被使用的 ApplicationContext 接口实现</h5><blockquote>
<p><strong>FileSystemXmlApplicationContext</strong>：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径。</p>
<p><strong>ClassPathXmlApplicationContext</strong>：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。</p>
<p><strong>XmlWebApplicationContext</strong>：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。</p>
</blockquote>
<h3 id="IOC配置的三种方式"><a href="#IOC配置的三种方式" class="headerlink" title="IOC配置的三种方式"></a>IOC配置的三种方式</h3><h4 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h4><p>将bean的信息配置.xml文件里，通过Spring加载文件为我们创建bean。这种方式出现很多早前的SSM项目中，将第三方类库或者一些配置工具类都以这种方式进行配置，主要原因是由于第三方类不支持Spring注解。</p>
<p>可以使用于任何场景，结构清晰，通俗易懂；配置繁琐，不易维护，枯燥无味，扩展性差。</p>
<p>举例：</p>
<p>声明命名空间和配置bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="java配置"><a href="#java配置" class="headerlink" title="java配置"></a>java配置</h4><p>将类的创建交给我们配置的JavcConfig类来完成，Spring只负责维护和管理，采用纯Java创建方式。其本质上就是把在XML上的配置声明转移到Java配置类中。</p>
<p>适用于任何场景，配置方便，因为是纯Java代码，扩展性高，十分灵活；由于是采用Java类的方式，声明不明显，如果大量配置，可读性比较差。</p>
<p>举例：</p>
<ol>
<li>创建一个配置类， 添加@Configuration注解声明为配置类</li>
<li>创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDaoImpl <span class="title function_">userDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userService&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserServiceImpl <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        userService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><p>通过在类上加注解的方式，来声明一个类交给Spring管理，Spring会自动扫描带有@Component，@Controller，@Service，@Repository这四个注解的类，然后帮我们创建并管理，前提是需要先配置Spring的注解扫描器。</p>
<p>开发便捷，通俗易懂，方便维护；具有局限性，对于一些第三方资源，无法添加注解。</p>
<p>举例：</p>
<ol>
<li>对类添加@Component相关的注解，比如@Controller，@Service，@Repository</li>
<li>设置ComponentScan的basePackage, 比如<code>&lt;context:component-scan base-package=&#39;tech.pdai.springframework&#39;&gt;</code>, 或者<code>@ComponentScan(&quot;tech.pdai.springframework&quot;)</code>注解，或者 <code>new AnnotationConfigApplicationContext(&quot;tech.pdai.springframework&quot;)</code>指定扫描的basePackage.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * user dao impl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDaoImpl userDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find user list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findUserList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖注入-Dependency-Injection-DI"><a href="#依赖注入-Dependency-Injection-DI" class="headerlink" title="依赖注入(Dependency Injection,DI)"></a>依赖注入(Dependency Injection,DI)</h2><p>在Java程序中，类与类之间的耦合非常频繁，如Class A需要依赖Class B的对象b。</p>
<p>而基于Spring框架的开发，在Class A中不需要显式地使用new关键字新建一个对象b，只需在对象b的声明之上加一行注解@Autowired，这样在Class A用到b时，Spring容器会主动完成对象b的创建和注入。</p>
<p>比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。</p>
<p>通过上面的解释，我们可以发现IoC和DI其实是同一概念从不同角度的解释。</p>
<h3 id="DI是如何实现的"><a href="#DI是如何实现的" class="headerlink" title="DI是如何实现的"></a>DI是如何实现的</h3><p>反射机制，它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p>
<h3 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h3><p>构造方法注入、setter方法注入、<del>接口注入</del>（带有侵入性）。</p>
<blockquote>
<p><strong>构造方法注入</strong>：优点是，对象在构造完成之后即已进入就绪状态，可以马上使用。缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。</p>
<p><strong>setter方法注入</strong>：因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。 另外，setter方法可以被继承，允许设置默认值。缺点当然就是对象无法在构造完成后马上进入就绪状态。</p>
</blockquote>
<h4 id="setter方式"><a href="#setter方式" class="headerlink" title="setter方式"></a>setter方式</h4><h5 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h5><p>在XML配置方式中，property都是setter方式注入，比如下面的xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>本质上包含两步：</p>
<ol>
<li>第一步，需要new UserServiceImpl()创建对象, 所以需要默认构造函数</li>
<li>第二步，调用setUserDao()函数注入userDao的值, 所以需要setUserDao()函数</li>
</ol>
<h5 id="注解和Java配置"><a href="#注解和Java配置" class="headerlink" title="注解和Java配置"></a>注解和Java配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDaoImpl userDao;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userDao.findUserList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDaoImpl userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><h5 id="xml配置-1"><a href="#xml配置-1" class="headerlink" title="xml配置"></a>xml配置</h5><p><code>&lt;constructor-arg&gt;</code>是通过构造函数参数注入，比如下面的xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>本质上是new UserServiceImpl(userDao)创建对象</p>
<h5 id="注解和Java配置-1"><a href="#注解和Java配置-1" class="headerlink" title="注解和Java配置"></a>注解和Java配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDaoImpl userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(<span class="keyword">final</span> UserDaoImpl userDaoImpl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDaoImpl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUserList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userDao.findUserList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p>自动注入注解，修饰符有三个属性：Constructor，byType，byName。默认按照byType注入。</p>
<blockquote>
<p><strong>constructor</strong>：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到多参数的构造方法中。</p>
<p><strong>byName</strong>：被注入bean的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。</p>
<p><strong>byType</strong>：查找所有的set方法，将符合符合参数类型的bean注入。</p>
</blockquote>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Autowired注解源码上看，可以使用在下面这些地方：</p>
<blockquote>
<p>@Target(ElementType.CONSTRUCTOR) #构造函数<br>@Target(ElementType.METHOD) #方法<br>@Target(ElementType.PARAMETER) #方法参数<br>@Target(ElementType.FIELD) #字段、枚举的常量<br>@Target(ElementType.ANNOTATION_TYPE) #注解</p>
</blockquote>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li><p>@Autowired是Spring自带的注解，通过AutowiredAnnotationBeanPostProcessor 类实现的依赖注入</p>
</li>
<li><p>@Autowired可以作用在CONSTRUCTOR、METHOD、PARAMETER、FIELD、ANNOTATION_TYPE</p>
</li>
<li><p>@Autowired默认是根据类型（byType）进行自动装配的</p>
</li>
<li><p>如果有多个类型一样的Bean候选者，需要指定按照名称（byName ）进行装配，则需要配合@Qualifier。</p>
</li>
<li><p>指定名称后，如果Spring IOC容器中没有对应的组件bean抛出NoSuchBeanDefinitionException。也可以将@Autowired中required配置为false，如果配置为false之后，当没有找到相应bean的时候，系统不会抛异常</p>
</li>
</ol>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>在字段属性上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br><span class="line"><span class="keyword">public</span> HelloDao <span class="title function_">getHelloDao</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> helloDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHelloDao</span><span class="params">(HelloDao helloDao)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.helloDao = helloDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br><span class="line"><span class="comment">//@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HelloServiceImpl</span><span class="params">(<span class="meta">@Autowired</span> HelloDao helloDao)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.helloDao = helloDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造器注入也可不写@Autowired，也可以注入成功。</span></span><br></pre></td></tr></table></figure>

<p>将@Autowired写在被注入的成员变量上，setter或者构造器上，就不用在xml文件中配置了。</p>
<h5 id="结合-Qualifier"><a href="#结合-Qualifier" class="headerlink" title="结合@Qualifier"></a>结合@Qualifier</h5><p>如果有多个类型一样的Bean候选者，则默认根据设定的属性名称进行获取。比如 HelloDao 在Spring中有 helloWorldDao 和 helloDao 两个Bean候选者，首先根据类型获取，发现多个HelloDao，然后根据helloDao进行获取，如果要获取限定的其中一个候选者，结合@Qualifier进行注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;helloWorldDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br></pre></td></tr></table></figure>

<p>使用@Qualifier 时候，如果设置的指定名称的Bean不存在，则会抛出异常，如果防止抛出异常，可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Qualifier(&quot;xxxxyyyy&quot;)</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br></pre></td></tr></table></figure>

<h5 id="结合-Bean"><a href="#结合-Bean" class="headerlink" title="结合@Bean"></a>结合@Bean</h5><p>在SpringBoot中也可以使用@Bean+@Autowired进行组件注入，将@Autowired加到参数上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">getPerson</span><span class="params">(<span class="meta">@Autowired</span> Car car)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;	<span class="comment">// @Autowired 其实也可以省略</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>IoC</tag>
        <tag>依赖注入</tag>
        <tag>Autowired</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile &amp; 内存屏障</title>
    <url>/posts/e41b8b68/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/assets/img/07.jpg" alt="壁纸" title="好看"></p>
<p>[TOC]</p>
<h1 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h1><p>volatile通过内存屏障(Memory Barrier)实现其在内存中的语义，即可见性和禁止重排优化。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中；</p>
<span id="more"></span>

<p>当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量。</p>
<p>所以，volatile变量的修改对其他线程立即可见。</p>
<h2 id="禁止重排优化"><a href="#禁止重排优化" class="headerlink" title="禁止重排优化"></a>禁止重排优化</h2><p>由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说<strong>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</strong>。Memory Barrier的另外一个作用是<strong>强制刷出各种CPU的缓存数据</strong>，因此任何CPU上的线程都能读取到这些数据的最新版本。</p>
<h2 id="基于保守策略的JMM内存屏障插入策略"><a href="#基于保守策略的JMM内存屏障插入策略" class="headerlink" title="基于保守策略的JMM内存屏障插入策略"></a>基于保守策略的JMM内存屏障插入策略</h2><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障。</p>
<p>具体策略如下：</p>
<blockquote>
<ul>
<li>在每个volatile写操作前插入一个StoreStore屏障；</li>
<li>在每个volatile写操作后插入一个StoreLoad屏障；</li>
<li>在每个volatile读操作后插入一个LoadLoad屏障；</li>
<li>在每个volatile读操作后插入一个LoadStore屏障。</li>
</ul>
</blockquote>
<p>并且遵循这样的规则：</p>
<blockquote>
<ol>
<li><p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</p>
</li>
<li><p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p>
</li>
<li><p>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p>
</li>
</ol>
</blockquote>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="volatile的典型应用场景：单例模式"><a href="#volatile的典型应用场景：单例模式" class="headerlink" title="volatile的典型应用场景：单例模式"></a>volatile的典型应用场景：单例模式</h3><p>单例模式的对象，可以被volatile修饰从而避免重排序。</p>
<p>下面给出懒汉式单例模式的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new对象的过程中，<strong>初始化实例对象</strong> 与 <strong>将singleton指针指向该对象</strong>可能被重排序。正因为这个重排序，另一个线程执行getInstance方法时，会返回一个未完成初始化的对象。而加<code>volatile</code>就能解决这个问题。volatile严格限制了对volatile域的写和对普通域的读写的重排序，因此volatile能保证这两个步骤不进行重排序。</p>
<h3 id="JSR-133：额外的重排序限制"><a href="#JSR-133：额外的重排序限制" class="headerlink" title="JSR-133：额外的重排序限制"></a>JSR-133：额外的重排序限制</h3><p>JSR-133 提出禁止 <strong>volatile 的读写</strong>与<strong>普通变量的读写</strong>重排序</p>
<p>这种额外的限制是为了提供一种<strong>比锁更轻量级的线程之间通信的机制</strong>。通过增强 volatile 的内存语义，使得<strong>对volatile的写-读 和 锁(synchronized)的释放-获取 具有相同的内存语义</strong>。</p>
<p>在功能上，锁比 volatile 更强大；在性能上，volatile 更有优势。原因是 volatile 仅仅保证对单个 volatile 变量的读&#x2F;写具有原子性，而锁可以保证整个<strong>临界区代码</strong>的执行具有原子性。</p>
<blockquote>
<p><strong>临界区</strong>：指的是某一块代码区域，它同一时刻只能由一个线程执行。</p>
</blockquote>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分以下3种：</p>
<blockquote>
<ul>
<li><p>编译器优化的重排：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</p>
</li>
<li><p>指令并行的重排：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序</p>
</li>
<li><p>内存系统的重排：由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p>
</li>
</ul>
</blockquote>
<p>其中编译器优化的重排属于<strong>编译器重排</strong>，指令并行的重排和内存系统的重排属于<strong>处理器重排</strong>，在多线程环境中，这些重排优化可能会导致程序出现内存可见性问题。</p>
<h3 id="内存可见性问题"><a href="#内存可见性问题" class="headerlink" title="内存可见性问题"></a>内存可见性问题</h3><p>当线程1和线程2在未同步的情况下对共享内存（主内存）中的变量进行访问时，比如两个线程的操作都是对变量a进行加1操作。假设线程1首先获取主内存中变量a的值，随后线程2又获取了主内存变量a的值，此时它们工作内存中a的值都是1，它们各自将a的值加1操作，然后assign至工作内存，工作内存中变量a的值都是2，然后两个线程又将值刷新到主内存，最后的结果是主内存中变量a的值是2。虽然整体对a的值加1操作做了两次操作，但<strong>由于线程间的操作是互相隔离的，默认情况下无法感知内存变量的值在随后的变化，也就无法访问内存中最新的变量值</strong>，这就是内存可见性的问题。</p>
<h4 id="如何解决内存可见性问题？"><a href="#如何解决内存可见性问题？" class="headerlink" title="如何解决内存可见性问题？"></a>如何解决内存可见性问题？</h4><ol>
<li>对进入临界区的线程做同步处理，同一时刻仅有一个线程能够访问临界区的资源；</li>
<li>使用 volatile 关键字保证内存可见性，它能保证访问临界区资源的所有线程总能看到共享资源的最新值；</li>
<li>CAS无锁化。</li>
</ol>
<h3 id="Java内存模型-Java-Memory-Modle，-JMM"><a href="#Java内存模型-Java-Memory-Modle，-JMM" class="headerlink" title="Java内存模型(Java Memory Modle， JMM)"></a>Java内存模型(Java Memory Modle， JMM)</h3><p>这是一个抽象的概念，用来描述或者规范访问内存变量的方式。 Java内存规定了所有变量都存储在主内存（Main Memory）中，各个线程又有自己的本地内存（工作内存），本地内存保存着主内存中部分变量。</p>
<p>参考流程如下：</p>
<p><a href=""><img src="/assets/img/06.jpg" alt="内存模型" title="访问内存变量的流程"></a></p>
<ol>
<li><strong>lock加锁：</strong>为了保证访问主内存变量的线程安全性，在访问前一般会加锁处理；</li>
<li><strong>read读：</strong>从主内存中读取一个变量到工作内存；</li>
<li><strong>load加载：</strong>把read读到的变量加载到工作内存的变量副本中；</li>
<li><strong>use使用：</strong>此时线程可以使用其工作内存中的变量了；</li>
<li><strong>assign赋值：</strong>将处理后的变量赋值给工作内存中的变量；</li>
<li><strong>store存储：</strong>将工作内存中的变量存储到主内存中，以新建new 一个新变量的方式存储；</li>
<li><strong>write写：</strong>将store存在的新变量的引用赋值给被处理的变量；</li>
<li><strong>unload解锁：</strong>所有的工作做完，最后解锁释放资源。</li>
</ol>
<h4 id="主内存和本地内存分别放什么变量？"><a href="#主内存和本地内存分别放什么变量？" class="headerlink" title="主内存和本地内存分别放什么变量？"></a>主内存和本地内存分别放什么变量？</h4><p>根据虚拟机规范，对于一个实例对象中的<strong>成员方法</strong>而言，如果方法中包含本地变量是基本数据类型，将直接存储在工作内存的帧栈结构中；倘若本地变量是引用类型，那么该变量的引用会存储在工作内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。</p>
<p>但对于实例对象的<strong>成员变量</strong>，不管它是基本数据类型或者包装类型还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存。</p>
<h5 id="本地内存和堆"><a href="#本地内存和堆" class="headerlink" title="本地内存和堆"></a>本地内存和堆</h5><p>从上面可以看到：Java线程持有堆对象的引用，那会直接操作堆吗？</p>
<p>堆是 Java 内存结构的一部分，属于共享区域，如果线程直接操作堆，就与JMM冲突了。</p>
<p>虽然Java采用直接指针的方式访问对象，但实际上<strong>并不会直接操作堆对象</strong>，毕竟堆也属于内存，也就是JMM的主存区域，Java线程的做法是：<strong>将堆对象拷贝到线程自己的本地内存来进行操作</strong>（如果对象很大只会拷贝一部分）。本地内存确实是线程私有的，但请不要和「JVM运行时数据结构的那些线程私有的栈等」划上等号，本地内存是抽象的。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>一个或多个操作要么全执行成功要么全执行失败（全不执行）。Java内存模型只保证单一的操作具有原子性，比如<code>int a = 1</code>; 是一个原子的操作，所以具有原子性；但是<code>a++</code>在底层会分为三个操作：</p>
<ol>
<li><p>读取a的值给临时变量；</p>
</li>
<li><p>临时变量a的值加1操作；</p>
</li>
<li><p>将加操作后的值赋值给a。</p>
</li>
</ol>
<p>每个操作都是原子的，但Java内存模型在多线程下并不能保证多操作具有整体原子性。需要对响应的代码块做同步处理，比如使用 <strong>有锁的synchronized</strong> 或 <strong>无锁的CAS</strong>。</p>
<h4 id="解决原子性问题：CAS"><a href="#解决原子性问题：CAS" class="headerlink" title="解决原子性问题：CAS"></a>解决原子性问题：CAS</h4><p>Java解决原子性问题，最核心的机制是：CAS。CAS是一条CPU并发原语</p>
<h5 id="CAS-Compare-and-Swap"><a href="#CAS-Compare-and-Swap" class="headerlink" title="CAS : Compare and Swap"></a>CAS : Compare and Swap</h5><p>用于<strong>在硬件层面上提供原子性操作</strong>。在 Intel 处理器中，CAS通过指令<code>cmpxchg</code>实现。 比较是否和给定的数值一致，如果一致则修改，不一致则不修改。</p>
<p>CAS有如下三个变量：</p>
<ul>
<li>V：要更新的变量(var)</li>
<li>E：预期值(expected)， 就是旧值</li>
<li>N：新值(new)</li>
</ul>
<p>CAS操作：判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。</p>
<p>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>
<h6 id="CAS为什么能保证原子性呢？"><a href="#CAS为什么能保证原子性呢？" class="headerlink" title="CAS为什么能保证原子性呢？"></a>CAS为什么能保证原子性呢？</h6><p>比如说，会不会出现两个线程同时做CAS并发现<code>Var = Eepected</code>，然后同时修改呢？</p>
<p><strong>CAS是一条CPU的原子指令，是CPU层面保证的。</strong>Linux的X86下主要是通过<code>cmpxchgl</code>这个指令，但在多处理器情况下必须使用<code>lock</code>指令加锁来完成。不同的操作系统和处理器的实现各不相同。</p>
<h5 id="CAS实现原子操作三大问题"><a href="#CAS实现原子操作三大问题" class="headerlink" title="CAS实现原子操作三大问题"></a>CAS实现原子操作三大问题</h5><h6 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h6><p>A-&gt;B-&gt;A，CAS检查不出变化。</p>
<p>ABA问题的本质是：一次CAS的旧值与另一次CAS的新值完全一样。</p>
<p>因此我们可以：加上<strong>版本号或者时间戳</strong>。</p>
<p>JUC解决ABA问题：AtomicStampedReference：这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查标志stamped是否为预期标志，如果全部一致，则继续；加上版本号。</p>
<h6 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h6><p>如果自旋CAS长时间不成功，会占用大量的CPU资源。</p>
<p>如果JVM能支持处理器提供的<strong>pause指令</strong>，那么效率会有一定的提升。</p>
<p>pause指令的两个作用：</p>
<ol>
<li><p>它可以延迟流水线执行指令，使CPU不会消耗过多的执行资源</p>
</li>
<li><p>它可以避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空</p>
</li>
</ol>
<h6 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h6><p>如果要保证多个变量的操作的原子性，CAS就无能为力了。我们有两种解决方案：</p>
<ul>
<li>锁机制，保证临界区的代码只有一个线程可以执行；</li>
<li>把多个共享变量合并成一个共享变量来操作；</li>
<li>使用JDK 1.5提供的<code>AtomicReference</code>类保证对象的原子性，把多个变量放在一个对象里。</li>
</ul>
<h4 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h4><p>这里指的是内存可见性。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>线程内的所有操作都是有序的，既程序执行的顺序按照代码的先后顺序执行。</p>
<h4 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h4><p>在JMM中，提供happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据。</p>
<p>具体内容如下：</p>
<blockquote>
<p><strong>程序顺序原则</strong>：即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</p>
<p><strong>锁规则</strong>： 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</p>
<p><strong>volatile规则</strong>： volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</p>
<p><strong>线程启动规则</strong>： 线程的start方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</p>
<p><strong>传递性</strong>： A先于B ，B先于C ，那么A必然先于C</p>
<p><strong>线程终止规则</strong>： 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</p>
<p><strong>线程中断规则</strong> ：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</p>
<p><strong>对象终结规则</strong> ：对象的构造函数执行，结束先于finalize()方法</p>
</blockquote>
<h4 id="CAS拓展"><a href="#CAS拓展" class="headerlink" title="CAS拓展"></a>CAS拓展</h4><h5 id="锁机制利用CAS"><a href="#锁机制利用CAS" class="headerlink" title="锁机制利用CAS"></a>锁机制利用CAS</h5><p>除了偏向锁，JVM实现锁的方式都用了循环CAS，也就是几乎所有的Java的锁实现都依赖于CAS操作。</p>
<p>实现逻辑：</p>
<blockquote>
<p>定义一个锁的状态；<br>状态状态值&#x3D;0 则表示没有线程获取到该锁；<br>状态状态值&#x3D;1 则表示有线程已经持有该锁；</p>
</blockquote>
<p>CAS 获取锁：将该锁的状态从 0 改为 1。</p>
<p>能够修改成功 cas 成功则表示获取锁成功<br>如果获取锁失败——修改失败，则不会阻塞而是通过循环（自旋来控制重试）</p>
<p>CAS 释放锁：将该锁的状态从 1 改为 0 。</p>
<p>如果能够改成功 cas 成功则表示释放锁成功</p>
<h5 id="循环CAS"><a href="#循环CAS" class="headerlink" title="循环CAS"></a>循环CAS</h5><p>循环CAS 就是在一个循环里不断的做cas 操作，直到成功为止。 </p>
<h1 id="内存屏障-Memory-Barrier"><a href="#内存屏障-Memory-Barrier" class="headerlink" title="内存屏障(Memory Barrier)"></a>内存屏障(Memory Barrier)</h1><p>内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性。</p>
<h2 id="为什么需要内存屏障？"><a href="#为什么需要内存屏障？" class="headerlink" title="为什么需要内存屏障？"></a>为什么需要内存屏障？</h2><p>这就需要了解一下MESI协议。</p>
<h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>一种比较常用的缓存一致性协议（不同处理器使用的缓存一致性协议可能不一样），M、E、S、I分别代表缓存行的四种状态。</p>
<blockquote>
<p><strong>M(Modify)</strong> 表示共享数据只缓存在当前 CPU 缓存中，并且是被修改状态（也就是缓存的数据和主内存中的数据不一致）</p>
<p><strong>E(Exclusive)</strong> 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改</p>
<p><strong>S(Shared)</strong> 表示数据可能被多个 CPU 缓存，并且各个缓存中的数据和主内存数据一致</p>
<p><strong>I(Invalid)</strong> 表示缓存已经失效</p>
</blockquote>
<p>在 MESI 协议中，每个缓存的缓存控制器不仅知道自己的读写操作，而且也监听(snoop)其它CPU的读写操作。</p>
<p>对于 MESI 协议，从 CPU 读写角度来说会遵循以下原则：<br>CPU读请求：缓存处于 M、E、S 状态都可以被读取，I 状态CPU 只能从主存中读取数据<br>CPU写请求：缓存处于 M、E 状态才可以被写。对于S状态的写，需要将其他CPU中缓存行置为无效才行。</p>
<h4 id="MESI协议存在的问题"><a href="#MESI协议存在的问题" class="headerlink" title="MESI协议存在的问题"></a>MESI协议存在的问题</h4><p>由于各个CPU缓存行的状态是通过消息传递来进行的，如果CPU0要对一个在缓存中共享的变量进行写入，首先需要发送一个失效的消息给到其他缓存了该数据的 CPU。并且要等到他们的确认回执。CPU0在这段时间内都会处于阻塞状态。</p>
<p>为了避免阻塞带来的资源浪费，CPU中引入了<strong>store bufferes</strong>：CPU0 只需要在写入共享数据时，直接把数据写入到 store bufferes中，同时发送invalidate消息，然后继续去处理其他指令（异步）， 当收到其他所有 CPU 发送了invalidate acknowledge消息时，再将store bufferes中的数据数据存储至缓存行中，最后再从缓存行同步到主内存。</p>
<p>但是这种优化就会带来了可见性问题，也可以认为是CPU的乱序执行引起的或者说是指令重排序。</p>
<p>所以CPU层面就提供了内存屏障，使得软件层面可以决定在适当的地方来插入内存屏障来禁止指令重排序。</p>
<h4 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h4><h5 id="为什么要有缓存一致性协议？"><a href="#为什么要有缓存一致性协议？" class="headerlink" title="为什么要有缓存一致性协议？"></a>为什么要有缓存一致性协议？</h5><p>这就需要先了解CPU的缓存机制了</p>
<h5 id="CPU的多级缓存"><a href="#CPU的多级缓存" class="headerlink" title="CPU的多级缓存"></a>CPU的多级缓存</h5><p>线程是CPU调度的最小单元，线程设计的目的最终仍然是更充分的利用计算机处理的效能，但是绝大部分的运算任务不能只依靠处理器计算就能完成，处理器还需要与内存交互，比如读取运算数据、存储运算结果，这个 I&#x2F;O 操作是很难消除的。</p>
<p>而由于计算机的存储设备与处理器的运算速度差距非常大，所以现代计算机系统都会<strong>增加一层</strong>读写速度尽可能接近处理器运算速度的<strong>高速缓存</strong>来作为内存和处理器之间的缓冲：<strong>将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步到内存之中</strong>。</p>
<p><a href=""><img src="/assets/img/cpu.png" alt="CPU多级缓存" title="多级缓存"></a></p>
<p>从上图可以看出，CPU有L1、L2、L3三级缓存，L1和L2缓存为各个CPU独有，而有了高速缓存的存在以后，每个 CPU 的处理过程是，先将计算需要用到的数据缓存在 CPU 高速缓存中，在 CPU进行计算时，直接从高速缓存中读取数据并且在计算完成之后写入到缓存中。在整个运算过程完成后，再把缓存中的数据同步到主内存。</p>
<p>由于在多 CPU 中，每个线程可能会运行在不同的 CPU 内，并且每个线程拥有自己的高速缓存。同一份数据可能会被缓存到多个 CPU 中，如果在不同 CPU 中运行的不同线程看到同一份内存的缓存值不一样就会存在缓存不一致的问题，那么怎么<strong>解决缓存一致性问题</strong>呢？</p>
<p>CPU层面提供了两种解决方法：<strong>总线锁</strong>和<strong>缓存锁</strong>。</p>
<h5 id="总线锁-缓存锁"><a href="#总线锁-缓存锁" class="headerlink" title="总线锁 &amp; 缓存锁"></a>总线锁 &amp; 缓存锁</h5><p>总线锁：在多CPU下，当其中一个处理器要对共享内存进行操作的时候，在总线上发出一个 LOCK#信号，这个信号使得其他处理器无法通过总线来访问到共享内存中的数据。总线锁定把 CPU 和内存之间的通信锁住了(CPU和内存之间通过总线进行通讯)，这使得锁定期间，其他处理器不能操作其他内存地址的数据。</p>
<p>然而这种做法的代价显然太大，那么如何优化呢？优化的办法就是<strong>降低锁的粒度</strong>，所以CPU就<strong>引入了缓存锁</strong>。</p>
<p>缓存锁：缓存锁的核心机制是基于缓存一致性协议来实现的，一个处理器的缓存回写到内存会导致其他处理器的缓存无效，IA-32处理器和Intel 64处理器使用MESI实现缓存一致性协议。</p>
<h2 id="CPU层面的内存屏障"><a href="#CPU层面的内存屏障" class="headerlink" title="CPU层面的内存屏障"></a>CPU层面的内存屏障</h2><p>通过防止 CPU 对内存的乱序访问来保证共享数据在多线程并行执行下的可见性</p>
<blockquote>
<p><strong>写屏障(Store Memory Barrier)：</strong>告诉处理器在写屏障之前的所有已经存储在存储缓存(store bufferes)中的数据同步到主内存，简单来说就是使得写屏障之前的指令的结果对写屏障之后的读或者写是可见的。</p>
<p><strong>读屏障(Load Memory Barrier)：</strong>处理器在读屏障之后的读操作，都在读屏障之后执行。配合写屏障，使得写屏障之前的内存更新对于读屏障之后的读操作是可见的。</p>
<p><strong>全屏障(Full Memory Barrier)：</strong>确保屏障前的内存读写操作的结果提交到内存之后，再执行屏障后的读写操作。</p>
</blockquote>
<h2 id="JMM层面的内存屏障"><a href="#JMM层面的内存屏障" class="headerlink" title="JMM层面的内存屏障"></a>JMM层面的内存屏障</h2><p>在JMM中把内存屏障分为4类，LoadLoad、StoreStore、LoadStore、StoreLoad。</p>
<p>StoreLoad Barriers是一个全能型的屏障，它同时具有其他3个屏障的效果。现代的多数处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。</p>
]]></content>
      <tags>
        <tag>CAS</tag>
        <tag>JMM</tag>
        <tag>指令重排</tag>
        <tag>CPU多级缓存</tag>
        <tag>MESI协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream流式编程</title>
    <url>/posts/862c3f1c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.netbian.com/4kdongman/"><img src="/assets/img/05.jpg" alt="壁纸" title="古风少女"></a></p>
<p>[TOC]</p>
<h1 id="了解Stream"><a href="#了解Stream" class="headerlink" title="了解Stream"></a>了解Stream</h1><ul>
<li>Stream 是 Java8 添加的一个新的抽象称为流，可以让你以一种声明的方式处理数据。通过使用流，我们可以说明想要完成什么任务，而不是说明如何去实现它。我们将操作的调度留给具体实现去解决。例如，假设我们想要计算某个属性的平均值，那么我们就可以指定数据源和该属性，然后，流库就可以对计算进行优化，例如，使用多线程来计算总和与个数，并将结果合并。</li>
<li>Stream 可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。<span id="more"></span></li>
<li>Stream 流的操作是以管道的方式串起来的。管道以数据源开始，包含若干个中间操作，最终以终点操作结束(规约操作）。</li>
<li>流并不存储其元素。这些元素可能存储在底层的集合中，或者是按需生成的。</li>
<li>流的操作不会修改其数据源。例如，filter 方法不会从流中移除元素，而是会生成一 个新的流，其中不包含被过滤掉的元素。</li>
<li>流的操作是尽可能惰性执行的。这意味着直至需要其结果时，操作才会执行。因此，我们甚至可以操作无限流。</li>
</ul>
<h1 id="操作流的典型流程"><a href="#操作流的典型流程" class="headerlink" title="操作流的典型流程"></a>操作流的典型流程</h1><p>建立一个包含三个阶段的操作管道：</p>
<ol>
<li>创建一个流</li>
<li>指定将初始流转换为其他流的中间操作，可能有多个中间操作</li>
<li>归约操作，产生结果，此操作会强制执行之前的惰性操作，然后这个流就再也无法使用了</li>
</ol>
<h2 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h2><ol>
<li>使用Collection接口的stream方法将任何集合转换为流：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   spliterator是一个实际的 Spliterator 对象，它代表了可以被分割和遍历的数据源;<br>   false表示是否应该创建一个并行流（parallel stream）。传入的是 false，意味着创建的是一个顺序流，这意味着流的操作将在当前线程上按照元素的自然顺序逐个进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;1ded&quot;</span>,<span class="string">&quot;2cec&quot;</span>,<span class="string">&quot;2dc&quot;</span>,<span class="string">&quot;4vv&quot;</span>,<span class="string">&quot;4vrv&quot;</span>);</span><br><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;2&quot;</span>)).forEach(System.out::println);</span><br><span class="line"><span class="comment">//2cec    2dc</span></span><br></pre></td></tr></table></figure>

<p>   关于顺序流可以参考下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Apple&gt; appleStore = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="number">500</span>, <span class="string">&quot;湖南&quot;</span>),  <span class="comment">//id1</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="number">2</span>, <span class="string">&quot;red&quot;</span>, <span class="number">100</span>, <span class="string">&quot;天津&quot;</span>),  <span class="comment">//id2</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="number">3</span>, <span class="string">&quot;green&quot;</span>, <span class="number">300</span>, <span class="string">&quot;湖南&quot;</span>), <span class="comment">//id3</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="number">4</span>, <span class="string">&quot;green&quot;</span>, <span class="number">200</span>, <span class="string">&quot;天津&quot;</span>),  <span class="comment">//id4</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="number">5</span>, <span class="string">&quot;green&quot;</span>, <span class="number">100</span>, <span class="string">&quot;湖南&quot;</span>)  <span class="comment">//id5</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        appleStore.stream().filter(apple -&gt; apple.getWeight() &gt; <span class="number">100</span>)</span><br><span class="line">                .peek(apple -&gt; System.out.println(<span class="string">&quot;通过第1层筛选 &quot;</span> + apple))</span><br><span class="line">                .filter(apple -&gt; <span class="string">&quot;green&quot;</span>.equals(apple.getColor()))</span><br><span class="line">                .peek(apple -&gt; System.out.println(<span class="string">&quot;通过第2层筛选 &quot;</span> + apple))</span><br><span class="line">                .filter(apple -&gt; <span class="string">&quot;湖南&quot;</span>.equals(apple.getBirthplace()))</span><br><span class="line">                .peek(apple -&gt; System.out.println(<span class="string">&quot;通过第3层筛选 &quot;</span> + apple))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   它的执行过程是这样的：id1先过滤，通过了第一层重量筛选但是颜色不对没通过第二层；换id2过滤，重量都没通过；换id3过滤，三层都通过了……</p>
<p>   输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过第1层筛选 com.example.javalearn.rui5.Apple@7cca494b</span><br><span class="line">通过第1层筛选 com.example.javalearn.rui5.Apple@7ba4f24f</span><br><span class="line">通过第2层筛选 com.example.javalearn.rui5.Apple@7ba4f24f</span><br><span class="line">通过第3层筛选 com.example.javalearn.rui5.Apple@7ba4f24f</span><br><span class="line">通过第1层筛选 com.example.javalearn.rui5.Apple@3b9a45b3</span><br><span class="line">通过第2层筛选 com.example.javalearn.rui5.Apple@3b9a45b3</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>Stream接口的of方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values<span class="comment">/*可变参数可看作数组*/</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line"><span class="comment">//实际上就是return StreamSupport.stream(spliterator(array, startInclusive, endExclusive), false);</span></span><br><span class="line">&#125;</span><br><span class="line">Stream&lt;String&gt; str = Stream.of(<span class="string">&quot;abx&quot;</span>,<span class="string">&quot;asac&quot;</span>,<span class="string">&quot;sad&quot;</span>);</span><br><span class="line"><span class="comment">//进入Arrays类的stream方法内部：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(T[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stream(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(T[] array, <span class="type">int</span> startInclusive, <span class="type">int</span> endExclusive)</span></span><br><span class="line"><span class="comment">//这也是一种创建流的方式</span></span><br></pre></td></tr></table></figure>



<h3 id="创建无限流"><a href="#创建无限流" class="headerlink" title="创建无限流"></a>创建无限流</h3><p>Stream接口有两个创建无限流的静态方法：</p>
<p>1. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">generate</span><span class="params">(Supplier&lt;? extends T&gt; s<span class="comment">/*用于提供Stream中的元素,反复调用函数s*/</span>)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(s);<span class="comment">//确保传入的Supplier不为空</span></span><br><span class="line">				<span class="keyword">return</span> StreamSupport.stream(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">StreamSpliterators</span>.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s)<span class="comment">/*用于创建一个无限的SupplyingSpliterator，其中s用于提供元素。*/</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] count = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 创建一个无限递增的整数流</span></span><br><span class="line">Stream&lt;Integer&gt; infiniteIntegers = Stream.generate(() -&gt; count[<span class="number">0</span>]++);</span><br><span class="line"><span class="comment">// 取前10个整数打印</span></span><br><span class="line">infiniteIntegers.limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>无论何时，只要需要 一个流类型的值，该函数就会被调用以产生一个这样的值。</p>
<p>2. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(f);</span><br><span class="line">Spliterator&lt;T&gt; spliterator = <span class="keyword">new</span> <span class="title class_">Spliterators</span>.AbstractSpliterator&lt;&gt;(Long.MAX_VALUE,Spliterator.ORDERED | Spliterator.IMMUTABLE) &#123;<span class="comment">/*匿名类*/</span>					</span><br><span class="line">  					T prev;</span><br><span class="line">						<span class="type">boolean</span> started;</span><br><span class="line"><span class="comment">//Spliterator实现了tryAdvance方法，每次调用该方法时，会将序列中的下一个元素传递给给定的Consumer行动，并返回true。</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAdvance</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">                Objects.requireNonNull(action);</span><br><span class="line">                T t;</span><br><span class="line">                <span class="keyword">if</span> (started)</span><br><span class="line">                    t = f.apply(prev);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    t = seed;</span><br><span class="line">                    started = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                action.accept(prev = t);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   如何利用iterate方法产生一个有限的序列呢？添加一个谓词（Predicate）来描述迭代应该如何结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(T seed, Predicate&lt;? <span class="built_in">super</span> T&gt; hasNext, UnaryOperator&lt;T&gt; next)</span></span><br><span class="line">  </span><br><span class="line"><span class="type">var</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;10000&quot;</span>);</span><br><span class="line">Stream&lt;BigInteger&gt; integers = Stream.iterate(BigInteger.ZERO, </span><br><span class="line">n -&gt;n.compareTo(limit) &lt; <span class="number">0</span>, n -&gt; n. add(BigInteger. ONE));</span><br><span class="line"><span class="comment">//该序列中的第一个元素是种子BigInteger.ZERO，第 二个元素是f(seed)，即1(作为大整数)，下一个元素是f(f(seed)，即2，后续以此类推。   只要该谓词拒绝了某个选代生成的值，这个流即结束</span></span><br></pre></td></tr></table></figure>



<h3 id="创建空流"><a href="#创建空流" class="headerlink" title="创建空流"></a>创建空流</h3><p>Stream接口的empty方法：Stream.empty();</p>
<h2 id="流的转换"><a href="#流的转换" class="headerlink" title="流的转换"></a>流的转换</h2><p>流的转换会产生一个新的流，它的元素派生自另一个流中的元素。常用的有filter,map和flatMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span> <span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span></span><br></pre></td></tr></table></figure>

<p>产生一个流，它包含当前流中所有满足谓词条件的元素。可以参考上面的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T，? extends R&gt; mapper)</span></span><br></pre></td></tr></table></figure>

<p>产生一个流，它包含将mapper应用于当前流中所有元素所产生的结果</p>
<p>带方法引用的map：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;1ded&quot;</span>,<span class="string">&quot;2cec&quot;</span>,<span class="string">&quot;2dc&quot;</span>,<span class="string">&quot;4vv&quot;</span>,<span class="string">&quot;4vrv&quot;</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; uppercase = list.stream().map(String::toUpperCase);</span><br><span class="line">uppercase.forEach(System.out::println);<span class="comment">//1DED 2CEC......</span></span><br><span class="line">或者这样写：</span><br><span class="line">list.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"><span class="comment">//因为forEach方法没有返回值，是一个void</span></span><br></pre></td></tr></table></figure>

<p>lambda表达式的map：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().map(s -&gt; s.substring(<span class="number">0</span>,<span class="number">1</span>)).forEach(System.out::println);<span class="comment">//1 2 2 4 4</span></span><br></pre></td></tr></table></figure>

<p>flatMap方法接受一个lambda表达式函数， 函数的返回值必须也是一个stream类型，flatMap方法最终会把所有返回的stream合并，map方法做不到这一点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; Streams&lt;R&gt; <span class="title function_">flatMap</span><span class="params">(Function &lt;? <span class="built_in">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span><br></pre></td></tr></table></figure>

<p>通过一个案例来理解：对给定单词列表 [“Hello”,”World”],你想返回列表[“H”,”e”,”l”,”o”,”W”,”r”,”d”]</p>
<p>使用map：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] words = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>&#125;;</span><br><span class="line">List&lt;String[]&gt; a = Arrays.stream(words)</span><br><span class="line">                .map(word -&gt; word.split(<span class="string">&quot;&quot;</span>))</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(toList());</span><br><span class="line">a.forEach(System.out::print);</span><br><span class="line"><span class="comment">//[Ljava.lang.String;@6d311334[Ljava.lang.String;@682a0b20返回了两个地址</span></span><br></pre></td></tr></table></figure>

<p>这个实现方式是有问题的，传递给map方法的lambda为每个单词生成了一个String[]（String列表）。因此，map返回的流实际上是Stream&lt;String[]&gt; 类型的。你真正想要的是用Stream<String>来表示一个字符串。</p>
<p>使用flatMap：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; a = Arrays.stream(words)</span><br><span class="line">                .map(word -&gt; word.split(<span class="string">&quot;&quot;</span>))</span><br><span class="line">                .flatMap(Arrays::stream)</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(toList());</span><br><span class="line">a.forEach(System.out::print);<span class="comment">//HeloWrd</span></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;待续。。。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot开发环境热部署"><a href="#SpringBoot开发环境热部署" class="headerlink" title="SpringBoot开发环境热部署"></a>SpringBoot开发环境热部署</h1><p>Spring Boot提供了spring-boot-devtools组件，无须手动重启Spring Boot应用即可重新编译、启动项目，大大缩短编译启动的时间。devtools会监听classpath下的文件变动，触发Restart类加载器重新加载该类，从而实现类文件和属性文件的热部署。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用optional&#x3D;true表示依赖不会传递，即该项目依赖devtools，其他项目如果引入此项目生成的JAR包，则不会包含devtools。</p>
<p>然后在application.properties中配置devtools</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 热部署生效</span></span><br><span class="line"><span class="attr">spring.devtools.restart.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 设置重启目录</span></span><br><span class="line"><span class="attr">spring.devtools.restart.additional-paths</span>=<span class="string">src/main/java</span></span><br><span class="line"><span class="comment"># 忽略重启目录</span></span><br><span class="line"><span class="attr">spring.devtools.restart.exclude</span>=<span class="string">static/**</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/posts/364ea8cc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/assets/img/08.jpg" alt="桌面图片" title="少女的侧脸"></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2129898729&auto=0&height=66"></iframe>

<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>总体来说设计模式分为三大类：</p>
<span id="more"></span>

<ol>
<li><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
</li>
<li><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
</li>
<li><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
</li>
</ol>
<p>其实还有两类：并发型模式和线程池模式。</p>
<h2 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式(Strategy Pattern)"></a>策略模式(Strategy Pattern)</h2><p>刘备要到江东娶老婆了，走之前诸葛亮给赵云(伴郎)三个锦囊妙计，说是按天机拆开解决棘手问题， 嘿，还别说，真是解决了大问题，搞到最后是周瑜陪了夫人又折兵呀，那咱们先看看这个场景是什么样子的。</p>
<p>先说这个场景中的要素：三个妙计，一个锦囊，一个赵云，妙计是小亮同志给的，妙计是放置在锦囊里，俗称就是锦囊妙计嘛，那赵云就是一个干活的人，从锦囊中取出妙计-&gt;执行-&gt;然后获胜。</p>
<p>三个妙计是同一类型的东西，那咱就写个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStrategy</span> &#123;</span><br><span class="line">    <span class="comment">//每个妙计都是一个可执行的算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再写三个实现类，这就是三个妙计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackDoor</span> <span class="keyword">implements</span> <span class="title class_">IStrategy</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找乔国老帮忙，让吴国太给孙权施加压力&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GivenGreenLight</span> <span class="keyword">implements</span> <span class="title class_">IStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;求吴国太开个绿灯,放行!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockEnemy</span> <span class="keyword">implements</span> <span class="title class_">IStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;孙夫人断后，挡住追兵&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类在实现某个接口的方法时最好加上@override，这里省略掉了</span></span><br></pre></td></tr></table></figure>

<p>再写一个锦囊存放这三个妙计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123; <span class="comment">//构造函数，你要使用那个妙计</span></span><br><span class="line">	<span class="keyword">private</span> IStrategy straegy;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(IStrategy strategy)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.straegy = strategy; </span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">//使用计谋了，看我出招了 </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.straegy.operate(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是赵云使用这三个妙计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZhaoYun</span> &#123;</span><br><span class="line">	<span class="comment">//赵云出场了，他根据诸葛亮给他的交代，依次拆开妙计</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    Context context;</span><br><span class="line">		<span class="comment">//刚刚到吴国的时候拆第一个 </span></span><br><span class="line">    context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">BackDoor</span>()); <span class="comment">//拿到妙计</span></span><br><span class="line">		context.operate(); <span class="comment">//执行第一个锦囊</span></span><br><span class="line">    <span class="comment">//刘备乐不思蜀了，拆第二个了 </span></span><br><span class="line">    context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">GivenGreenLight</span>());</span><br><span class="line">    context.operate(); <span class="comment">//执行第二个锦囊</span></span><br><span class="line">		<span class="comment">//孙权的小兵追了，咋办?拆第三个</span></span><br><span class="line">		context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">BlockEnemy</span>()); </span><br><span class="line">    context.operate(); <span class="comment">//执行第二个锦囊</span></span><br><span class="line">    <span class="comment">//孙夫人退兵</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="策略模式的作用"><a href="#策略模式的作用" class="headerlink" title="策略模式的作用"></a>策略模式的作用</h3><p>策略模式在软件设计中具有以下重要作用：</p>
<blockquote>
<ol>
<li><p><strong>封装算法族</strong>：策略模式将一组相关的算法封装成一系列可相互替换的具体策略类，每个策略类代表一个具体的算法或行为。这样，将算法的实现细节与使用算法的客户端代码分离，实现了算法的封装。</p>
</li>
<li><p><strong>支持算法切换</strong>：策略模式允许在运行时根据需要动态地选择和切换算法。客户端通过改变所持有的策略对象，就可以改变系统的行为，无需修改客户端代码或目标对象的结构。这种灵活性使得系统易于适应不同情境或用户需求的变化。</p>
</li>
<li><p><strong>消除条件分支</strong>：在没有使用策略模式的情况下，若系统中包含大量基于条件判断的代码（如if-else语句或switch-case结构），以选择不同的行为。策略模式通过引入策略对象，可以将这些条件分支逻辑替换为简单的策略对象的替换操作，使得代码更简洁、更易于理解和维护。</p>
</li>
<li><p><strong>易于扩展新算法</strong>：当需要添加新的算法或修改现有算法时，只需要新增一个策略类或修改已有策略类，客户端代码无需变动。这种对开放扩展、封闭修改的遵循体现了“开闭原则”，增强了系统的可扩展性。</p>
</li>
<li><p><strong>松散耦合</strong>：策略模式通过策略接口或抽象策略类将客户端与具体策略类解耦。客户端依赖于抽象策略，而不直接依赖于具体策略，降低了组件间的耦合度，使得各个策略之间互不影响，容易进行单元测试，也便于在不影响其他代码的情况下进行重构。</p>
</li>
<li><p><strong>支持组合策略</strong>：在某些情况下，策略模式可以支持策略之间的组合，形成更复杂的算法。通过在客户端代码中组合使用多个策略对象，可以实现算法的复合或优先级设定，以应对更复杂的业务场景。</p>
</li>
<li><p><strong>易于理解和复用</strong>：策略模式将每种算法封装为独立的类，每个类都有清晰的职责和边界，易于理解。由于策略类通常只包含与特定算法相关的逻辑，它们可以作为可复用的组件在不同上下文中使用，提高了代码的复用性。</p>
</li>
</ol>
</blockquote>
<p>综上所述，策略模式的主要作用在于通过将一组相关算法封装成一系列可相互替换的策略对象，使得客户端能够在运行时动态地选择和切换算法，从而实现算法的封装、切换、扩展，消除条件分支，降低系统耦合度，支持算法组合，并提高代码的可理解性和复用性。这种模式广泛应用于需要根据不同情况选择不同处理逻辑的场景，如排序算法的选择、数据校验规则的变更、支付方式的切换等。</p>
<h2 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式(Proxy Pattern)"></a>代理模式(Proxy Pattern)</h2><p>什么是代理模式呢？我很忙，忙的没空理你，那你要找我呢就先找我的代理人吧，那代理人总要知道被代理人能做哪些事情不能做哪些事情吧，那就是两个人具备同一个接口，代理人虽然不能干活，但是被代理的人能干活呀。</p>
<p>定义一种类型的女人，王婆和潘金莲都属于这个类型的女人：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">KindWomen</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeEyesWithMan</span><span class="params">()</span>; <span class="comment">//抛媚眼</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">happyWithMan</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后分别定义潘金莲和王婆两个实现类，但是王婆太老了，是个男人都看不上，所以她作为一类女人的代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PanJinLian</span> <span class="keyword">implements</span> <span class="title class_">KindWomen</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">happyWithMan</span><span class="params">()</span> &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;潘金莲在和男人做那个.....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeEyesWithMan</span><span class="params">()</span> &#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;潘金莲抛媚眼&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WangPo</span> <span class="keyword">implements</span> <span class="title class_">KindWomen</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> KindWomen kindWomen;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">WangPo</span><span class="params">()</span>&#123; <span class="comment">//默认是潘金莲的代理 </span></span><br><span class="line">    <span class="built_in">this</span>.kindWomen = <span class="keyword">new</span> <span class="title class_">PanJinLian</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//她也可以是KindWomen的任何一个女人的代理</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WangPo</span><span class="params">(KindWomen kindWomen)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.kindWomen = kindWomen; </span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">happyWithMan</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.kindWomen.happyWithMan(); <span class="comment">//自己老了，干不了，让年轻的代替</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeEyesWithMan</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.kindWomen.makeEyesWithMan(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个西门庆，他要做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiMenQing</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    <span class="comment">//把王婆叫出来</span></span><br><span class="line">    <span class="type">WangPo</span> <span class="variable">wangPo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WangPo</span>();</span><br><span class="line">    wangPo.makeEyesWithMan();</span><br><span class="line">    wangPo.happyWithMan();<span class="comment">//表面上是和王婆做，实际上却是和潘金莲 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理模式的作用"><a href="#代理模式的作用" class="headerlink" title="代理模式的作用"></a>代理模式的作用</h3><p>代理模式在软件设计中具有以下重要作用：</p>
<blockquote>
<ol>
<li><p><strong>控制访问</strong>：代理模式可以作为访问控制的中间层，通过代理对象来控制对真实对象（目标对象）的访问权限。例如，安全代理可以验证用户身份、检查访问权限，只有在满足特定条件时才允许客户端访问目标对象的方法。</p>
</li>
<li><p><strong>增强功能</strong>：代理对象可以在调用目标对象方法前后添加额外的操作，如预处理、后处理、日志记录、性能监控、事务管理等。这种机制允许在不修改目标对象代码的情况下为其增加新功能，符合“开闭原则”。</p>
</li>
<li><p><strong>透明代理</strong>：代理对象与目标对象遵循相同的接口，对客户端而言是透明的。客户端无需关心与之交互的是真实对象还是代理对象，只需按照接口约定进行调用。这种封装提高了系统的灵活性，因为可以在运行时动态切换不同的代理实现。</p>
</li>
<li><p><strong>远程代理</strong>：代理模式可以用来实现代理对象代表远程对象执行本地方法调用。远程代理隐藏了底层网络通信、序列化&#x2F;反序列化等细节，使得客户端能够像操作本地对象一样调用远程服务。</p>
</li>
<li><p><strong>延迟加载（懒加载）</strong>：懒汉式单例模式就是一种典型的延迟加载代理，只有当客户端首次请求时才真正创建目标对象。这种方式可以优化系统启动速度，减少资源消耗，特别适用于那些创建成本高或并非始终需要的对象。</p>
</li>
<li><p><strong>缓冲与数据缓存</strong>：代理对象可以作为缓存层，存储目标对象返回的数据，当客户端重复请求相同数据时，直接从代理对象中返回，避免频繁访问目标对象，从而提高性能。</p>
</li>
<li><p><strong>虚拟代理</strong>：对于创建成本高或耗时长的真实对象，如大体积图像、复杂的报表等，虚拟代理可以在必要时才创建或加载真实对象，同时在加载过程中提供占位符或其他默认数据。</p>
</li>
<li><p><strong>解耦</strong>：代理模式通过引入代理类，将一些与主要业务逻辑无关但又需要与之关联的操作（如日志记录、异常处理、统计计数等）从目标对象中分离出来，增强了系统的模块化和可维护性。</p>
</li>
</ol>
</blockquote>
<p>综上所述，代理模式主要用于为对象提供一个替代者（代理对象），通过代理对象来间接控制对真实对象（目标对象）的访问，以此实现访问控制、功能增强、透明代理、远程服务、延迟加载、缓存、虚拟化以及解耦等多种功能。它在软件开发中是一种强大的结构型设计模式，广泛应用于各种需要对对象访问进行中介、增强或控制的场景中。</p>
<h2 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h2><p>单例就是单一、独苗的意思。我们可以认为皇帝是个单例模式，在这 个场景中，有皇帝、有大臣，大臣是天天要上朝参见皇帝的，今天参拜的皇帝应该和昨天、前天的一样，大臣磕完头，抬头一看，嗨，还是昨天那个皇帝，单例模式，绝对的单例模式。</p>
<p>先定义一个皇帝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emperor</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Emperor</span> <span class="variable">emperor</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义一个皇帝放在那里</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Emperor</span><span class="params">()</span>&#123;&#125; <span class="comment">//不让你产生第二个皇帝</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(emperor == <span class="literal">null</span>)&#123; </span><br><span class="line">      <span class="comment">//如果皇帝还没有定义，那就定一个 </span></span><br><span class="line">      emperor = <span class="keyword">new</span> <span class="title class_">Emperor</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> emperor; </span><br><span class="line">  &#125;	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">emperorInfo</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我就是皇帝某某某....&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例模式很简单，就是在构造函数中多了加一个构造函数，访问权限是 private 的就可以了，这个模式是简单，但是简单中透着风险，风险？什么风险？在一个 B&#x2F;S 项目中，每个 HTTP Request 请求到 J2EE 的容器上后都创建了一个线程,每个线程都要创建同一个单例对象，怎么办？好，我们写一个通用的单例程序，然后分析一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingletonPattern singletonPattern= <span class="literal">null</span>; </span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">SingletonPattern</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> SingletonPattern <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.singletonPattern; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上面的写法在多线程情况下就会出现问题，就在getInstance方法里，假如现在有两个线程 A 和线程 B，线程 A 执行到 this.singletonPattern &#x3D; new SingletonPattern()，正在申请内存分配，可能需要 0.001 微秒，就在这 0.001 微秒之内，线程 B 执行到 if(this.singletonPattern &#x3D;&#x3D; null)，这个时候判断条件是 true ，那然后呢？线程 B 也往下走，于是乎就在内存中就有两个 SingletonPattern 的实例了，看看是不是出问题了？</p>
<p>如果你这个单例是去拿一个序列号或者创建一个信号资源的时候，就会导致业务逻辑混乱！数据一致性校验失败！最重要的是从代码上还看不出什么问题，因为这种情况基本上是重现不了的。那怎么修改？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonPattern singletonPattern= <span class="keyword">new</span> <span class="title class_">SingletonPattern</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingletonPattern</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonPattern <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> singletonPattern;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接 new 一个对象传递给类的成员变量 singletonpattern，你要的时候 getInstance()直接返回给你，解决问题！</p>
<h3 id="单例模式的作用"><a href="#单例模式的作用" class="headerlink" title="单例模式的作用"></a>单例模式的作用</h3><p>单例模式在软件工程中具有以下重要作用：</p>
<blockquote>
<ol>
<li><p><strong>确保唯一实例</strong>：单例模式的核心目标是确保一个类在整个应用程序的生命周期内只创建一个实例。通过精心设计的构造函数私有化、静态成员变量持有唯一实例以及提供一个公共的静态方法（通常称为“getInstance”）来获取该实例，有效地阻止了外部代码通过常规途径多次实例化该类。</p>
</li>
<li><p><strong>资源优化与共享</strong>：对于那些需要消耗大量系统资源（如数据库连接、文件句柄、硬件设备访问权限等）或者创建成本较高的对象，使用单例模式可以避免不必要的资源浪费。单一实例使得多个客户端可以共享同一资源，节省内存、磁盘空间、网络连接等资源，特别是对于那些全局状态管理、线程池、缓存、日志记录等场景尤为适用。</p>
</li>
<li><p><strong>协调系统状态</strong>：当一个类负责协调系统中全局状态或行为时，确保其全局唯一性至关重要。例如，充当系统配置管理器、事件调度中心、注册表服务等角色的类，通常需要以单例形式存在，以避免因多个实例导致的数据不一致或竞态条件。</p>
</li>
<li><p><strong>控制复杂性</strong>：单例模式有助于简化复杂系统的整体设计。由于单例对象的生命周期由类本身控制，开发者不需要在各处手动管理对象的创建、销毁和传递，减少了对象生命周期管理的复杂性，有利于提高代码的可读性和可维护性。</p>
</li>
<li><p><strong>保证一致性</strong>：对于需要维持全局状态一致性的应用，如序列号生成器、数据库连接池等，单例模式可以确保所有客户端都通过同一入口访问同一对象，避免了因多个实例导致的状态冲突或不一致。</p>
</li>
<li><p><strong>简化并行与分布式环境下的同步问题</strong>：在多线程或多进程环境中，如果某个类的实例必须是唯一的，直接使用单例模式可以避免不同线程或进程各自创建实例而引起的同步问题。单例的实现通常包含适当的同步机制（如双重检查锁定），确保在并发环境下也能正确地创建和返回单个实例。</p>
</li>
<li><p><strong>易于测试</strong>：在单元测试中，有时需要替换实际的单例对象为测试专用的模拟对象。良好的单例设计通常会提供一种方式（如通过依赖注入、设置静态开关等）来允许测试代码临时替换或重新初始化单例实例，便于进行隔离测试。</p>
</li>
</ol>
</blockquote>
<p>综上所述，单例模式的主要作用在于通过限制类的实例化次数为一次，实现资源的有效管理和共享，保证系统状态的一致性，简化对象生命周期管理，以及为复杂系统设计提供一种全局协调机制。它在许多需要控制全局唯一访问点、优化资源使用或维护系统状态的应用场景中发挥着关键作用。</p>
<h2 id="工厂方法模式-Factory-Method-Pattern"><a href="#工厂方法模式-Factory-Method-Pattern" class="headerlink" title="工厂方法模式(Factory Method Pattern)"></a>工厂方法模式(Factory Method Pattern)</h2><p>假设女娲造人的时候创建了一个工厂，根据这个工厂不断的造黑人、黄人、白人。</p>
<p>先定义人类的总称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Human</span> &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">laugh</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">talk</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义具体的人种，这里就省略掉了，就是三个实现类分别实现Human的方法。</p>
<p>再就是工厂了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HumanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Human <span class="title function_">createHuman</span><span class="params">(Class c)</span>&#123;</span><br><span class="line">        <span class="type">Human</span> <span class="variable">human</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义一个类型的人类 </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            human = (Human)Class.forName(c.getName()).newInstance(); <span class="comment">//产生一个人种</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;必须指定人种的颜色&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;人种定义错误!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;你指定的人种找不到!&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> human; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再定义女娲：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NvWa</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Human</span> <span class="variable">yellow</span> <span class="operator">=</span> HumanFactory.createHuman(YellowHuman.class);</span><br><span class="line">        yellow.laugh();</span><br><span class="line">        yellow.cry();</span><br><span class="line">        yellow.talk();</span><br><span class="line">      <span class="comment">//也可按照同样的写法创建其他人种</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂方法模式的作用"><a href="#工厂方法模式的作用" class="headerlink" title="工厂方法模式的作用"></a>工厂方法模式的作用</h3><p>工厂方法模式是一种创建型设计模式，其在软件工程领域具有以下几个主要作用：</p>
<blockquote>
<ol>
<li><p><strong>延迟对象创建</strong>：工厂方法模式将对象的创建过程封装在工厂类或子类中，通过调用工厂方法来创建所需对象，而不是直接使用 <code>new</code> 关键字在客户端代码中显式实例化。这样实现了对象创建的延迟，即具体的对象类型在运行时才确定，提高了程序的灵活性。</p>
</li>
<li><p><strong>解耦客户端与具体产品类</strong>：通过引入工厂接口（或抽象类），客户端代码无需了解或依赖具体产品类的细节。客户端只需与工厂接口交互，请求创建对象，而具体的对象类型和创建逻辑由工厂子类来实现。这样降低了客户端与具体产品类之间的耦合度，使得两者可以独立变化，提高系统的可维护性和可扩展性。</p>
</li>
<li><p><strong>支持多态产品对象创建</strong>：由于工厂方法通常在工厂子类中实现，不同的工厂子类可以创建不同类型的对象。这意味着客户端可以通过使用相同的工厂接口，根据需要选择不同的工厂子类来创建相应的产品对象。这种多态性增强了系统的灵活性，使得在不修改客户端代码的情况下，能够添加新产品类型或更换产品实现。</p>
</li>
<li><p><strong>便于对象的管理和配置</strong>：使用工厂方法模式，可以在工厂类或配置文件中集中管理对象的创建逻辑和依赖关系，便于进行全局的配置和调整。例如，可以根据不同的环境或用户需求，轻松切换产品对象的实现，如使用不同的数据库驱动、选择不同的日志记录器等。</p>
</li>
<li><p><strong>应对需求变化和代码复用</strong>：当业务需求发生变化时，如果涉及到产品类的变化，只需新增或修改相应的工厂子类即可，不会影响到使用工厂方法创建对象的客户端代码。同时，对于创建过程复杂的对象，工厂方法可以封装重复的初始化逻辑，减少代码重复，提升代码的复用性。</p>
</li>
<li><p><strong>防止对象创建代码散乱</strong>：在大型项目中，如果对象创建代码分散在各个模块或函数中，会使得代码难以管理和维护。工厂方法模式将对象创建集中化，有助于保持代码的整洁性和组织性，方便团队协作和代码审查。</p>
</li>
</ol>
</blockquote>
<p>总结来说，工厂方法模式的主要作用在于通过提供一个创建对象的通用接口，将对象的实例化过程封装并委托给子类实现，从而实现对象创建的延迟、客户端与具体产品类的解耦、多态产品对象的创建，以及对对象创建过程的集中管理和配置，增强软件系统的灵活性、可扩展性、可维护性和代码质量。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>算法刷题</title>
    <url>/posts/e86d771b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/assets/img/10.jpg" alt="桌面图片" title="少女"></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2034187125&auto=0&height=66"></iframe>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>这两天刷了十几道dp题，头已经昏了。dp实际上还是递归思想，只不过记录了在递归过程中的值。dp题给我的感觉就是基本上都是一个模版，找到其中的递归关系，然后自己再写写画画找到递推公式就行，甚至有时候递推公式原理没搞清楚可以靠猜的。</p>
<span id="more"></span>

<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>这是一道多维动态规划的题目。</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列 ，返回 0 。</p>
<p>一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p>
<p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace” </p>
<p>输出：3  </p>
<p>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p>
<h3 id="我的答案"><a href="#我的答案" class="headerlink" title="我的答案"></a>我的答案</h3><p>当时咋想的也忘了，明天再写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length(),n = text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowIndex</span> <span class="operator">=</span> m - <span class="number">1</span>,colIndex = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(text1.charAt(<span class="number">0</span>) == text2.charAt(<span class="number">0</span>))  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= rowIndex;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span> || text1.charAt(i) == text2.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= colIndex;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[<span class="number">0</span>][j-<span class="number">1</span>] == <span class="number">1</span> || text2.charAt(j) == text1.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= rowIndex;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= colIndex;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i) == text2.charAt(j))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[rowIndex][colIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="官方答案"><a href="#官方答案" class="headerlink" title="官方答案"></a>官方答案</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length(), n = text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> text1.charAt(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> text2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/posts/d366874c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/assets/img/01.jpg" alt="桌面图片" title="蒙眼少女"></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1959528822&auto=0&height=66"></iframe>

<p>[TOC]</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection&lt;E&gt;接口"></a>Collection&lt;E&gt;接口</h2><p>Collection是<strong>单列</strong>集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是 <strong>java.util.List</strong> 与 <strong>java.util.Set</strong>。</p>
<span id="more"></span>

<h3 id="Collection接口定义"><a href="#Collection接口定义" class="headerlink" title="Collection接口定义"></a>Collection接口定义</h3><p>继承自Iterable&lt;E&gt;，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>仅保留此列表中指定集合c中包含的元素</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span></span><br><span class="line">Object[] toArray()</span><br><span class="line"><span class="keyword">default</span> &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator)</span><br><span class="line">&lt;T&gt; T[] toArray(T[] a)</span><br></pre></td></tr></table></figure>
<h3 id="SequencedCollection"><a href="#SequencedCollection" class="headerlink" title="SequencedCollection&lt;E&gt;"></a>SequencedCollection&lt;E&gt;</h3><p>顺序集合，java21中新增特性，这里的顺序指的是在遍历一个集合时，集合中元素的出现顺序。</p>
<p>与顺序集合相关的操作包括：获取集合的第一个和最后一个元素、在集合的最前面和最后面插入或删除元素、按照逆序来遍历集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SequencedCollection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>/addLast(E e)</span><br><span class="line"><span class="keyword">default</span> E <span class="title function_">getFirst</span><span class="params">()</span>/getLast()</span><br><span class="line"><span class="keyword">default</span> E <span class="title function_">removeFirst</span><span class="params">()</span>/removeLast()</span><br><span class="line">SequencedCollection&lt;E&gt; <span class="title function_">reversed</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h3 id="List接口"><a href="#List接口" class="headerlink" title="List&lt;E&gt;接口"></a>List&lt;E&gt;接口</h3><p>List集合中的元素存储有序、可重复、可索引。</p>
<h4 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h4><p>List扩展了SequencedCollection接口，支持两端操作，并且可以在指定索引位置操作，并且支持自定义比较规则进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyOf</span><span class="params">(Collection&lt;? extends E&gt; coll)</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>/<span class="keyword">default</span> E <span class="title function_">getFirst</span><span class="params">()</span>/<span class="keyword">default</span> E <span class="title function_">getLast</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>/<span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span><span class="comment">//返回指定元素最后一次出现的索引</span></span><br><span class="line">ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span>/ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">of</span><span class="params">()</span><span class="comment">//返回一个空list</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">of</span><span class="params">(E e1,E e2,...)</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>/<span class="keyword">default</span> E <span class="title function_">removeFirst</span><span class="params">()</span>/<span class="keyword">default</span> E <span class="title function_">removeLast</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span></span><br><span class="line"><span class="keyword">default</span> List&lt;E&gt; <span class="title function_">reversed</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,E element)</span><span class="comment">//将List中指定位置的元素替换为指定元素。</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex,<span class="type">int</span> toIndex)</span><span class="comment">//类似于切片操作</span></span><br></pre></td></tr></table></figure>
<h5 id="replaceAll方法"><a href="#replaceAll方法" class="headerlink" title="replaceAll方法"></a>replaceAll方法</h5><p>按照替换规则替换列表中符合要求的所有元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, -<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">numbers.replaceAll(n -&gt; n &gt; <span class="number">0</span> ? n * <span class="number">2</span> : n);<span class="comment">// 数列变为 [2, -2, 6, -4, 10]</span></span><br></pre></td></tr></table></figure>

<h5 id="sort方法"><a href="#sort方法" class="headerlink" title="sort方法"></a>sort方法</h5><p><code>Comparator&lt;? super E&gt;</code>是一个比较器接口，用于定义元素间的比较规则。如果列表元素类型E自身实现了<code>Comparable</code>接口（如<code>String</code>、<code>Integer</code>等），则可以省略这个参数，使用元素自身的自然排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>);</span><br><span class="line">words.sort(Comparator.comparingInt(String::length));<span class="comment">// 数列现在变为 [&quot;cat&quot;, &quot;dog&quot;, &quot;apple&quot;, &quot;banana&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set&lt;E&gt;接口"></a>Set&lt;E&gt;接口</h3><p>元素不重复，存储无序。和List不一样，Set直接继承自Collection。</p>
<h4 id="部分方法-1"><a href="#部分方法-1" class="headerlink" title="部分方法"></a>部分方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">copyOf</span><span class="params">(Collection&lt;? extends E&gt; coll)</span></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">of</span><span class="params">()</span>/<span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">of</span><span class="params">(E e1,...)</span></span><br></pre></td></tr></table></figure>

<p>Set不支持索引操作，也不支持两端操作，也没有看到有sort方法（Set接口定义的是共性的方法，但是不代表所有的Set都不可排序）。</p>
<h3 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue&lt;E&gt;接口"></a>Queue&lt;E&gt;接口</h3><p><code>Queue</code>也直接继承自<code>Collection</code>接口。</p>
<h4 id="Queue接口定义"><a href="#Queue接口定义" class="headerlink" title="Queue接口定义"></a>Queue接口定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;<span class="comment">//向队列中添加一个元素；成功返回true，失败则抛出异常</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;<span class="comment">//向队列中添加一个元素；成功返回true，否则返回false</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">()</span>;<span class="comment">//从队列中删除队首元素，并返回该元素，没有则抛出NoSuchElementException异常</span></span><br><span class="line">E <span class="title function_">poll</span><span class="params">()</span>;<span class="comment">//从队列中删除队首元素，并返回该元素，没有则返回null</span></span><br><span class="line">E <span class="title function_">element</span><span class="params">()</span>;<span class="comment">//从队列获取队首元素，没有元素则抛出NoSuchElementException异常</span></span><br><span class="line">E <span class="title function_">peek</span><span class="params">()</span>;<span class="comment">//从队列获取队首元素，没有元素则返回null</span></span><br></pre></td></tr></table></figure>

<h4 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque&lt;E&gt;接口"></a>Deque&lt;E&gt;接口</h4><p>双端队列，Deque继承自Queue接口和SequencedCollection接口。操作方法与<code>Queue</code>的操作方法类似，只是指定了在队首还是队尾进行元素操作。</p>
<h5 id="Deque接口定义"><a href="#Deque接口定义" class="headerlink" title="Deque接口定义"></a>Deque接口定义</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>/<span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>/ <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span>/E <span class="title function_">removeLast</span><span class="params">()</span></span><br><span class="line">E <span class="title function_">pollFirst</span><span class="params">()</span>/E <span class="title function_">pollLast</span><span class="params">()</span></span><br><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>/E <span class="title function_">getLast</span><span class="params">()</span> </span><br><span class="line">E <span class="title function_">peekFirst</span><span class="params">()</span>/ E <span class="title function_">peekLast</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span>/<span class="type">boolean</span> <span class="title function_">removeLastOccurrence</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">//从队列中删除第一次/最后一次出现的该元素</span></span><br><span class="line"><span class="keyword">default</span> Deque&lt;E&gt; <span class="title function_">reversed</span><span class="params">()</span></span><br><span class="line">E <span class="title function_">pop</span><span class="params">()</span>/E <span class="title function_">push</span><span class="params">()</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span> </span><br></pre></td></tr></table></figure>
<h4 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue&lt;E&gt;接口"></a>BlockingQueue&lt;E&gt;接口</h4><p>阻塞队列，在入队和出队时进行加锁，保证了队列线程安全；当队列满时，会阻塞入队的线程，直到队列不满；当队列为空时，会阻塞出队的线程，直到队列中有元素。</p>
<p>常用于<strong>生产者-消费者模型</strong>中，往队列里添加元素的是生产者，从队列中获取元素的是消费者；通常情况下生产者和消费者都是由多个线程组成。生产者和消费者之间通过队列平衡两者的的处理能力、进行解耦等。</p>
<h5 id="BlockingQueue接口定义"><a href="#BlockingQueue接口定义" class="headerlink" title="BlockingQueue接口定义"></a>BlockingQueue接口定义</h5><p>继承自Queue接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//入队一个元素，如果有空间则直接插入，如果没有空间则一直阻塞等待</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//入队一个元素，如果没有空间则等待timeout时间，插入失败则返回false</span></span><br><span class="line">E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//检索并出队一个元素，如果不可获元素得则一直阻塞等待</span></span><br><span class="line">E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//出队一个元素，如果元素不可获得则等待timeout时间，无元素则返回null</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remainingCapacity</span><span class="params">()</span><span class="comment">//返回该队列剩余的容量（如果没有限制则返回Integer.MAX_VALUE）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c)</span><span class="comment">//将队列中的所有元素出队，并添加到给定的集合c中，返回出队的元素数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c, <span class="type">int</span> maxElements)</span></span><br><span class="line"><span class="comment">//将队列中的元素出队，限制数量maxElements个，并添加到给定的集合c中，返回出队的元素数量</span></span><br></pre></td></tr></table></figure>

<h5 id="BlockingQueue主要实现类"><a href="#BlockingQueue主要实现类" class="headerlink" title="BlockingQueue主要实现类"></a>BlockingQueue主要实现类</h5><p>主要有5个实现类：</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ArrayBlockingQueue</strong></td>
<td>使用数组存储数据，初始化时需要指定其容量，所以是一个<strong>有界队列</strong>，还可以设置内部的ReentrantLock是否使用公平锁。但是公平性会在性能上付出代价，只有在的确非常需要的时候再使用它。是一个基于数组的阻塞循环队列。</td>
</tr>
<tr>
<td><strong>LinkedBlockingQueue</strong></td>
<td>使用链表存储数据，默认是一个大小为Integer.MAX_VALUE的无界队列（如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。尽量自己传值，避免队列过大造成机器负载或者内存爆满等情况）；也可以通过构造方法中的<code>capacity</code>设置最大元素数量，所以也可以作为<strong>有界队列</strong>。</td>
</tr>
<tr>
<td><strong>SynchronousQueue</strong></td>
<td>一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并且立刻消费。它的特别之处在于它内部没有容器，一个生产线程，当它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递），这样的一个过程称为一次配对过程(当然也可以先take后put,原理是一样的)。</td>
</tr>
<tr>
<td><strong>PriorityBlockingQueue</strong></td>
<td>内部由优先级堆支持的无界优先级队列，队列中的元素按优先级顺序被移除。底层基于数组实现，是一个<strong>无界队列</strong>。<strong>PriorityBlockingQueue就是PriorityQueue的加锁线程安全版。</strong></td>
</tr>
<tr>
<td><strong>DelayQueue</strong></td>
<td><strong>一个内部由优先级堆支持的、基于时间的调度队列</strong>。队列中存放Delayed元素，只有在延迟期满后才能从队列中提取元素。当一个元素的getDelay()方法返回值小于等于0时才能从队列中poll中元素，否则poll()方法会返回null。无界阻塞队列，该队列的头部是延迟期满后保存时间最长的Delayed 元素。缓存系统的设计，缓存中的对象，超过了空闲时间，需要从缓存中移出；任务调度系统，能够准确的把握任务的执行时间。我们可能需要通过线程处理很多时间上要求很严格的数据。可以考虑<code>DelayQueue</code>。</td>
</tr>
</tbody></table>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map&lt;K,V&gt;接口"></a>Map&lt;K,V&gt;接口</h2><p>双列集合的根接口，表明一种映射关系。</p>
<h3 id="Map接口定义"><a href="#Map接口定义" class="headerlink" title="Map接口定义"></a>Map接口定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> </span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">compute</span><span class="params">(K key,BiFunction&lt;? <span class="built_in">super</span> K,? <span class="built_in">super</span> V,? extends V&gt; remappingFunction)</span></span><br><span class="line"><span class="comment">//根据给定的键（key）和一个双参数函数（remappingFunction），计算并更新与该键相关联的值。</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">computeIfAbsent</span><span class="params">(K key,Function&lt;? <span class="built_in">super</span> K,? extends V&gt; mappingFunction)</span><span class="comment">//在键不存在时计算并插入新值</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">computeIfPresent</span><span class="params">(K key,BiFunction&lt;? <span class="built_in">super</span> K,? <span class="built_in">super</span> V,? extends V&gt; remappingFunction)</span><span class="comment">//仅在键存在时计算并更新现有值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>/<span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span></span><br><span class="line"><span class="keyword">static</span> &lt;K, V&gt; Map&lt;K,V&gt; <span class="title function_">copyOf</span><span class="params">(Map&lt;? extends K,? extends V&gt; map)</span></span><br><span class="line"><span class="keyword">static</span> &lt;K, V&gt; Map.Entry&lt;K,V&gt; <span class="title function_">entry</span><span class="params">(K k,V v)</span><span class="comment">//获取map的entry对象，常用于遍历</span></span><br><span class="line"><span class="meta">@SafeVarargs</span> <span class="keyword">static</span> &lt;K, V&gt; Map&lt;K,V&gt; <span class="title function_">ofEntries</span><span class="params">(Map.Entry&lt;? extends K,? extends V&gt;... entries)</span></span><br><span class="line"><span class="comment">//根据提供的entries可变参数创建并返回一个不可变的Map实例。注意，返回的映射是不可修改的（unmodifiable），即不能添加、删除或更新键值对。</span></span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()/Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>/Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>/<span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> K,? <span class="built_in">super</span> V&gt; action)</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key,V defaultValue)</span></span><br><span class="line"><span class="comment">//get or default，如果键key在映射中存在，方法会返回与该键关联的实际值；如果不存在返回默认值defaultValue</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>/<span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">merge</span><span class="params">(K key,V value,BiFunction&lt;? <span class="built_in">super</span> V,? <span class="built_in">super</span> V,? extends V&gt; remappingFunction)</span></span><br><span class="line"><span class="keyword">static</span> &lt;K, V&gt; Map&lt;K,V&gt; <span class="title function_">of</span><span class="params">()</span>/<span class="keyword">static</span> &lt;K, V&gt; Map&lt;K,V&gt; <span class="title function_">of</span><span class="params">(K,V,K,V,...)</span></span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span>/<span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K,? extends V&gt; m)</span>/<span class="keyword">default</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key,V value)</span></span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span>/<span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key,Object value)</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">replace</span><span class="params">(K key,V value)</span>/<span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key,V oldValue,V newValue)</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> K,? <span class="built_in">super</span> V,? extends V&gt; function)</span></span><br></pre></td></tr></table></figure>

<h4 id="compute方法"><a href="#compute方法" class="headerlink" title="compute方法"></a>compute方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; wordsMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;word&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">updateCount</span> <span class="operator">=</span> wordsMap.compute(a,(k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);<span class="comment">//word:1</span></span><br></pre></td></tr></table></figure>

<p>这里的compute的第二个参数是一个Lambda表达式，接收当前键K和值V，V为空则置为1，并将值返回给updateCount。本来key&#x3D;”word”对应的value为null，经过compute函数后，value&#x3D;1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count0</span> <span class="operator">=</span> wordsMap.computeIfAbsent(a, k -&gt; <span class="number">3</span>);<span class="comment">//不会修改，依旧是word:1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> wordsMap.computeIfAbsent(b, k -&gt; <span class="number">3</span>);<span class="comment">//word:1, world:3</span></span><br><span class="line"><span class="type">int</span> <span class="variable">updated</span> <span class="operator">=</span> wordsMap.computeIfPresent(b,(k,v) -&gt;  v == <span class="number">3</span> ? <span class="number">2</span> : <span class="number">4</span>);<span class="comment">//word:1,world:2</span></span><br></pre></td></tr></table></figure>

<h4 id="merge方法"><a href="#merge方法" class="headerlink" title="merge方法"></a>merge方法</h4><p>将指定的键值对（<code>key</code>和<code>value</code>）合并到映射中。如果映射中已经存在与该键关联的值，那么将使用提供的<code>remappingFunction</code>来决定如何合并新值和现有值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; wordCounts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> <span class="string">&quot;example&quot;</span>;<span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">mergedCount1</span> <span class="operator">=</span> wordCounts.merge(word,newValue,Integer::sum);<span class="comment">//5;   example:5</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mergedCount2</span> <span class="operator">=</span> wordCounts.merge(word,newValue,Integer::sum);<span class="comment">//10;   example:10</span></span><br></pre></td></tr></table></figure>

<h4 id="replaceAll方法-1"><a href="#replaceAll方法-1" class="headerlink" title="replaceAll方法"></a>replaceAll方法</h4><p>对于映射中的每个键值对，<code>function</code>都会被调用，其返回值将替换原有的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; employeeAges = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ... (填充映射数据)</span></span><br><span class="line">employeeAges.replaceAll((id, age) -&gt; age + <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h4 id="SafeVarargs注解"><a href="#SafeVarargs注解" class="headerlink" title="@SafeVarargs注解"></a>@SafeVarargs注解</h4><p>用于声明一个方法是类型安全的可变参数方法，消除编译器对**可变参数(varargs)**方法可能导致类型安全问题的警告，并告诉编译器开发者已经确保了在使用可变参数时不会出现类型不匹配或安全隐患。</p>
<h1 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h1><h2 id="需要先了解的一些知识"><a href="#需要先了解的一些知识" class="headerlink" title="需要先了解的一些知识"></a>需要先了解的一些知识</h2><h3 id="线程安全队列"><a href="#线程安全队列" class="headerlink" title="线程安全队列"></a>线程安全队列</h3><p>在Java中，提供了两种线程安全队列的实现方式：一种是<strong>阻塞机制</strong>，另一种是<strong>非阻塞机制</strong>。</p>
<p>使用阻塞机制的队列，是通过使用<strong>锁</strong>的方式来实现，在入队和出队时通过加锁避免并发操作，比如BlockingQueue就是一个线程安全的阻塞队列；</p>
<p>而使用非阻塞机制的队列，是通过使用<strong>CAS方式</strong>实现，比如ConcurrentLinkedQueue。</p>
<h3 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h3><h4 id="捕捉子类的通用特性"><a href="#捕捉子类的通用特性" class="headerlink" title="捕捉子类的通用特性"></a>捕捉子类的通用特性</h4><p>抽象类用于定义一组相关或相似类的共同属性和行为。这些类可能在某些方面有所不同，但在某些核心特征和功能上具有共性。</p>
<p>抽象类将这些共性抽取出来，形成一个通用模板，为子类提供一个统一的结构和接口。</p>
<p>子类可以从抽象类继承并专注于实现其特有的细节，而不必重复编写通用部分的代码。</p>
<h4 id="定义抽象方法"><a href="#定义抽象方法" class="headerlink" title="定义抽象方法"></a>定义抽象方法</h4><p>抽象类可以包含抽象方法（abstract关键字修饰），这些方法只有声明而没有具体实现。子类必须提供抽象方法的实现，否则子类自身也需要声明为抽象类。</p>
<p>这种机制强制子类对特定功能进行实现，确保了子类具备某种约定的能力，增强了代码的规范性和一致性。</p>
<h4 id="实现接口的模板"><a href="#实现接口的模板" class="headerlink" title="实现接口的模板"></a>实现接口的模板</h4><p>抽象类可以作为实现某个接口（或多个接口）的模板。它不仅定义了接口所需的方法签名，还可以提供部分或全部方法的默认实现。这样，子类可以直接继承抽象类，从而实现接口的同时，利用抽象类提供的默认行为，避免了重复实现接口中所有方法的繁琐工作。</p>
<p>这在Java 8之后引入的默认方法（default ）特性之前尤为有用，那时的接口不能包含方法实现。</p>
<h4 id="隐藏类型细节"><a href="#隐藏类型细节" class="headerlink" title="隐藏类型细节"></a>隐藏类型细节</h4><p>抽象类可用于隐藏具体类型的实现细节，对外提供一致的接口。客户端代码可以操作抽象类的实例，而不必关心实际使用的具体子类。</p>
<p>这种类型隐藏提高了代码的灵活性和可扩展性，因为可以随时替换为其他实现了相同抽象类的子类，而无需修改依赖抽象类的代码。</p>
<h4 id="模块化与扩展性"><a href="#模块化与扩展性" class="headerlink" title="模块化与扩展性"></a>模块化与扩展性</h4><p>模块或框架可以通过定义抽象类来规定其扩展点或插件接口。其他开发人员只需创建继承自该抽象类的子类，即可实现特定功能的扩展。</p>
<h4 id="防止实例化"><a href="#防止实例化" class="headerlink" title="防止实例化"></a>防止实例化</h4><p>抽象类不能直接被实例化，只能作为其他类的父类使用。这一特性确保了抽象类只能用于定义通用结构和行为，而非用于创建独立的对象实例。</p>
<p>这有助于避免因误用抽象类而导致的运行时错误。</p>
<h3 id="AbstractCollection"><a href="#AbstractCollection" class="headerlink" title="AbstractCollection&lt;E&gt;"></a>AbstractCollection&lt;E&gt;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>实现了 <code>Collection</code> 接口的部分方法，提供了诸如元素计数、迭代器创建等通用功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> <span class="keyword">throws</span> UnsupportedOperationException,ClassCastException,NullPointerException,IllegalArgumentException,IllegalStateException</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="keyword">throws</span> </span><br><span class="line">UnsupportedOperationException,ClassCastException,NullPointerException,IllegalArgumentException,IllegalStateException</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedOperationException</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>/containsAll(Collection&lt;?&gt; c) <span class="keyword">throws</span> ClassCastException,NullPointerException</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>/removeAll(Collection&lt;?&gt; c) <span class="keyword">throws</span> </span><br><span class="line">UnsupportedOperationException,ClassCastException,NullPointerException </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> <span class="keyword">throws</span></span><br><span class="line">UnsupportedOperationException,ClassCastException,NullPointerException</span><br><span class="line">Object[] toArray()</span><br><span class="line">&lt;T&gt; T[] toArray(T[] a) <span class="keyword">throws</span> ArrayStoreException,NullPointerException </span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h4 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList&lt;E&gt;"></a>AbstractList&lt;E&gt;</h4><p><code>AbstractList</code> 主要目的是简化 <code>List</code> 接口的实现工作，特别是针对那些基于随机访问数据存储的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index,E element)</span>/<span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>/<span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index,Collection&lt;? extends E&gt; c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>/<span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>/<span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>/ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span>/ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>/<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex,<span class="type">int</span> toIndex)</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,E element)</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex,<span class="type">int</span> toIndex)</span></span><br></pre></td></tr></table></figure>

<h5 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h5><p>该类中还定义了modCount：<code>protected transient int modCount</code>，用于跟踪集合结构被修改的次数。</p>
<h5 id="迭代器的一致性检查"><a href="#迭代器的一致性检查" class="headerlink" title="迭代器的一致性检查"></a>迭代器的一致性检查</h5><p>当使用集合的迭代器进行遍历时，迭代器会记录一个初始的 <code>modCount</code> 值（即 <code>expectedModCount</code>）。在每次迭代过程中或执行迭代器方法（如 <code>next()</code> 或 <code>remove()</code>）时，迭代器会检查当前的 <code>modCount</code> 是否与 <code>expectedModCount</code> 相匹配。</p>
<p>如果在迭代过程中集合的结构发生了改变（如添加、删除、更新元素），会导致 <code>modCount</code> 增加。当发现 <code>modCount</code> 与 <code>expectedModCount</code> 不一致时，迭代器会立即抛出 <code>ConcurrentModificationException</code> 异常，这种机制称为 <strong>快速失败（Fail-Fast）</strong>。</p>
<p>它旨在尽早检测到并发修改，并阻止程序继续在已失效的迭代器上操作，从而避免潜在的不确定行为和数据不一致。</p>
<h5 id="Fail-Fast-策略"><a href="#Fail-Fast-策略" class="headerlink" title="Fail-Fast 策略"></a>Fail-Fast 策略</h5><p>Fail-Fast 是迭代器的一种设计选择，它不保证线程安全，而是选择在检测到并发修改时迅速失败，而不是冒着在不同步访问下产生不可预见结果的风险。</p>
<p>在多线程环境下，<code>modCount</code> 变量需要被声明为 <code>volatile</code>，确保其修改对所有线程立即可见。</p>
<h5 id="AbstractSequentialList"><a href="#AbstractSequentialList" class="headerlink" title="AbstractSequentialList&lt;E&gt;"></a>AbstractSequentialList&lt;E&gt;</h5><p>专门为那些支持顺序访问（sequential access）的列表实现设计的，与 <code>AbstractList&lt;E&gt;</code> 相比，<code>AbstractSequentialList&lt;E&gt;</code> 更侧重于简化对这种特定访问模式的支持，尤其是对于那些底层数据结构不适合随机访问的列表实现，如链表。</p>
<p>基于ListIterator来实现大部分List接口的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index,E element)</span>/<span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index,Collection&lt;? extends E&gt; c)</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>/E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>/E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,E element)</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>/<span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>

<h3 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h3><p>一个标记接口（tag interface），它没有定义任何方法，仅作为一种标识存在。当一个类（如 <code>ArrayList</code>）实现 <code>RandomAccess</code> 接口时，它表示该类支持快速随机访问元素。</p>
<h3 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h3><p>一个标记接口，表示类支持克隆操作。实现此接口的类可以被安全地复制，产生一个与原对象内容相同的新对象。</p>
<h4 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h4><p>由于clone返回的是Object对象，使用时可能需要强制转换成其他类型（如：ArrayList）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; originalList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ... 填充原始列表 ...</span></span><br><span class="line">ArrayList&lt;String&gt; clonedList = (ArrayList&lt;String&gt;) originalList.clone();</span><br></pre></td></tr></table></figure>

<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>表示类支持 Java 序列化机制。实现 <code>Serializable</code> 的类需要遵循一定的序列化规则，确保其实例在序列化和反序列化过程中保持语义上的正确性和一致性。</p>
<h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet&lt;E&gt;"></a>SortedSet&lt;E&gt;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortedSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Set</span>&lt;E&gt;, SequencedSet&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>顾名思义，维持集合的有序。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addFirst,addLast,comparator,getFirst/getLast,spliterator,reversed</span><br><span class="line">E <span class="title function_">first</span><span class="params">()</span>/last() 返回最小/大元素</span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement)</span> <span class="comment">//包含集合中所有小于（或等于，取决于排序规则）toElement 的元素</span></span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement)</span>/SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement,E toElement)</span></span><br></pre></td></tr></table></figure>

<h3 id="NavigableSet"><a href="#NavigableSet" class="headerlink" title="NavigableSet&lt;E&gt;"></a>NavigableSet&lt;E&gt;</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NavigableSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">SortedSet</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>扩展了 SortedSet接口，提供了更丰富的排序和搜索功能。<code>NavigableSet</code> 主要用于存储唯一且有序的元素，并且允许高效地在有序集合中进行导航和范围查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">descendingIterator,descendingSet,pollFirst,pollLast,removeFirst,removeLast</span><br><span class="line">E <span class="title function_">ceiling</span><span class="params">(E e)</span><span class="comment">//返回集合中大于等于给定元素 e 的最小元素 </span></span><br><span class="line">E <span class="title function_">higher</span><span class="params">(E e)</span><span class="comment">// 返回集合中大于给定元素 e 的最小元素</span></span><br><span class="line">E <span class="title function_">floor</span><span class="params">(E e)</span><span class="comment">//返回集合中小于等于给定元素 e 的最大元素</span></span><br><span class="line">E <span class="title function_">lower</span><span class="params">(E e)</span><span class="comment">//返回集合中小于给定元素 e 的最大元素</span></span><br><span class="line">NavigableSet&lt;E&gt; headSet/tailSet(E,<span class="type">boolean</span> inclusive)<span class="comment">//inclusive:是否包含端点</span></span><br><span class="line">NavigableSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E,<span class="type">boolean</span> fromInclusive,E,<span class="type">boolean</span> ToInclusive)</span></span><br></pre></td></tr></table></figure>

<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList&lt;E&gt;"></a>ArrayList&lt;E&gt;</h2><p>基于数组实现的类，可扩容，非线程安全。</p>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认的空的数组，这个主要是在构造方法初始化一个空数组的时候使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//使用默认size大小的空数组实例，和EMPTY_ELEMENTDATA区分开来，这样可以知道当第一个元素添加的时候进行扩容至多少</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="comment">//一个空的实例elementData，为上面的DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>当加入新元素时，数组容量不足则需要扩容。计算扩容所需容量minCapacity，计算新数组容量newCapacity：旧容量的1.5倍。如果new小于min，则将min作为新数组容量；如果new小于0，抛出越界异常；如果new 大于<code> Integer.MAX_VALUE - 8</code>，则取<code>Integer.MAX_VALUE</code>或<code> Integer.MAX_VALUE - 8</code>为新的数组容量。最后通过Array.copyOf对新数组赋值。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造一个空的数组集合，初始的elementData的容量为0，第一次添加元素的时候则扩容elementData为10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//elementData才是实际存放元素的数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个集合转变为ArrayList，实际上就是将集合中的元素换为了数组的形式。如果传入的集合为null会抛出空指针异常（调用c.toArray()方法的时候）</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//c.toArray()可能不会正确地返回一个 Object[]数组，那么使用Arrays.copyOf()方法</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果集合转换为数组之后数组长度为0，就直接使用自己的空成员变量初始化elementData</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="部分方法-2"><a href="#部分方法-2" class="headerlink" title="部分方法"></a>部分方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">clone</span><span class="params">()</span><span class="comment">//返回ArrayList实例的浅拷贝，新创建的对象中的相应元素与原对象中的对应部分指向相同的内存位置。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span><span class="comment">//增加容量确保至少大于minCapacity</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span><span class="comment">//将列表的容量修剪至当前大小</span></span><br></pre></td></tr></table></figure>

<h3 id="add操作流程"><a href="#add操作流程" class="headerlink" title="add操作流程"></a>add操作流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为要添加元素，所以添加之后可能导致容量不够，所以需要在添加之前进行判断（扩容）：<code>ensureCapacityInternal(size + 1)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当要add进第一个元素时，minCapacity为size+1&#x3D;1，在Math.max()方法比较后，minCapacity为10。紧接着调用ensureExplicitCapacity更新modCount的值，并判断是否需要扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++; </span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>超出容量则需要扩容grow，grow的流程也就是上面提到的扩容机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意到这个hugeCapacity方法，简单看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList&lt;E&gt;"></a>LinkedList&lt;E&gt;</h2><p>基于双向链表实现的类，可索引但是比较慢，非线程安全。既可以作为双端队列使用，也可以作为栈使用，同时还支持快速地在列表中间进行插入和删除操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>在LinkedList中有两个成员变量<code>first</code>和<code>last</code>，分别表示链表的首尾节点。</p>
<h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>

<h3 id="部分方法-3"><a href="#部分方法-3" class="headerlink" title="部分方法"></a>部分方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span>/<span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span>/<span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> LinkedList&lt;E&gt; <span class="title function_">reversed</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>LinkedList的索引并不能像数组那样支持下标随机访问，他会先判断索引是在链表的前半部分还是后半部分，从而选择从前还是从后遍历，所以会有listIterator。</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet&lt;E&gt;"></a>HashSet&lt;E&gt;</h2><p>不允许重复元素，不可索引，元素存取顺序不一致，非线程安全。</p>
<p><strong>java8之前</strong>底层数据结构：数组+链表（使用链表处理冲突），新元素存入数组时占据老元素位置，老元素以链表形式接在新元素后面（如果链表太长会导致查询性能降低，数组就会扩容）。</p>
<p><strong>java8之后</strong>底层数据结构：数组+链表+红黑树，当链表长度超过8且数组长度&gt;&#x3D;64时，自动将链表转成红黑树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<h3 id="基于HashMap"><a href="#基于HashMap" class="headerlink" title="基于HashMap"></a>基于HashMap</h3><p>HashSet 的内部采用了HashMap作为数据存储，HashSet其实就是在操作HashMap的key，value值默认为null或new Object()。</p>
<p>因为HashMap是无序的，因此HashSet也不能保证元素的顺序。</p>
<h3 id="HashSet去重复的机制"><a href="#HashSet去重复的机制" class="headerlink" title="HashSet去重复的机制"></a>HashSet去重复的机制</h3><p>两个不同对象的hashcode一般不同，相同对象的hashcode一定相同。如果有两个相同内容的不同对象则不能去重，需要重写对象的hashCode()方法和equals()方法。</p>
<h3 id="构造器-2"><a href="#构造器-2" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet()<span class="comment">//底层的hashmap实例有默认的容量16以及加载因子0.75</span></span><br><span class="line">HashSet(<span class="type">int</span> initialCapacity)</span><br><span class="line">HashSet(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c)</span><br><span class="line">HashSet(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor)</span><br></pre></td></tr></table></figure>

<h4 id="加载因子-LoadFactor"><a href="#加载因子-LoadFactor" class="headerlink" title="加载因子(LoadFactor)"></a>加载因子(LoadFactor)</h4><p>用于控制其内部使用的 HashMap 容量调整策略的重要参数。加载因子是一个介于0和1之间的浮点数，它代表了 HashMap在其容量被元素填充到一定程度时触发扩容(rehashing)操作的比例阈值。扩容时通常将容量扩大至原来的两倍。</p>
<p>较高的加载因子意味着允许更高的空间利用率，但在添加元素时更可能遭遇哈希冲突，可能导致查找、添加、删除等操作的性能下降；</p>
<p>较低的加载因子则倾向于牺牲一定的空间利用率，换取更低的哈希冲突率和更稳定的性能。</p>
<h3 id="部分方法-4"><a href="#部分方法-4" class="headerlink" title="部分方法"></a>部分方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; HashSet&lt;T&gt; <span class="title function_">newHashSet</span><span class="params">(<span class="type">int</span> numElements)</span><span class="comment">//创建一个新的空的hashset以适合numElements个元素，默认loadfactor是0.75</span></span><br><span class="line"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span>/<span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet&lt;E&gt;"></a>LinkedHashSet&lt;E&gt;</h3><p>继承自HashSet，依然是基于数组、链表、红黑树，但是每个元素多了一个双链表机制记录它前后元素的位置，元素存取顺序一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">SequencedSet</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<p>构造函数也和HashSet一样，其他方法也一样，只不过LinkedHashSet可以在两端操作(First&#x2F;Last)。</p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet&lt;E&gt;"></a>TreeSet&lt;E&gt;</h2><p>有序，元素按照自然排序（元素的自然顺序）或者指定的排序方式（通过比较器）排列。使用红黑树来存储元素，插入、删除和查找操作的时间复杂度均为 O(log n)。底层实际上是TreeMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<h3 id="构造器-3"><a href="#构造器-3" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet()<span class="comment">//默认创建一个初始容量为 16 的 TreeSet，加载因子为 0.75。</span></span><br><span class="line">TreeSet(SortedSet&lt;E&gt; s)<span class="comment">//创建一个有相同元素并且排序顺序与s一样的TreeSet</span></span><br><span class="line">TreeSet(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)<span class="comment">//指定排序方式</span></span><br><span class="line"><span class="comment">//new TreeSet&lt;&gt;(Comparator.reverseOrder())</span></span><br><span class="line">TreeSet(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c)<span class="comment">//从现有集合创建</span></span><br></pre></td></tr></table></figure>

<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>懒得写了，可以看实现的接口和继承的类里有哪些方法。</p>
<h3 id="对自定义类型对象如何进行排序"><a href="#对自定义类型对象如何进行排序" class="headerlink" title="对自定义类型对象如何进行排序"></a>对自定义类型对象如何进行排序</h3><ol>
<li><p>让自定义类实现Comparable接口，重写compareTo方法；</p>
</li>
<li><p>调用TreeSet有参构造器：TreeSet(Comparator&lt;? super E&gt; comparator)</p>
</li>
</ol>
<h4 id="Comparable与Comparator"><a href="#Comparable与Comparator" class="headerlink" title="Comparable与Comparator"></a>Comparable与Comparator</h4><ul>
<li>Comparable是Java中的一个接口，它包含一个方法compareTo(Object obj)，该方法用于比较当前对象与传入的对象obj的大小关系。该方法返回一个整数值，表示当前对象与传入对象的大小关系：如果当前对象小于传入对象，则返回负数；·······。实现Comparable接口的类可以作为集合的元素，使得集合内部的元素能够自动排序。</li>
<li>Comparator也是Java中的一个接口，它包含一个方法compare(Object obj1, Object obj2)，该方法用于比较两个对象obj1和obj2的大小关系：如果第一个对象小于第二个对象，则返回负数；·········。通过实现Comparator接口，<strong>可以根据不同的需求定义多种排序规则</strong>。实现Comparator接口的类可以作为参数传递给Collections.sort()等方法，从而实现定制排序。</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap&lt;K,V&gt;"></a>HashMap&lt;K,V&gt;</h2><p>底层数据结构是哈希表（数组+链表+红黑树），参考HashSet。</p>
<h3 id="继承关系-1"><a href="#继承关系-1" class="headerlink" title="继承关系"></a>继承关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<h3 id="重要变量"><a href="#重要变量" class="headerlink" title="重要变量"></a>重要变量</h3><p><code>DEFAULT_INITIAL_CAPACITY</code>数组的默认初始长度：<code>1 &lt;&lt; 4</code>即2^4&#x3D;16。</p>
<p><code>MAXIMUM_CAPACITY</code>数组的最大长度： <code>1 &lt;&lt; 30</code>。</p>
<p><code>DEFAULT_LOAD_FACTOR</code> 负载因子：默认值为<code>0.75</code>。</p>
<p><code>TREEIFY_THRESHOLD</code> 链表树化阈值： 默认值为 <code>8</code> 。表示在一个链表中节点的个数大于8时，才会将链表转换成为红黑树。</p>
<p><code>MIN_TREEIFY_CAPACITY = 64</code> 最小树化阈值，当数组长度超过改值时，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）。</p>
<p><code>UNTREEIFY_THRESHOLD</code> 红黑树链化阈值： 默认值为 <code>6</code> 。 表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</p>
<h3 id="构造器-4"><a href="#构造器-4" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K,? extends V&gt; m)</span></span><br><span class="line">其他方法：  <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; HashMap&lt;K,V&gt; <span class="title function_">newHashMap</span><span class="params">(<span class="type">int</span> numMappings)</span></span><br></pre></td></tr></table></figure>

<h3 id="JDK1-8中HashMap改了什么？"><a href="#JDK1-8中HashMap改了什么？" class="headerlink" title="JDK1.8中HashMap改了什么？"></a>JDK1.8中HashMap改了什么？</h3><ol>
<li><p>由 数组+链表 的结构改为 数组+链表+红⿊树 。</p>
</li>
<li><p>优化了⾼位运算的hash算法：h^(h&gt;&gt;&gt;16)</p>
</li>
<li><p>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。(解决了死循环的问题)</p>
</li>
<li><p>jdk1.7中加入新结点是头结点插入，jdk1.8之后采用尾结点插入，防止扩容的时候出现倒序的情况。</p>
</li>
</ol>
<h3 id="HashMap的线程不安全性"><a href="#HashMap的线程不安全性" class="headerlink" title="HashMap的线程不安全性"></a>HashMap的线程不安全性</h3><p>HashMap是非线程安全的，并没有<strong>提供操作的原子性</strong>以及<strong>可见性</strong>保证，存在线程安全问题。</p>
<p>比如A希望插入一个key-value对到HashMap中，当获取到对应的链表结点位置时，此时线程A的时间片用完了，而此时线程B被调度得以执行，可能线程B占用了A计算得到的位置，插入了数值。而线程A被切换回来的时候，不知道B已经插入了元素，仍然将元素插入此前计算好的位置，这样就会将B线程的插入记录覆盖掉了。</p>
<h4 id="HashTable如何保证线程安全？"><a href="#HashTable如何保证线程安全？" class="headerlink" title="HashTable如何保证线程安全？"></a>HashTable如何保证线程安全？</h4><p>使用了synchronized关键字。尽管HashTable保证了线程安全，但使用synchronized会有一个问题，就是锁的粒度太大，同时只能有一个线程进行操作，导致并发度低下，影响了操作的性能。</p>
<p>比如：HashTable的get和put方法，都使用了关键字synchronized修饰，这就意味着当一个线程调用put方法添加元素时，其它线程不能再同时执行put添加元素，也不能调用get方法获取数据。</p>
<h4 id="ConcurrentHashMap-如何保证线程安全？"><a href="#ConcurrentHashMap-如何保证线程安全？" class="headerlink" title="ConcurrentHashMap 如何保证线程安全？"></a>ConcurrentHashMap 如何保证线程安全？</h4><p>cas+synchronized+volatile。为了解决synchronized并发度低的问题，ConcurrentHashMap使用了cas+synchronized解决共享遍历操作原子性问题，使用volatile保障共享变量的内存可见性问题。</p>
<p>分段锁的思想，将 HashMap 进行切割，把 HashMap 中的哈希数组切分成小数组，每个小数组有 n 个 HashEntry 组成，其中小数组继承自ReentrantLock（可重入锁），这个小数组名叫Segment（JDK1.7），JDK1.8中取消了Segment 分段锁，采用 CAS + synchronized 来保证并发安全，ConcurrentHashMap 中 synchronized 只锁定当前链表或红黑二叉树的首节点，只要节点 hash不冲突，就不会产生并发。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap&lt;K,V&gt;"></a>LinkedHashMap&lt;K,V&gt;</h3><p>在HashMap的基础上添加了双链表机制，能够记录存储元素的顺序，保持迭代顺序。</p>
<h4 id="构造器-5"><a href="#构造器-5" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor,<span class="type">boolean</span> accessOrder)</span><span class="comment">//指定迭代顺序，访问顺序为真，插入顺序为假</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K,? extends V&gt; m)</span></span><br></pre></td></tr></table></figure>

<h4 id="部分方法-5"><a href="#部分方法-5" class="headerlink" title="部分方法"></a>部分方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;K, V&gt; LinkedHashMap&lt;K,V&gt; newLinkedHashMap(int numMappings)</span><br><span class="line">public V putFirst(K k,V v)/putLast(K k,V v)</span><br><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</span><br><span class="line">SequencedMap&lt;K,V&gt; reversed()</span><br><span class="line">SequencedSet&lt;Map.Entry&lt;K,V&gt;&gt; sequencedEntrySet()/SequencedSet&lt;K&gt; sequencedKeySet()/SequencedCollection&lt;V&gt; sequencedValues()</span><br></pre></td></tr></table></figure>

<h5 id="removeEldestEntry使用场景"><a href="#removeEldestEntry使用场景" class="headerlink" title="removeEldestEntry使用场景"></a>removeEldestEntry使用场景</h5><ol>
<li>当<code>LinkedHashMap</code>用作缓存时，可以设置一个最大容量限制。一旦缓存大小超过阈值，通过<code>removeEldestEntry</code>返回<code>true</code>来自动移除最久未使用的条目（LRU缓存策略）。</li>
<li>可以根据条目的添加时间或其他时间相关的属性判断是否已超出有效期限，从而删除过期条目。</li>
</ol>
<h4 id="实现LRU算法"><a href="#实现LRU算法" class="headerlink" title="实现LRU算法"></a>实现LRU算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="literal">true</span>); <span class="comment">// 设置初始容量、负载因子和accessOrder为true（按访问顺序排序）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES; <span class="comment">// 当缓存大小超过最大值时，删除最老的条目</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类可自行定义淘汰策略。</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap&lt;K,V&gt;"></a>TreeMap&lt;K,V&gt;</h2><p>底层通过红黑树进行自动排序。</p>
<h3 id="继承关系-2"><a href="#继承关系-2" class="headerlink" title="继承关系"></a>继承关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable,java.io.Serializable</span><br></pre></td></tr></table></figure>

<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="构造器-6"><a href="#构造器-6" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p><strong>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。</strong></p>
<p><strong>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于 ：内存的使用上，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象</strong>。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
<p><strong>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于 ：ArrayBlockingQueue采用读写同一个锁，所以没法实现读写并行</strong>。如果头部和尾部的锁分离，则可以实现读写并行，<code>LinkedBlockingQueue</code>就是。</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">  <span class="comment">/** 使用数组存储队列中的元素 */</span></span><br><span class="line">  <span class="keyword">final</span> Object[] items;</span><br><span class="line">  <span class="comment">/** 下一个出队元素在items数组中的索引 */</span></span><br><span class="line">  <span class="type">int</span> takeIndex;</span><br><span class="line">  <span class="comment">/** 下一个入队元素需要存放在items数组中的索引 */</span></span><br><span class="line">  <span class="type">int</span> putIndex;</span><br><span class="line">  <span class="comment">/** 队列中的元素数量 */</span></span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">  <span class="comment">/** 使用在许多教科书中能找到的经典的双Condition算法进行并发控制 */</span></span><br><span class="line">  <span class="comment">/** 使用独占锁ReetrantLock */</span></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">  <span class="comment">/** 等待出队的条件 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">  <span class="comment">/** 等待入队的条件 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部的数组其实是作为循环数组使用的，当数组中的元素满时，此时入队新元素需要进行等待。</p>
<h3 id="入队逻辑"><a href="#入队逻辑" class="headerlink" title="入队逻辑"></a>入队逻辑</h3><p>在当前位置插入元素，并修改索引值，并唤醒非空队列的线程，只有在获取锁的情况才会调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">  <span class="comment">// 将元素插入到putIndex处</span></span><br><span class="line">  items[putIndex] = x;</span><br><span class="line">  <span class="comment">// 修改putIndex索引</span></span><br><span class="line">  <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">  <span class="comment">// 如果修改后putIndex超出items数组最大索引，则指向索引0处</span></span><br><span class="line">    putIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 元素数量+1</span></span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">// 唤醒一个非空队列中的线程</span></span><br><span class="line">  notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队逻辑"><a href="#出队逻辑" class="headerlink" title="出队逻辑"></a>出队逻辑</h3><p>在当前位置获取一个元素，并修改索引值，并唤醒非满队列的线程，只有在获取锁的情况下才会调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">  <span class="comment">// 获取当前索引处元素</span></span><br><span class="line">  <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">  <span class="comment">// 将当前索引处置为空</span></span><br><span class="line">  items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 修改takeIndex索引</span></span><br><span class="line">  <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">  <span class="comment">// 如果修改后takeIndex超出items数组最大索引，则指向索引0处</span></span><br><span class="line">     takeIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 元素数量-1</span></span><br><span class="line">  count--;</span><br><span class="line">  <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">     itrs.elementDequeued();</span><br><span class="line">  <span class="comment">// 唤醒一个非满队列中的线程</span></span><br><span class="line">  notFull.signal();</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入队阻塞实现"><a href="#入队阻塞实现" class="headerlink" title="入队阻塞实现"></a>入队阻塞实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       checkNotNull(e);</span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">       <span class="comment">// 加锁</span></span><br><span class="line">       lock.lockInterruptibly();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">             <span class="comment">// 如果队列已满，线程阻塞，并添加到notFull条件队列中等待唤醒</span></span><br><span class="line">             notFull.await();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果队列未满，则调用enqueue方法进行入队操作</span></span><br><span class="line">           enqueue(e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用put方法进行阻塞式入队的基本流程"><a href="#调用put方法进行阻塞式入队的基本流程" class="headerlink" title="调用put方法进行阻塞式入队的基本流程"></a>调用put方法进行阻塞式入队的基本流程</h3><ol>
<li><p>首先，在进行入队操作前，使用<code>ReentrantLock</code>进行加锁操作，保证只有一个线程执行入队或出队操作；如果锁被其他线程占用，则等待；</p>
</li>
<li><p>如果加锁成功，则首先判断队列是否满；如果队列已满，则调用<code>notFull.await()</code>，将当前线程阻塞，并添加到<code>notFull条件队列</code>中等待唤醒；如果队列不满，则直接调用<code>enqueue</code>方法，进行元素插入；</p>
</li>
<li><p>当前线程添加到<code>notFull</code>条件队列中后，只有当其他线程有出队操作时，会调用<code>notFull.signal()</code>方法唤醒等待的线程；当前线程被唤醒后，还需要再次进行一次队列是否满的判断，如果此时队列不满才可以进行<code>enqueue</code>操作，否则仍然需要再次阻塞等待，这也就是为什么在判断队列是否满时使用<code>while</code>的原因，即避免当前线程被意外唤醒，或者唤醒后被其他线程抢先完成入队操作。</p>
</li>
<li><p>最后，当完成入队操作后，在finally代码块中进行锁释放<code>lock.unlock</code>，完成<code>put</code>入队操作</p>
</li>
</ol>
<h3 id="限时的入队"><a href="#限时的入队" class="headerlink" title="限时的入队"></a>限时的入队</h3><p>其实大致上是差不多的，只是多了时间的判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  checkNotNull(e);</span><br><span class="line">  <span class="comment">// 获取剩余等待时间</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  lock.lockInterruptibly();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断队列是否满</span></span><br><span class="line">    <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">// 入队队列满，等待时间为0，则入队失败，返回false</span></span><br><span class="line">       <span class="comment">// 如果队列满，等待时间大于0，且未到等待时间，则继续等待nanos</span></span><br><span class="line">       nanos = notFull.awaitNanos(nanos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列不满，进行入队操作</span></span><br><span class="line">    enqueue(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队阻塞实现-限时出队"><a href="#出队阻塞实现-限时出队" class="headerlink" title="出队阻塞实现 &amp; 限时出队"></a>出队阻塞实现 &amp; 限时出队</h3><p><code>take</code>、<code>poll</code>与<code>put</code>、<code>offer</code>逻辑类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 判断队列是否为空，如果为空则线程阻塞，添加到notEmpty条件队列等待</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 队列不为空，进行出队操作</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 指定队列元素数量capacity，并默认使用非公平锁进行并发控制 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;<span class="built_in">this</span>(capacity, <span class="literal">false</span>);&#125;</span><br><span class="line"><span class="comment">/** 指定使用公平锁/非公平锁进行并发控制*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;········&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>基于<strong>单向链表</strong>的阻塞队列，其内部维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时，才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。</p>
<p><strong>而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</strong></p>
<p>与<code>ArrayBlockingQueue</code>不同的是，在<code>LinkedBlockingQueue</code>中，入队和出队分别使用不同的锁。</p>
<h3 id="类的定义-1"><a href="#类的定义-1" class="headerlink" title="类的定义"></a>类的定义</h3><p>感觉思想和<code>ArrayBlockingQueue</code>差不多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 队列的容量，如果不传则默认Integer.MAX_VALUE */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 当前队列中元素数量 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">transient</span> Node&lt;E&gt; head;<span class="comment">////链表的头指针，head.item = null</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;<span class="comment">// 链表的尾指针 last.next = null</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 出队操作锁 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 出队条件：非空队列 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 入队锁 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 入队条件：非满队列 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造方法，队列容量为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定队列容量的构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">// 初始化链表的头尾节点</span></span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于集合构建队列，默认容量为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    putLock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">            enqueue(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e));</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put方法是如何实现的"><a href="#put方法是如何实现的" class="headerlink" title="put方法是如何实现的"></a>put方法是如何实现的</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="comment">// 入队锁上锁</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果队列中元素的数量等于队列的容量，则阻塞当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行入队操作</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// 元素数量增1，返回操作前的数量</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// c+1为当前队列的元素，如果小于容量，则唤醒notFull的等待线程，触发继续入队操作</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="comment">// 释放锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c为入队前的元素数量，也就是入队前队列为空，则需要唤醒非空条件notEmpty的等待线程，触发出队操作</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 唤醒出队等待的线程</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    <span class="comment">// 当前头结点（头结点不存储数据，第一个元素为head.next）</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// 当前队列中第一个元素</span></span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    <span class="comment">// 原头结点设置无效</span></span><br><span class="line">    h.next = h; </span><br><span class="line">    <span class="comment">// 最新的头结点指向第一个元素first</span></span><br><span class="line">    head = first;</span><br><span class="line">    <span class="comment">// 获得第一个元素的值</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">    <span class="comment">// 将第一个元素值设置为null，第一个元素变成头结点</span></span><br><span class="line">    first.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 返回第一个元素值</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="Spliterator"><a href="#Spliterator" class="headerlink" title="Spliterator"></a>Spliterator</h2><p>高效地遍历和分割数据源，特别关注于支持并行流（parallel streams）的高效处理。</p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><blockquote>
<p><code>tryAdvance(Consumer&lt;? super T&gt; action)</code>：接受一个 <code>Consumer</code> 函数式接口作为参数，尝试对下一个元素执行给定的操作。如果还有元素可处理，则返回 <code>true</code>；否则返回 <code>false</code>，表示遍历结束。</p>
<p><code>forEachRemaining(Consumer&lt;? super T&gt; action)</code>：对余下的所有元素执行给定的 <code>Consumer</code> 操作，直到数据源耗尽。这是对 <code>tryAdvance()</code> 的批处理版本，通常更高效。</p>
<p><code>trySplit()</code>：尝试将当前 Spliterator 分割成两个独立的 Spliterator，返回其中一个。返回 <code>null</code> 表示无法再分割（例如数据源太小或已遍历完毕）。此方法是实现并行处理的关键。</p>
<p><code>estimateSize()</code>：返回一个估计的剩余元素数量，可以是准确值，也可以是近似值。这个信息有助于并行框架合理分配任务和优化性能。</p>
<p><code>characteristics()</code>：返回一个包含 <code>Characteristic</code> 枚举值的位掩码（bitmask），表示数据源的特性。这些特性包括但不限于：<code>ORDERED</code>（有序）、<code>DISTINCT</code>（元素唯一）、<code>SORTED</code>（已排序）、<code>SIZED</code>（已知大小）、<code>NONNULL</code>（不包含 <code>null</code> 元素）、<code>IMMUTABLE</code>（数据源不可变）等。</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote>
<ul>
<li><p><strong>并行流处理</strong>：在使用 Java 8 的并行流（如 <code>Stream.parallel()</code>）时，流会自动使用数据源提供的 Spliterator 进行高效并行处理。</p>
</li>
<li><p><strong>自定义数据源遍历</strong>：如果需要为自定义数据结构提供高效的遍历接口，可以实现 Spliterator 接口以支持并行流和其他高级遍历操作。</p>
</li>
<li><p><strong>高性能数据处理库</strong>：在构建高性能数据处理库或框架时，Spliterator 是实现高效数据遍历和并行化的基础工具。</p>
</li>
</ul>
</blockquote>
<h2 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h2><p>支持从尾到头遍历、访问当前元素的前后元素、在迭代过程中直接修改列表以及定位到特定索引位置。</p>
<h2 id="descendingIterator"><a href="#descendingIterator" class="headerlink" title="descendingIterator"></a>descendingIterator</h2><p>该迭代器能够按照集合元素的从大到小顺序遍历集合。</p>
]]></content>
      <tags>
        <tag>ArrayBlockingQueue</tag>
        <tag>ArrayList</tag>
        <tag>HashSet</tag>
        <tag>LinkedList</tag>
        <tag>Fail-Fast策略</tag>
        <tag>Spliterator</tag>
        <tag>TreeSet</tag>
        <tag>LinkedBlockingQueue</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO</title>
    <url>/posts/94795185/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/../assets/img/0110235LwmT.jpg" alt="0110235LwmT"></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=566506089&auto=0&height=66"></iframe>

<h1 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h1><h2 id="四个抽象类基类"><a href="#四个抽象类基类" class="headerlink" title="四个抽象类基类"></a>四个抽象类基类</h2><p><code>InputStream</code>&#x2F;<code>Reader</code>：所有的输入流的基类。前者是字节输入流，后者是字符输入流。</p>
<p><code>OutputStream</code>&#x2F;<code>Writer</code>：所有输出流的基类。前：字节，后：字符。</p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中；</p>
<p>常用方法：</p>
<blockquote>
<p><code>read()</code> : 返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</p>
<p><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</p>
<p><code>available()</code>：返回输入流中可以读取的字节数。</p>
<p><code>skip(long n)</code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</p>
<p><code>read(byte b[], int off, int len)</code>：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p>
<p><code>write(int b)</code>：将特定字节写入输出流。</p>
<p><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</p>
<p><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p>
<p><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</p>
</blockquote>
<p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">te1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./log.txt&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;字节数目：&quot;</span> + fis.available());</span><br><span class="line">            <span class="type">int</span> content;</span><br><span class="line">            <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(ByteExtractor.formatBinaryStr(Integer.toBinaryString(content))</span><br><span class="line">                        + <span class="string">&quot;: &quot;</span> + (<span class="type">char</span>) content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteExtractor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符转成utf-8编码下的二进制数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> character 目标字符。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串形式的二进制数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">charToBinary</span><span class="params">(<span class="type">char</span> character)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取单个字符的字节表示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Character.toString(character);</span><br><span class="line">        <span class="type">byte</span>[] bytes = str.getBytes((StandardCharsets.UTF_8));</span><br><span class="line">        System.out.println(bytes.length);</span><br><span class="line">        <span class="comment">//2. 将字节数组转成二进制数</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">           sb.append(byteToBinary(b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将单个字节转成二进制数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 目标字节。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串形式的二进制数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">byteToBinary</span><span class="params">(<span class="type">byte</span> value)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 使用位运算获取当前位的值（1或0）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> (value &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            sb.append(bit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 格式化二进制字符串，使其长度为8位。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 目标字符串。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 格式化后的字符串。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">formatBinaryStr</span><span class="params">(String value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value.length() == <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>.repeat(<span class="number">8</span> - value.length()) + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字节数目：5</span><br><span class="line">01110011: s</span><br><span class="line">01100010: b</span><br><span class="line">11100110: æ</span><br><span class="line">10010110: </span><br><span class="line">10000111: </span><br><span class="line"></span><br><span class="line">原文件中信息：sb文</span><br></pre></td></tr></table></figure>

<p>可以看出中文字符在utf-8编码中占了三个字节。</p>
<p> <code>FileInputStream</code> 一般不会单独使用，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./log.txt&quot;</span>))</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(fis.readAllBytes()));</span><br><span class="line"><span class="comment">//输出：sb文</span></span><br></pre></td></tr></table></figure>

<p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合其它流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./log.txt&quot;</span>));</span><br><span class="line"><span class="comment">//可以读取任意具体的类型数据</span></span><br><span class="line">dataInputStream.readBoolean();	</span><br><span class="line">dataInputStream.readInt();	</span><br><span class="line">dataInputStream.readUTF();</span><br><span class="line">dataInputStream.readLong();</span><br></pre></td></tr></table></figure>

<p>注意readLong需要8字节的数据，如果文件中的字节数小于8，则会抛出<code>EOFException</code>。</p>
<p>比如我这个文件只有5字节的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">te1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./log.txt&quot;</span>)))&#123;</span><br><span class="line">            System.out.println(dis.readLong());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：java.io.EOFException</span></span><br></pre></td></tr></table></figure>

<p>连续用两个readInt()也会抛出<code>EOFException</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">te1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./log.txt&quot;</span>)))&#123;</span><br><span class="line">            System.out.println(dis.readInt());</span><br><span class="line">            System.out.println(dis.readInt());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="number">1935861398</span>   ----&gt;  <span class="number">01110011</span>  <span class="number">01100010</span>  <span class="number">11100110</span> <span class="number">10010110</span></span><br><span class="line">java.io.EOFException</span><br></pre></td></tr></table></figure>

<p>可以看见第一个readInt()正常读取了4个字节，第二个readInt()只剩下1个字节可读，报错。</p>
<p>先新建一个UTF-8文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">te1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./utf.txt&quot;</span>)))&#123;</span><br><span class="line">            dos.writeUTF(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件效果：</p>
<p><img src="/../assets/img/tx.png" alt="tx"></p>
<p>可以看到有一个前缀，<code>readUTF</code>方法先读取一个短整型（2字节），这个短整型表示后续UTF-8编码的字符序列的长度（字节数）。随后，根据这个长度，它会读取指定数量的字节来构成一个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">te1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./utf.txt&quot;</span>)))&#123;</span><br><span class="line">            System.out.println(dis.readUTF());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：你好</span></span><br></pre></td></tr></table></figure>

<p>既然是一个短整型的前缀，用<code>readShort()</code>方法打印看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p>刚好代表了6个字节。</p>
<p>⚠️<code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code>ObjectOutputStream</code>将对象写入到输出流(序列化)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">te1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./student.txt&quot;</span>)))&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Rui&quot;</span>, <span class="number">18</span>);</span><br><span class="line">            oos.writeObject(student);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Student类未实现 <code>Serializable</code> 接口时，抛出异常：<code>java.io.NotSerializableException</code>。</p>
<p>必须保证该类可被序列化。</p>
<p>写入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./student.txt&quot;</span>));</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Rui&quot;</span>, <span class="number">18</span>);</span><br><span class="line">oos.writeObject(student);</span><br></pre></td></tr></table></figure>

<p>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./student.txt&quot;</span>))；</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) ois.readObject();</span><br><span class="line">System.out.println(student.getName() + <span class="string">&quot; &quot;</span> + student.getAge());</span><br></pre></td></tr></table></figure>

<p>⚠️Student类被序列化并写入文件之后，如果被修改，再从文件读取信息时，会因为<code>serialVersionUID </code>不匹配而抛出异常。</p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>很明显，由于中文字符占据3个字节，所以乱码问题很容易出现。</p>
<p>因此，I&#x2F;O 流就提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。</p>
<p>如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<p>字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码。</p>
<blockquote>
<p>常用字符编码所占字节数：</p>
<p><code>utf8</code> :英文占 1 字节，中文占 3 字节，</p>
<p><code>unicode</code>：任何字符都占 2 个字节，</p>
<p><code>gbk</code>：英文占 1 字节，中文占 2 字节。</p>
</blockquote>
<p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p>
<p>常用方法：</p>
<blockquote>
<p><code>read()</code> : 从输入流读取一个字符。</p>
<p><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</p>
<p><code>read(char[] cbuf, int off, int len)</code>：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</p>
<p><code>skip(long n)</code>：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</p>
<p><code>write(int c)</code> : 写入单个字符。</p>
<p><code>write(char[] cbuf)</code>：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</p>
<p><code>write(char[] cbuf, int off, int len)</code>：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</p>
<p><code>write(String str)</code>：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</p>
<p><code>write(String str, int off, int len)</code>：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</p>
<p><code>append(CharSequence csq)</code>：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</p>
<p><code>append(char c)</code>：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</p>
<p><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字符。</p>
</blockquote>
<p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;./log.txt&quot;</span>);</span><br><span class="line"><span class="type">int</span> content;</span><br><span class="line"><span class="keyword">while</span> ((content = fr.read()) != -<span class="number">1</span>)&#123; System.out.print((<span class="type">char</span>)content);&#125;</span><br><span class="line"><span class="comment">//输出：sb文</span></span><br></pre></td></tr></table></figure>

<p>写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;./log.txt&quot;</span>)；</span><br><span class="line">fw.write(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">fw.append(<span class="string">&quot;123&quot;</span>).append(<span class="string">&quot;456&quot;</span>);</span><br><span class="line"><span class="comment">//hello world123456</span></span><br></pre></td></tr></table></figure>

<p>可以看出原文件内容被覆盖掉了，如何只追加内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;./log.txt&quot;</span>, <span class="literal">true</span>)；</span><br><span class="line">  <span class="comment">//加一个参数true</span></span><br></pre></td></tr></table></figure>

<h3 id="flush的作用"><a href="#flush的作用" class="headerlink" title="flush的作用"></a>flush的作用</h3><blockquote>
<p>确保数据写出：当向输出流写入数据时，数据通常不是立即被物理地写到目标设备（如磁盘、网络）上，而是先存储在内存中的缓冲区里。这样做可以减少实际的I&#x2F;O操作次数，提高效率。调用flush方法会强制将缓冲区中的数据立即写入到目标设备，确保数据不会因为程序异常终止或缓冲区满而丢失。</p>
</blockquote>
<p>⚠️很多情况下流会在关闭前自动调用flush，但在某些特定场景或使用自定义的流时，手动调用flush仍然是必要的。</p>
<h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p>
<p>字节缓冲流内部有缓冲区（字节数组），字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p>
<p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected volatile byte buf[];</span><br></pre></td></tr></table></figure>

<p>默认大小8192字节。</p>
<h2 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h2><p><code>RandomAccessFile</code> 的构造方法如下，我们可以指定 <code>mode</code>（读写模式）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode)</span></span><br><span class="line">    <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="built_in">this</span>(file, mode, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode, <span class="type">boolean</span> openAndDelete)</span>  <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">  <span class="comment">// 省略大部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>读写模式主要有下面四种：</p>
<ul>
<li><code>r</code> : 只读模式。</li>
<li><code>rw</code>: 读写模式</li>
<li><code>rws</code>: 相对于 <code>rw</code>，<code>rws</code> 同步更新对“文件的内容”或“元数据”的修改到外部存储设备。</li>
<li><code>rwd</code> : 相对于 <code>rw</code>，<code>rwd</code> 同步更新对“文件的内容”的修改到外部存储设备。</li>
</ul>
</blockquote>
<p>文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。</p>
<p><code>RandomAccessFile</code> 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 <code>RandomAccessFile</code> 的 <code>seek(long pos)</code> 方法来设置文件指针的偏移量（距文件开头 <code>pos</code> 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 <code>getFilePointer()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">te1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./log.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件指针位置：&quot;</span> + raf.getFilePointer()</span><br><span class="line">                + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) raf.read()</span><br><span class="line">                + <span class="string">&quot;，读取之后指针的位置：&quot;</span> + raf.getFilePointer()</span><br><span class="line">        );</span><br><span class="line">        raf.seek(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件指针位置：&quot;</span> + raf.getFilePointer()</span><br><span class="line">                + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) raf.read()</span><br><span class="line">                + <span class="string">&quot;，读取之后指针的位置：&quot;</span> + raf.getFilePointer()</span><br><span class="line">        );</span><br><span class="line">        raf.write(<span class="string">&#x27;W&#x27;</span>); <span class="comment">//把&#x27;E&#x27;覆盖掉了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件指针位置：&quot;</span> + raf.getFilePointer()</span><br><span class="line">                + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) raf.read()</span><br><span class="line">                + <span class="string">&quot;，读取之后指针的位置：&quot;</span> + raf.getFilePointer()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">文件指针位置：<span class="number">0</span>,当前读取到的字符A，读取之后指针的位置：<span class="number">1</span></span><br><span class="line">文件指针位置：<span class="number">3</span>,当前读取到的字符D，读取之后指针的位置：<span class="number">4</span></span><br><span class="line">文件指针位置：<span class="number">5</span>,当前读取到的字符F，读取之后指针的位置：<span class="number">6</span></span><br><span class="line"> </span><br><span class="line"> 原本：ABCDEFGHIJK    写入W:   ABCDWFGHIJK</span><br></pre></td></tr></table></figure>

<h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>断点续传是由服务器给客户端一个已经上传的位置标记position，然后客户端再将文件指针移动到相应的position，通过输入流将文件剩余部分读出来传输给服务器。</p>
<p>断点下载是由客户端告诉服务器已经下载的大小，然后服务器会将指针移动到相应的position，继续读出，把文件返回给客户端。 当然为了下载的更快一下，也可以多线程下载，那么基本实现就是给每个线程分配固定的字节的文件，分别去读。</p>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong>。</p>
<p>平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。</p>
<p>用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间。</p>
<blockquote>
<p>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</p>
<p>当应用程序发起 I&#x2F;O 调用后，会经历两个步骤：</p>
<ol>
<li>内核等待 I&#x2F;O 设备准备好数据；</li>
<li>内核将数据从内核空间拷贝到用户空间。</li>
</ol>
</blockquote>
<h3 id="常见IO模型"><a href="#常见IO模型" class="headerlink" title="常见IO模型"></a>常见IO模型</h3><ol>
<li>BIO(Blocking)，同步阻塞IO模型。</li>
</ol>
<p>应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>
<ol start="2">
<li>NIO(Non-blocking)</li>
</ol>
<h4 id="同步非阻塞-IO-模型"><a href="#同步非阻塞-IO-模型" class="headerlink" title="同步非阻塞 IO 模型"></a>同步非阻塞 IO 模型</h4><p><img src="/../assets/img/tt.png" alt="tt"></p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<h4 id="IO多路复用模型"><a href="#IO多路复用模型" class="headerlink" title="IO多路复用模型"></a>IO多路复用模型</h4><p><img src="/../assets/img/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.png" alt="88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark"></p>
<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。select 调用：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。epoll 调用：linux <span class="number">2.6</span> 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</span><br></pre></td></tr></table></figure>

<h1 id="Java-NIO-核心知识"><a href="#Java-NIO-核心知识" class="headerlink" title="Java NIO 核心知识"></a>Java NIO 核心知识</h1>]]></content>
  </entry>
  <entry>
    <title>noname1</title>
    <url>/posts/1384cba8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p>Swagger是一套基于 OpenAPI 规范（OpenAPI Specification，OAS）构建的开源工具，可以帮助我们设计、构建、记录以及使用 Rest API。</p>
<p><strong>Swagger 主要包含了以下三个部分：</strong></p>
<ul>
<li><strong>Swagger Editor</strong>：基于浏览器的编辑器，我们可以使用它编写我们 OpenAPI 规范。</li>
<li><strong>Swagger UI</strong>：它会将我们编写的 OpenAPI 规范呈现为交互式的 API 文档，后文我将使用浏览器来查看并且操作我们的 Rest API。</li>
<li><strong>Swagger Codegen</strong>：它可以通过为 OpenAPI（以前称为 Swagger）规范定义的任何 API 生成服务器存根和客户端 SDK 来简化构建过程。</li>
</ul>
<p>引入springfox-boot-starter依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
